\ Este arquivo contém o código fonte do compilador da linguagem de programação "Português Puro"
Uma mensagem de erro é uma string.
Uma contagem de nomes é uma contagem.
Um trecho de listagem é um trecho.
Um sinalizador de erros é um sinalizador.

Um endereço do arquivo atual é um endereço completo.
\Um problema é um número.
Um nome plural é um nome.
Um nome da DLL é um nome.
Um nome da função é um nome.
Um sinalizador de compilação é um sinalizador.
Um endereço é um número.
Um endereço base é um endereço.

Uma zona é uma estrutura com
  Um endereço base,
  Uma quantidade de caracteres e
  Um tamanho.

Um tipo primitivo é um tipo.
Uma rotina alvo é uma rotina.
Um sinalizador de possessivo reverso é um sinalizador.
Um campo de estrutura-membro é um campo de estrutura.
Um sinalizador de redirecionamento é um sinalizador.
Um byte ignorável é um byte.
Uma palavra-chave de referenciamento é uma palavra-chave.
Uma palavra-chave de reutilização de rotina é uma palavra-chave.

Um Cabeçalho DOS é uma estrutura com
\ Documentação: -> https://learn.microsoft.com/pt-br/windows/win32/debug/pe-format
  Uma word denominada Signature,
  Uma word denominada NumberOfBytesOnLastPage,
  Uma word denominada NumberOfPages,
  Uma word denominada Relocations,
  Uma word denominada SizeOfHeaderInParagraphs,
  Uma word denominada MinimumExtraParagraphsNeeded,
  Uma word denominada MamixmumExtraParagraphsNeeded,
  Uma word denominada InitialRelativeSS,  \\ Initial Sstack segment
  Uma word denominada InitialSP,  \\ Initial Stack Pointer value.
  Uma word denominada InitialChecksum,
  Uma word denominada InitialIP,  \\ Initial Instruction Pointer value.
  Uma word denominada InitialRelativeCS, \\ Pre-relocated initial CS register value.
  Uma word denominada AddressOfRelocationTableInFile, \
  Uma word denominada OverlyNumber,
  8 bytes denominados ReservedBytes,
  Uma word denominada OEM_Identifier,
  Uma word denominada OEM_Info,
  20 bytes denominados ReservedWords,
  Um número denominado AddressOfPEHeaderInFile.

Um endereço thunk é um endereço.
Um endereço do nome é um endereço.

Uma função é uma lista com
  Um endereço do nome,
  Um endereço thunk, \ Consulte https://en.wikipedia.org/wiki/Thunk e http://ftp.informatik.rwth-aachen.de/jargon300/thunk.html
  Um nome e
  Um endereço.

Uma expressão matemática é um termo.

Um campo é uma variável.

Um sinalizador de empilhamento é um sinalizador.

Uma rotina de função é uma rotina.

Um campo de estrutura é uma estrutura com
  Um sinalizador de redirecionamento,
  Um campo (referência),
  Uma rotina de função (referência),
  Um sinalizador de empilhamento.

Um fragmento é uma lista com
  \ O compilador gera 3 listas durante o processo de compilação: 
  \ 1. Uma lista de tipos,
  \ 2. Uma lista de variáveis, e 
  \ 3. Uma lista de rotinas
  \ Cada rotina consiste em um conjunto de instruções lógicas.
   \ Essas instruções lógicas são chamadas de "fragmentos"
   \ O compilador trabalha com apenas 22 tipos de instruções lógicas. São elas:
   \  Interrupção,
    \ Demanda Externa,
    \ Demanda Indireta,
    \ Demanda Interna,
    \ Redirecionamento,
    \ Fim de bloco condicional,
    \ Etapa conclusiva,
    \ Retorno,
    \ Finalização,
    \ Incremento,
    \ Decodificação,
    \ Desvio falso,
    \ Carregamento de endereço,
    \ Carregamento EAX,
    \ Iteração,
    \ Negação,
    \ Etapa preliminar,
    \ Empilhamento de endereço,
    \ Empilhamento de valor,
    \ Salvamento EAX,
    \ Reiteração,
    \ Endereço de Rotina
  Uma etiqueta,
  Uma variável (referência) [Demanda Indireta, redirecionamento, increment, load address, load eax, pop, push address, empilhamento de valor, rotina address, salve eax],
  Uma segunda variável (referência) [load address],
  Uma rotina (referência) [Demanda Interna, rotina address],
  Uma função (referência) [Demanda Externa],
  Um número [increment],
  Um sinalizador [load eax], \SAL
  Um endereço,
  Um texto hexadecimal denominado código.

Um corpo de variável global é um subtexto.
Uma variável global é uma variável.

Um cabeçalho da DLL é uma estrutura com
\traduzir isso aqui
  Um endereço denominado primeiro thunk, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-primeiro-thunkoft-milad-kahsari-alhadi/
  \ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft
  \ Thunks são as partes definitivas dos códigos em um sistema operacional que manipula as transições entre o código de 16 e 32 bits.
  \ Assim, eles garantem a compatibilidade com versões anteriores entre as chamadas feitas pelo aplicativo.
  \ O OS está sujeito a esta facilidade para compatibilidade com versões anteriores, de modo que os aplicativos de 16 bits possam funcionar sem problemas em ambientes de 32 bits.
  Um número denominado TimeStamp, \ Set to zero until bound; then this feld is set to the TimeDateStamp of the exporting FileHeader of the DLL
  Um endereço denominado corrente de encaminhamento, \ forward chain: The 32-bit index of the primeiro forwarder in the list of imported functions
  Um endereço denominado endereço do nome, \Esse endereço contém o RVA [Endereço Virtual Relativo] da DLL a ser carregada na memória. É um valor dword.
  \É composto por: RVA = Base da Imagem + Ordem Endian
  Um endereço denominado primeiro endereço thunk de memória.

Uma DLL é uma lista com
  Um endereço do nome,
  Um endereço do cabeçalho,
  Um nome,
  Um cabeçalho da DLL,
  Umas funções.

Um endereço do cabeçalho é um endereço.
Um variável intermediária é uma variável local.
Um valor literal é uma variável.
Uma variável local é uma variável.
Um endereço local é um endereço de byte .
Uma representação interna da rotina é uma string.  \ moniker
\ https://learn.microsoft.com/pt-br/windows/win32/com/monikers
\ Trata-se de uma representação interna de um nome de rotina, sendo que
\ • Não há artigos precedendo os tipos dos parâmetros.
\ • Os tipos dos parâmetros estão rodeados por colchetes.
\ • As preposições são expandidas para incluir seus sinônimos.
\ Cada pedaço de um moniker é uma unidade semântica. Por exemplo:
\ Nome da rotina: Rotina para que se adicione um número para uma contagem:
\ Moniker: adicione [número] em/para [contagem]
\ Monikettes: 
\ 1º: adicione 
\ 2º [número] 
\ 3º em/para 
\ 4º [contagem]
\ Essa representação interna é necessária porque
\ • quando o compilador busca a rotina a ser chamada,
\   a representação interna faz com que seja fácil detectar o tipo base do tipo atual
\   (por exemplo, [contagem] é um tipo derivado de [número])  when looking for an appropriate routine to call;
\ • tampém faz com que seja fácil expandir as preposições
\ • Nos ajuda a entender como o compilador entendeu a invoação da rotina, pois ele exibe a representação nas suas mensagens de erro.

Uma unidade semântica é uma lista com
  Uma string,
  Um tipo (referência),
  Um variável (referência),
  \ para fazer o bubbling
  Um tipo atual (referência),
  Um subtexto atual.

Um cabeçalho compactado é uma representação interna da rotina.
Uma string de erro é uma string.
Um parte da cifra binária é um subtexto.
Um apelido é um nome.

Um parâmetro é uma variável.

Um Cabeçalho PE é uma estrutura com   \ O formato Portable Executable (PE) é baseado na especificação COFF (Common Object File Format).
\Para obter mais informações, consulte https://learn.microsoft.com/pt-br/windows/win32/debug/pe-format
\ O cabeçalho MS-DOS ocupa os primeiros 64 bytes do arquivo. A estrutura básica está representada abaixo:
  Um número denominado Signature,
  Uma word denominada MachineType,
  Uma word denominada NumberOfSections,
  Um número denominado TimeStamp,
  Um número denominado PointerToSymbolTable,
  Um número denominado NumberOfSymbols,
  Uma word denominada SizeOfOptionalHeaderInBytes,
  Uma word denominada Characteristics,
  \ PARTE OPCIONAL - _IMAGE_OPTIONAL_HEADER64
  Uma word denominada MagicNumber,
  Um byte denominado MajorLinkerVersion,
  Um byte denominado MinorLinkerVersion,
  Um número denominado SizeOfCodeInFile, \ SizeOfCode
  Um número denominado SizeOfInitializedDataInFile,
  Um número denominado SizeOfUninitializedDataInFile,
  Um número denominado AddressOfEntryPointInMemory, \ AddressOfEntryPoint
  Um número denominado AddressOfCodeInMemory,  [BaseOfCode]
  Um número denominado AddressOfInitializedDataInMemory, [BaseOfData]
  Um número denominado ImageBase,
  Um número denominado MemoryAlignment, [SectionAlignment]
  Um número denominado FileAlignment,
  Uma word denominada OS_MajorVersion, [MajorOperatingSystemVersion]
  Uma word denominada OS_MinorVersion, [MinorOperatingSystemVersion]
  Uma word denominada UserMajorVersion,  [MajorImageVersion]
  Uma word denominada UserMinorVersion, [MinorImageVersion]
  Uma word denominada SubsystemMajorVersion, [MajorSubsystemVersion]
  Uma word denominada SubsystemMinorVersion, [MinorSubsystemVersion]
  Um número denominado Reserved,  [Win32VersionValue]
  Um número denominado SizeOfImageInMemory, [SizeOfImage]
  Um número denominado SizeOfAllHeadersInFile, [SizeOfHeaders]
  Um número denominado CheckSum,
  Uma word denominada Subsystem,
  Uma word denominada DLLCharacteristics,
  Um número denominado MaxStack, [SizeOfStackReserve]
  Um número denominado MinStack, [SizeOfStackCommit]
  Um número denominado MaxHeap, [SizeOfHeapReserve]
  Um número denominado MinHeap, [SizeOfHeapCommit]
  Um número denominado LoaderFlags,  \ _IMAGE_OPTIONAL_HEADER64
  Um número denominado NumberOfDirectories, [NumberOfRvaAndSizes]
  8 bytes denominados Directory0,
  Um número denominado ImageDirectoryEntryImportAddress,
  Um número denominado ImageDirectoryEntryImportSize,
  112 bytes denominados Directories2-15,
  Um Cabeçalho de Seção PE denominado Idata Section,
  Um Cabeçalho de Seção PE denominado Data Section,
  Um Cabeçalho de Seção PE denominado Code Section.

Um Cabeçalho de Seção PE é uma estrutura com
  8 bytes denominados Nome, \ Each section header has a name fielf up to eight characters em comprimento, for which the primeiro character must be a period.
  Um número denominado SizeInBytes,
  Um número denominado AddressInMemory,
  Um número denominado SizeInFile,
  Um número denominado AddressInFile,
  12 bytes denominados Reserved,
  Um número denominado Characteristics. \ Defines the section Characteristics.
  \These values are encontrado both em WINNT.H and in the Portable Executable Format specification.

Uma frase é uma string.

Um protótipo de string é uma estrutura com
  Um caractere inicial e
  Um caractere final .

Um campo português é um campo.
Um campo português feminino é um campo.
Um tipo encadeado é um tipo.
Um tipo estruturado é um tipo.
Um tipo base é um tipo.
Uma instrução é um subtexto.
Um cabeçalho de rotina é um subtexto.
Um tamanho local é um tamanho.
Um sinalizador de função é um sinalizador.
Uma representação de emprego é uma representação interna da rotina.
\Um catálogo de apelidos é um catálogo.

Uma rotina é uma lista com
  Um endereço local (referência),
  Um sinalizador de compatibilidade,
  Um sinalizador de deliberação,
  Um sinalizador de função,
  Um sinalizador de compilação,
  Um catálogo denominado catálogo de apelidos, \ alocação dinâmica. Verificar
  Uma representação interna da rotina,
  Umas unidades semânticas,
  Uns parâmetros,
  Um tamanho do parâmetro,
  Uma representação de emprego,
  Umas variáveis locais,
  Um tamanho local,
  Um cabeçalho de rotina,
  Uma string do cabeçalho,
  Umas instruções,
  Uma string do corpo,
  Uns fragmentos,
  Um endereço.

Uma string do corpo é uma string.
Uma string do cabeçalho é uma string.
Uma referência da rotina é [composta de] umas unidades semânticas.
Uma palavra-chave é uma string.
Uma palavra-chave de designação é uma palavra-chave.
Um variável temporária de compilação é uma variável local.

Um arquivo fonte é uma lista com
  Um endereço completo e
  Um trecho.

Os arquivos fontes são uns arquivos fontes.

Uma etiqueta é um número.

Um termo é uma estrutura com
  Uma variável e
  Uma frase.

Um tamanho do parâmetro é um tamanho.
Um nome do tipo primitivo é um nome.
Um sinalizador de informações complementares é um sinalizador.

Um tipo é uma lista com
  Um endereço local (referência),
  Um nome,
  Um nome plural,
  Um cabeçalho compactado,
  Uma quantidade de caracteres,
  Um nome do tipo primitivo,
  Um tipo base (referência),
  Um nome do conteúdo,
  Um tipo do conteúdo (referência) [aplicável somente a ponteiros],
  Uma razão de escala,
  Uns campos [aplicável somente a estruturas],
  Um sinalizador de recursividade,
  Um sinalizador de informações complementares.

Um sinalizador de recursividade é um sinalizador.
Um nome do tipo é um nome.

Uma variável é uma lista com
  Um endereço local (referência),
  Um categoria [lvalor iteral, variável global, variável local, parâmetro, variável temporária de compilação],
  Um sinalizador de compilação,
  Um nome,
  Um apelido,
  Um nome do tipo,
  Um tipo (referência), \ tipo real no caso de valores literais, variáveis globais e locais; tipos revogados em parâmetros e variável temporária de compilaçãoes
  Um endereço [variáveis globais e valores literais somente] ou
  Um deslocamento sob o endereço [variáveis locais, parâmetros, e campos somente],
  Uma contagem [campos somente],
  Um sinalizador de referência [campos somente],
  Um novo nome [campos somente],
  Um sinalizador de passagem por-valor [parâmetros somente],
  Um corpo de variável global [variáveis globais somente],
  Um texto inicializador [variáveis globais somente],
  Um valor literal (referência) [variáveis globais somente - constante com a qual se inicializa a variável global],
  Um texto hexadecimal denominado data [literais somente].

Um deslocamento é um número.
Um texto inicializador é uma string.
Um sinalizador de referência é um sinalizador.
Um sinalizador de passagem por-valor é um sinalizador.
Um novo nome é um nome.

O temporizador de escrita é um temporizador.
\ Um temporizador é uma estrutura com uma contagem, uns intervalos iniciais e uns intervalos totais.
\ Um intervalo é um número.
O temporizador de transmutação é um temporizador.
O temporizador de análise/verificação é um temporizador.
O temporizador de resolução de variáveis globais é um temporizador.
O temporizador de resolução de tipos é um temporizador.
O temporizador de operacionalização é um temporizador.
O temporizador de deslocamentos é um temporizador.
O temporizador de vinculação é um temporizador.
O temporizador de ferramentas de catalogação é um temporizador.
O temporizador de compilação do conteúdo das rotinas é um temporizador.
O temporizador de compilação de cabeçalhos de rotina é um temporizador.
O temporizador de etapas de cálculo é um temporizador.
O temporizador de endereçamento é um temporizador.
O temporizador de adição de rotinas pré-definidas de mémoria é um temporizador.
O temporizador de adição de rotinas pré-definidas de inicialização é um temporizador.

A etiqueta de interrupção é uma etiqueta igual a 1.
A etiqueta de demanda externa é uma etiqueta igual a 2.
A etiqueta de demanda indireta é uma etiqueta igual a 3.
A etiqueta de demanda interna é uma etiqueta igual a 4.
A etiqueta de redirecionamento é uma etiqueta igual a 5.
A etiqueta delimitadora de bloco condicional é uma etiqueta igual a 6.
A etiqueta conclusiva é uma etiqueta igual a 7.
A etiqueta de retorno é uma etiqueta igual a 8.
A etiqueta de finalização é uma etiqueta igual a 9.
A etiqueta de acréscimo é uma etiqueta igual a 10.
A etiqueta de decodificação é uma etiqueta igual a 11.
A etiqueta de desvio falso é uma etiqueta igual a 12.
A etiqueta de carregamento de endereço é uma etiqueta igual a 13.
A etiqueta de carregamento de registrador EAX é uma etiqueta igual a 14.
A etiqueta de laço é uma etiqueta igual a 15.
A etiqueta de negação lógica é uma etiqueta igual a 16.
A etiqueta preliminar é uma etiqueta igual a 17.
A etiqueta de inserção de endereço [na stack] é uma etiqueta igual a 18.
A etiqueta de inserção de valor [na stack] é uma etiqueta igual a 19.
A etiqueta de obtenção do registrador EAX é uma etiqueta igual a 20.
A etiqueta de repetição é uma etiqueta igual a 21.
A etiqueta de endereço de rotina é uma etiqueta igual a 22.

O compilador é uma estrutura com
  Um endereço da pasta,
  Um temporizador,
  Um sinalizador de erros,
  Um mensagem de erro,
  Um endereço do arquivo atual,
  Um número da linha de erro,
  Uma contagem de nomes,
  Um trecho exe,
  Um trecho de listagem.

O catálogo de variáveis globais é um catálogo.
As variáveis globais são umas variáveis globais.
A image base é um endereço igual a 4194304 [$00400000].
A seção de DLLs é uma zona.
As DLLs são umas DLLs.
O catálogo de variáveis hexadecimais é um catálogo.
Os valores literais são uns valores literais.
O catálogo geral de rotinas é um catálogo.
As rotinas são umas rotinas.
O catálogo de tipos é um catálogo.
O nome do conteúdo é um nome.
O tipo do conteúdo é um tipo.
Os tipos são uns tipos.
O catálogo de rotinas úteis é um catálogo.
O endereço do cabeçalho usado atualmente é um endereço.
O endereço do nome usado atualmente é um endereço.
O rotina utilizada atualmente é uma rotina.
O endereço pré-calculado atual é um endereço.
A região de dados é um zona.
O percorredor de contrações é um percorredor.
A Região de Código é um zona.
As variáveis globais predefinidas são umas variáveis globais.

\ firstparam=esp+4/ebp+8,
\secondparam=esp+8/ebp+12, etc...

\ Strings são implementadas como uma struct que contém 2 membros, a saber:
\ O endereço do byte inicial e o endereço do byte final.
\ Desta forma é possível trocar o primeiro e o último bytes de uma string, com um comandos como este:
\ Permute o conteúdo deste caractere inicial desta string com o conteúdo do caractere final desta string.

\ Parâmetros são passados por referência

\ Os registradores EBP (ponteiro base) e ESP (ponteiro de pilha) são usados para manipular a PILHA
\ que é uma área da memória que você pode imaginar como uma pilha de pratos,
\ sendo que cada prato representando um valor salvo em um registrador,
\ ou um endereço em algum lugar no código do programa,
\ ou o endereço de uma variável (que reside em algum outro lugar na memória),
\ ou o conteúdo de uma variável.

\ Como é típico do Windows, a pilha cresce inversamente.
\ ou seja, o endereço do “topo” da pilha é sempre menor que o endereço da base.

\ O registrador ESP sempre contém o endereço do “topo” da pilha.
\O registrador EBP contém o endereço da “base” da pilha da rotina atual.
\ Por convenção, é assim que a pilha é usada em Português Puro 
\ (C usa o STACK de maneira semelhante, mas envia os parâmetros na ordem inversa):

\ Você pode ver que dessa forma,  o primeiro parâmetro de uma rotina estará no endereço do registrador EBP + 8,
\ o segundo parâmetro estará no endereço em EBP + 12, etc.
\ E que nossas variáveis locais serão estarão no endereço no registrador EBP menos 4, menos 8, etc,
\ dependendo, é claro, do tamanho de cada uma dessas variáveis.

\ O prólogo de cada rotina em português puro começa salvando o ebp do chamador na pilha, logo acima do endereço de retorno.
\ O epílogo de cada rotina remove quaisquer variáveis locais, restaura o ebp e retorna ao chamador, estabelecendo quaisquer parâmetros enquanto ele assim o faz.
\ Os programas em C operam de maneira semelhante.

\ A CPU Intel sabe como colocar valores e endereços de 4 bytes na pilha e como recuperá-los.
\ Para colocar e retirar coisas maiores da pilha, precisamos lidar diretamente com o registro ESP.
\ Subtrair 16 do endereço no ESP, por exemplo, abre espaço para 16 bytes de dados locais no “topo” da pilha; adicionar 16 tira esses bytes da pilha.


\ Rotina para que se execute o programa:
  \ Atribua "console" para o tipo da aplicação.
  \ Inicialize os componentes.
  \\Inicialize o compilador.
  \ Faça tudo.
  \ Finalize o compilador.
  \ Escreva na próxima linha em StdOut.
  \ Escreva "Operação finalizada." junto com o texto CRLF para o painel de informações.
  \\Execute os eventos.\
  \ Feche o programa.

Rotina para que se faça tudo:
  Atribua 1252 a um número denominado codepage.
  Processe "kernel32.dll" "SetConsoleOutputCP" com o codepage retornando um número denominado status de erro.
  Se o status de erro for 0 [NULL],
    Escreva "Código de Erro #001. Erro ao definir o CodePage do Console para STDOUT." junto com o texto CRLF para o painel de informações.
  Obtenha uma string desde os argumentos da linha de comando.
  Se a string estiver em branco,
    Escreva "--------------------------------------------------------------------------------------------------------------- " junto com o texto CRLF para StdOut;
    Escreva "Aviso. Para utilizar este compilador, você deve invocá-lo através da linha de comando. " junto com o texto CRLF para StdOut;
    Escreva "Para fazer isso, abra o Prompt de Comando (cmd.exe), navegue até a pasta do compilador e digite:" junto com o texto CRLF para StdOut;
    Escreva " " junto com o texto CRLF para StdOut;
    Escreva " c:\endereço_do_compilador.exe\  c:\pasta_do_projeto_atual\ " junto com o texto CRLF para StdOut;
  Retorne.
  Se o conteúdo deste caractere final desta string não for a barra invertida,
    Acrescente a barra invertida para a string.
  Se a string não estiver no sistema de arquivos,
    Escreva "Código de Erro #002. O diretório '" junto com a string seguido de "' não foi encontrado." junto com o texto CRLF para StdOut;
    Retorne.
  Escreva "Compilando o diretório '" junto com a string seguido de "' ..." junto com o texto CRLF para o painel de informações. \ #0
  Escreva o texto CRLF para o painel de informações.
  Compile a string.
  Se existir algum problema de compilação,
    Exiba o erro de compilação;
    Retorne.
  Escreva "Tempo de compilação: " junto com a string deste temporizador deste compilador seguido de " ms" junto com o texto CRLF para o painel de informações.

Rotina para que se obtenha uma string desde os argumentos da linha de comando:
  Processe "kernel32.dll" "GetCommandLineA" 
    Retornando um endereço do caractere.
  Converta o endereço do caractere para uma string denominada argumentos.
  Lance um subtexto sobre os argumentos.
  Itere.
    Se o subtexto estiver em branco,
      Limpe a string;
      Retorne.
    Se o conteúdo deste caractere inicial deste subtexto não for o caractere de espaço,
      Adicione 1 para o caractere inicial deste subtexto;
      Reitere.
    Atribua o subtexto para a string.
    Elimine os resíduos na string.
  \Reitere.

Rotina para que se compile um endereço da pasta:
  Compile o endereço da pasta (inicialização). \ #001
  Compile o endereço da pasta (arquivos de código fonte). \ #002
  Compile o endereço da pasta (análise dos arquivos fornecidos). \ #003
  Compile o endereço da pasta (identificação dos tipos das variáveis). \ #004
  Compile o endereço da pasta (identificação de variáveis globais). \ #005
  Compile o endereço da pasta (cabeçalhos de rotinas). \ #006
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos). \ #007
  Compile o endereço da pasta (adição de rotinas de memória incorporadas). \ #008
  Compile o endereço da pasta (catalogue as rotinas por utilização). \ #009
  Compile o endereço da pasta (conteúdo das rotinas). \ #010
  Compile o endereço da pasta (adição e compilação da rotina de inicialização). \ #011
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis). \ #012
  Compile o endereço da pasta (endereço). \ #013
  Compile o endereço da pasta (transmutação). \ #014
  Compile o endereço da pasta (vinculação). \ #015
  Compile o endereço da pasta (etapa final). \ #016
  Compile o endereço da pasta (interrupção). \ #017

Rotina para que se exiba o erro de compilação:
  Se o endereço do arquivo atual deste compilador estiver em branco,
    Escreva a mensagem de erro deste compilador para StdOut;
    Retorne.
  Escreva 
    A mensagem de erro deste compilador seguido de "Arquivo: " 
      junto com o endereço do arquivo atual deste compilador 
      junto com o texto CRLF
      seguido de "Linha: " 
      junto com o número da linha de erro deste compilador
    para o painel de informações.
  Escreva o texto CRLF para o painel de informações.

Rotina para que se finalize o compilador:
  Destrua o catálogo de rotinas úteis.
  Destrua o catálogo geral de rotinas.
  Destrua o catálogo de variáveis hexadecimais.
  Destrua o catálogo de variáveis globais.
  Destrua o catálogo de tipos.
  \Destrua o catálogo de apelidos.
  Destrua as DLLs.
  Destrua as rotinas.
  Destrua os valores literais.
  Destrua as variáveis globais.
  Destrua as variáveis globais predefinidas.
  Destrua os tipos.
  Destrua os arquivos fontes.




\---------------------------------------------------------------------------- ROTINAS EXTRAS------------------------------------------------------

Rotina para que se compile um endereço da pasta usando um nível de profundidade:
  Atribua 1 ao nível de profundidade.
  Compile o endereço da pasta (inicialização). \ #001
  Compile o endereço da pasta (arquivos de código fonte). \ #002
  \Compile o endereço da pasta usando o nível de profundidade (arquivos de código fonte). \ #002
  Defina uma variável global usando "O código de retorno é um número.".
  Compile o endereço da pasta (análise dos arquivos fornecidos). \ #003
  Compile o endereço da pasta (identificação dos tipos das variáveis). \ #004
  Compile o endereço da pasta (identificação de variáveis globais). \ #005
  Compile o endereço da pasta (cabeçalhos de rotinas). \ #006
  Compile o endereço da pasta (cálculo de tamanhos e deslocamentos). \ #007
  Compile o endereço da pasta (adição de rotinas de memória incorporadas). \ #008
  Compile o endereço da pasta (catalogue as rotinas por utilização). \ #009
  Compile o endereço da pasta (conteúdo das rotinas). \ #010
  Compile o endereço da pasta (adição e compilação da rotina de inicialização). \ #011
  Compile o endereço da pasta (deslocamento de parâmetros e variáveis). \ #012
  Compile o endereço da pasta (endereço). \ #013
  Compile o endereço da pasta (transmutação). \ #014
  Compile o endereço da pasta (vinculação). \ #015
  Compile o endereço da pasta (etapa final). \ #016
  Compile o endereço da pasta (interrupção). \ #017

Rotina para que se defina uma variável global usando uma string:
  Se existir algum problema de compilação, retorne.
  Preserve a string.
  Se a string começa com "O ",
    Remova os caracteres iniciais desde a string usando 2.
  Se a string começa com "A ",
    Remova os caracteres iniciais desde a string usando 2.
  Se a string começa com "Os ",
    Remova os caracteres iniciais desde a string usando 3.
  Se a string começa com "As ",
    Remova os caracteres iniciais desde a string usando 3.
  Remova os caracteres ignoráveis no final dessa string.
  Lance um percorredor sobre a string.
  Examine uma variável global usando o percorredor. \ ETAPA 03
  Atribua inexistente no endereço local desta variável global.
  Duplique a variável global retornando uma segunda variável global.
  Acrescente a segunda variável global para as variáveis globais prededinidas.

Rotina para que se compile um endereço da pasta usando um nível de profundidade (arquivos de código fonte): \#002
  Se existir algum problema de compilação, retorne.
  Escreva "Carregando arquivos..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de operacionalização.
  Carregue os arquivos fontes usando o nível de profundidade.
  Suspenda o temporizador de operacionalização.

Rotina para que se carregue uns arquivos fonte usando um nível de profundidade: \ Jasper
  Leia os arquivos fonte usando o endereço completo deste compilador e o nível de profundidade.

Rotina para que se carregue uns arquivos fonte usando um endereço da pasta e um nível de profundidade: \Jasper
  Atribua ".pop" a uma nova extensão.
  Anexe o caractere NULL após a nova extensão.
  Se o nível de profundidade for menor do que 1, retorne.
  Preserve o nível de profundidade.
  Atribua o nível de profundidade para um segundo nível de profundidade.
  Subtraia 1 desde o segundo nível de profundidade.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um item desde o endereço da pasta.
    Se o item não for encontrado, pare.
    Se a categoria deste item for "endereço de pasta",
      Leia os arquivos fonte usando o endereço da pasta deste item e o segundo nível de profundidade;
      Reitere.
    Se a categoria deste item não for "arquivo", reitere.
    Se a extensão deste  item não for a nova extensão, reitere.
    Se o item parece ser encadernável, reitere.
    Se o item parece ser lexical, reitere.
    Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    Carregue o arquivo fonte.
  Reitere.

Função para que se determine se uma variável global está causando conflitos: \ Jasper Paulsen
  Se o nome desta variável global não estiver no catálogo de variáveis globais, diga não.
  Se a variável global estiver perfeitamente predefinida, diga não.
  Diga sim.

Função para que se determine se uma variável global está perfeitamente predefinida: \ Jasper Paulsen
  Itere.
    Obtenha uma segunda variável global desde as variáveis globais prededinidas.
    Se a segunda variável global for inexistente, diga não.
    Se a variável for alguma cópia dessa segunda variável global, diga sim.
  Reitere.

Função para que se determine se uma variável global é alguma cópia de uma segunda variável global: \ Jasper Paulsen
  Se a variável global for inexistente, diga não.
  Se a segunda variável global for inexistente, diga não.
  \ OK to have different loci.
  Se a categoria desta variável global não for "variável global", diga não.
  Se a categoria desta segunda variável global não for "variável global", diga não.
  Se o nome desta variável global não for o nome desta segunda variável global, diga não.
  Se o nome do tipo desta variável global não for o nome do tipo desta segunda variável global, diga não.
  Se o corpo de variável global desta variável global não for o corpo de variável global desta segunda variável global, diga não.
  Diga sim.

Função para que se determine se um item parece ser lexical: \ Jasper
  \Verifiqua progressivamente as porções maiores do arquivo (em bytes).
  Se o item não parece ser lexical usando 200, diga não.
  Se o item não parece ser lexical usando 10000, diga não.
  Se o item não parece ser lexical usando o maior número, diga não.
  Diga sim.

Função para que se determine se um item parece ser lexical usando um tamanho: \ Jasper
  \ O arquivo de léxico não inclui pontos.
  \ Os arquivos de código incluem pontos.
  Leia o endereço completo deste item em um trecho utilizando o tamanho.
  Se o trecho contém um ".", diga não.
  Diga sim.

Função para que se determine se um trecho contém uma string;
Função para que se determine se uma string contém uma segunda string:
  Se a segunda string estiver na string, diga sim.
  Diga não.

\ Rotina para que se carregue uns arquivos fontes:
  \ Atribua ".pop" a uma nova extensão.
  \ Anexe o caractere NULL após a nova extensão.
  \ Itere.
    \ Se existir algum problema de compilação, retorne.
    \ Obtenha um item desde o endereço da pasta deste compilador.
    \ Se o item não for encontrado, pare.
    \ Se a categoria deste item não for "arquivo", reitere.
    \ Se a extensão deste  item não for a nova extensão, reitere.
    \ Se o item parece ser encadernável, reitere.
    \ Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    \ Carregue o arquivo fonte.
  \ Reitere.

\ Rotina para que se mostre uma string no painel de informações;
\ Rotina para que se mostre no painel de informações uma string:
  \ Escreva a string para o painel de informações.

Rotina para que se execute os eventos:
  [Itere.]
    Desenfileire um evento.
    Se o evento for inexistente, retorne.
    Execute o evento.
  Reitere.

\ Rotina para que se execute um evento:
  \ Se a categoria deste evento for "pressionamento de tecla",
    \ Renuncie ao controle;
    \ Retorne.

\------------------------------------------------------------------------------------------------------------------------------------


Rotina para que se compile um endereço da pasta (inicialização): \#001
  Escreva "Iniciando..." junto com o texto CRLF para o painel de informações.
  Finalize o compilador.
  Comece o temporizador deste compilador.
  Inicialize o compilador usando o endereço da pasta.
  Adicione os tipos primitivos.

Rotina para que se escreva uma string para o painel de informações:
  Atribua a string à string deste painel de informações.
  Mostre o painel de informações.

Rotina para que se inicialize o compilador usando um endereço da pasta:
  Atribua o endereço da pasta ao endereço da pasta deste compilador.
  Zere a contagem de nomes deste compilador.
  Limpe o sinalizador de erros deste compilador.
  Limpe a mensagem de erro deste compilador.
  Limpe o endereço do arquivo atual deste compilador.
  Limpe o número da linha de erro deste compilador.
  Esvazie a rotina utilizada atualmente.
  Crie o catálogo de tipos com 13001 [recipientes]. \ era 4027
  Crie o catálogo de variáveis globais com 13001 [recipientes]. \ era 4027
  Crie o catálogo de variáveis hexadecimais com 13001 [recipientes]. \ era 4027
  Crie o catálogo geral de rotinas com 13001 [recipientes]. \ era 7919
  Crie o catálogo de rotinas úteis com 13001 [recipientes]. \ era 4027

Rotina para que se adicione os tipos primitivos:
  Adicione um tipo primitivo usando "byte" e "bytes" e 1.
  Adicione um outro tipo primitivo usando "estrutura" e "estruturas" e 0.

Rotina para que se adicione um tipo primitivo usando um nome e um nome plural e uma quantidade de caracteres:
  Adicione o tipo primitivo para os tipos usando o nome e o nome plural e o nome. \ o nome do tipo
  Atribua a quantidade de caracteres à quantidade de caracteres deste tipo primitivo.
  Atribua o tipo primitivo ao tipo base deste tipo primitivo.
  Catalogue o tipo primitivo.

Rotina para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo:
  Adicione o tipo para os tipos usando o nome e o nome plural e o nome do tipo primitivo e nulo.

Rotina para que se adicione um tipo para uns tipos usando um nome e um nome plural e um nome do tipo primitivo e um endereço local:
  Crie o tipo.
  Acrescente o tipo para os tipos. \ Um tipo é uma lista duplamente encadeada
  Atribua o endereço local ao endereço local deste tipo.
  Atribua o nome ao nome deste tipo.
  Atribua o nome plural ao nome plural deste tipo.
  Atribua o nome do tipo primitivo ao nome do tipo primitivo deste tipo.

Rotina para que se crie um tipo:
  Aloque memória para o tipo.
  Atribua 0/1 à razão de escala deste tipo.
  Atribua -1 à quantidade de caracteres deste tipo.

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (arquivos de código fonte): \#002
  Se existir algum problema de compilação, retorne.
  Escreva "Carregando arquivos..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de operacionalização.
  Carregue os arquivos fontes.
  Suspenda o temporizador de operacionalização.

Função para que se determine se há algum problema de compilação;
Função para que se determine se existe algum problema de compilação:
  Se o sinalizador de erros deste compilador estiver ativado, diga sim.

Rotina para que se carregue uns arquivos fontes:
  Atribua ".pop" para uma nova extensão.
  Anexe o caractere NULL após a nova extensão.
  Itere.
    Se existir algum problema de compilação,
      Retorne.
    Obtenha um item desde o endereço da pasta deste compilador.
    Se o item não for encontrado,
      Pare.
    Se a categoria deste item não for "arquivo",
      Reitere.
    Se a extensão deste  item não for a nova extensão,
      Reitere.
    \Se o item parece ser encadernável, reitere.
    Adicione um arquivo fonte para os arquivos fontes usando o endereço completo deste item.
    Carregue o arquivo fonte.
  Reitere.

Função para que se determine se um item parece ser encadernável:
  Carregue o endereço completo deste item para um trecho.
  Se o trecho começa com "ream cal", diga sim. \ ream
  Se o trecho começa com "ream SAL", diga sim. \
  Se o trecho começa com "ream CEL", diga sim. \ 
  Se o trecho começa com "Este documento foi produzido pelo Editor de Documentos - CEL", diga sim.
  Diga não.

Rotina para que se adicione um arquivo fonte para uns arquivos fontes usando um endereço completo:
  Crie o arquivo fonte.
  Acrescente o arquivo fonte para os arquivos fontes.
  Atribua o endereço completo ao endereço completo deste arquivo fonte.

Rotina para que se crie um arquivo fonte:
  Aloque memória para o arquivo fonte.

Rotina para que se carregue um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  \Carregue o endereço completo deste arquivo fonte para o trecho deste arquivo fonte.
  Carregue o endereço completo deste arquivo fonte para uma string. \ necessário para expandir contrações.
  Se o erro do fluxo de entrada/saída não estiver em branco,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #003. Não foi possível carregar o arquivo '" 
        junto com o endereço completo deste arquivo fonte 
        seguido de "'. Verifique o arquivo possui permissão de leitura ou se está sendo usado por outro processo." junto com o texto CRLF;
    Retorne.
  Parse a string para o trecho deste arquivo fonte (para expandir contrações).

Rotina para que se parse uma string para uma segunda string (para expandir contrações):
  Limpe a segunda string.
  Limpe uma terceira string.
  Lance o percorredor de contrações sobre a string.
  Itere.
    Se o segmento final deste percorredor de contrações estiver em branco, retorne.
    Posicione o segmento inicial deste percorredor de contrações sobre o segmento final deste percorredor de contrações.
    Mova o percorredor de contrações (englobando tudo).
    Se o percorredor de contrações estiver sobre alguma preposição conectiva,
      Acrescente "par" para a segunda string. \ converte o "a" em "para" ("par" + "a"), quando aplicável
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor de contrações não for um byte ignorável,
      Acrescente o segmento inicial deste percorredor de contrações para a segunda string;
      Reitere.
    Acrescente o segmento inicial deste percorredor de contrações para a segunda string usando a terceira string (para expandir contrações).
    Atribua o segmento inicial deste percorredor de contrações à terceira string.
  Reitere.

Função para que se determine se um byte é um byte ignorável:
  Se o byte for algum letra, diga sim.
  Se o byte for algum dígito, diga sim.
  Se o byte for o acento til, diga sim.
  Se o byte for o sinal de arroba, diga sim.
  Se o byte for o símbolo cardinal, diga sim.
  Se o byte for o sinal de porcentagem, diga sim.
  Se o byte for o & comercial, diga sim.
  Se o byte for o underline, diga sim.
  Se o byte for o apóstrofo, diga sim.
  Se o byte for o hífen, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o barra inclinada, diga sim.
  Se o byte for o símbolo da Libra Esterlina, diga sim.
  Diga não.

Rotina para que se mova um percorredor (englobando tudo):
  Posicione o segmento inicial deste percorredor sobre o segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  \Se o conteúdo deste caractere inicial deste segmento final deste percorredor for "a",
  \ Avance o percorredor.
  \ Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum artigo indefinido,
  \ Recue o percorredor; atribua "para" para o percorredor.  
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante,
    Mova o percorredor (ignorando os caracteres irrelevantes);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for a barra invertida,
    Mova o percorredor (ignorando os comentários);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo,
    Mova o percorredor (ignorando as observações);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas,
    Mova o percorredor (strings literais);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo,
    Mova o percorredor (qualificadores);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor for algum sinal de pontuação,
    Mova o percorredor (sinais de pontuação);
    Retorne.
  Se o percorredor estiver sobre algum possessivo inglês,
    Mova o percorredor (possessivo inglês);
    Retorne.
  Mova o percorredor (símbolos conectivos).

\ Função para que se determine se um byte é irrelevante:
  \ Se o byte for menor do que ou igual ao caractere de espaço, diga sim.
  \ Se o byte for o [ANTIGO] símbolo DEL [que agora está descontinuado], diga sim.
  \ Se o byte for o espaço rígido, diga sim.
  \ Se o byte for 129, diga sim. \ Unused
  \ Se o byte for 141, diga sim. \ Unused
  \ Se o byte for 143, diga sim. \ Unused
  \ Se o byte for 144, diga sim. \ Unused
  \ Se o byte for 157, diga sim. \ Unused
  \ Diga não.

Rotina para que se mova um percorredor (ignorando os caracteres irrelevantes):
  \Itere.
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for irrelevante, reitere.

Rotina para que se mova um percorredor (ignorando os comentários):
  [Itere.]
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o retorno de carro, reitere.

Rotina para que se mova um percorredor (ignorando as observações): \ pode ser aperfeiçoado
  [Itere.]
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare. \ para não abranger múltiplas linhas. Poderia ser removido.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete esquerdo,
      Adicione 1 para uma contagem.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o colchete direito,
      Subtraia 1 desde a contagem.
    Avance o percorredor.
    Se a contagem for 0, pare.
  Reitere.

Rotina para que se mova um percorredor (strings literais):
  \Itere.
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, retorne.
    \ para não abranger múltiplas linhas. Poderia ser removido.
    Se o percorredor estiver sobre múltiplas aspas duplas aninhadas,
      Avance o percorredor;
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for as aspas duplas,
      Avance o percorredor;
      Retorne.
  Reitere.

Função para que se determine se um percorredor está sobre múltiplas aspas duplas aninhadas:
  Se o segmento final deste percorredor começa com """""", diga sim.
  Diga não.

Rotina para que se mova um percorredor (qualificadores):
  \Itere.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o retorno de carro, pare.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses esquerdo,
      Adicione 1 para uma contagem.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for o parênteses direito,
      Subtraia 1 desde a contagem.
    Avance o percorredor.
    Se a contagem for 0, pare.
  Reitere.

Rotina para que se mova um percorredor (sinais de pontuação):
  Avance o percorredor.

Função para que se determine se um percorredor está sobre algum possessivo inglês:
  Se o segmento final deste percorredor estiver em branco, diga não.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o apóstrofo, diga não. \ apóstrofo
  Se o percorredor estiver sobre algum possessivo inglês (tipo 1 - 's), diga sim.
  Se o percorredor estiver sobre algum possessivo inglês (tipo 2 - s'), diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo inglês (tipo 1 - 's):
  Se o segmento final deste percorredor não começa com "'s", diga não.
  Preserve o percorredor.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo inglês (tipo 2 - s'):
  Preserve o percorredor.
  Se o caractere inicial deste segmento final deste percorredor for o caractere inicial desta cópia da string original deste percorredor, diga não.
  Subtraia 1 desde o caractere inicial deste segmento final deste percorredor.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for o s minúsculo ou o S maiúsculo, diga não.
  Adicione 2 para o caractere inicial deste segmento final deste percorredor.
  Se o segmento final deste percorredor estiver em branco, diga sim.
  Se o conteúdo deste caractere inicial deste segmento final deste percorredor não for um byte ignorável, diga sim.
  Diga não.

Rotina para que se mova um percorredor (possessivo inglês):
  Avance o percorredor.
  Se o segmento final deste percorredor estiver em branco, retorne.
  Se o segmento final deste percorredor começa com "s",
    Avance o percorredor.

Rotina para que se mova um percorredor (símbolos conectivos):
  \Itere.
    Avance o percorredor.
    Se o segmento final deste percorredor estiver em branco, retorne.
    Se o percorredor estiver sobre algum possessivo inglês, retorne.
    Se o conteúdo deste caractere inicial deste segmento final deste percorredor for um byte ignorável, reitere.

Rotina para que se acrescente uma string para uma segunda string usando uma terceira string (para expandir contrações):
  \contrações
  Se a string for "ao",
    Acrescente "a o" para a segunda string;
    Retorne.
  Se a string for "à",
    Acrescente "a a" para a segunda string;
    Retorne.
  Se a string for "aos",
    Acrescente "a os" para a segunda string;
    Retorne.
  Se a string for "às",
    Acrescente "a as" para a segunda string;
    Retorne.
  Se a string for "dum",
    Acrescente "de esse" para a segunda string;
    Retorne.
  Se a string for "duma",
    Acrescente "de essa" para a segunda string;
    Retorne.
  Se a string for "dumas",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "duns",
    Acrescente "de esses" para a segunda string;
    Retorne.
  Se a string for "desse",
    Acrescente "de o" para a segunda string;
    Retorne.
  Se a string for "dessa",
    Acrescente "de a" para a segunda string;
    Retorne.
  Se a string for "desses",
    Acrescente "de os" para a segunda string;
    Retorne.
  Se a string for "dessas",
    Acrescente "de as" para a segunda string;
    Retorne.
  Se a string for "deste",
    Acrescente "de este" para a segunda string;
    Retorne.
  Se a string for "desta",
    Acrescente "de esta" para a segunda string;
    Retorne.
  Se a string for "destes",
    Acrescente "de estes" para a segunda string;
    Retorne.
  Se a string for "destas",
    Acrescente "de estas" para a segunda string;
    Retorne.
  Se a string for "nesse",
    Acrescente "em esse" para a segunda string;
    Retorne.
  Se a string for "nesses",
    Acrescente "em esses" para a segunda string;
    Retorne.
  Se a string for "neste",
    Acrescente "em este" para a segunda string;
    Retorne.
  Se a string for "nestes",
    Acrescente "em estes" para a segunda string;
    Retorne.
  Se a string for "nessa",
    Acrescente "em essa" para a segunda string;
    Retorne.
  Se a string for "nessas",
    Acrescente "em essas" para a segunda string;
    Retorne.
  Se a string for "nesta",
    Acrescente "em esta" para a segunda string;
    Retorne.
  Se a string for "nestas",
    Acrescente "em estas" para a segunda string;
    Retorne.
  Se a string for "na",
    Acrescente "em a" para a segunda string;
    Retorne.
  Se a string for "no",
    Acrescente "em o" para a segunda string;
    Retorne.
  Se a string for "nos",
    Acrescente "em os" para a segunda string;
    Retorne.
  Se a string for "nas",
    Acrescente "em as" para a segunda string;
    Retorne.
  Se a string for "num",
    Acrescente "em um" para a segunda string;
    Retorne.
  Se a string for "numa",
    Acrescente "em uma" para a segunda string;
    Retorne.
  Se a string for "nuns",
    Acrescente "em uns" para a segunda string;
    Retorne.
  Se a string for "numas",
    Acrescente "em umas" para a segunda string;
    Retorne.
  Se a string for "pelo",
    Acrescente "por o" para a segunda string;
    Retorne.
  Se a string for "pela",
    Acrescente "por a" para a segunda string;
    Retorne.
  Se a string for "pelos",
    Acrescente "por os" para a segunda string;
    Retorne.
  Se a string for "pelas",
    Acrescente "por as" para a segunda string;
    Retorne.
  Acrescente a string para a segunda string.


\-------------------------------------- ROTINAS EXTRAS -------------------------------------

Função para que se determine se uma string deveria ser expandida usando uma segunda string (análise de termos compostos):
  Se a string não for "partir", diga não.
  Se a string não for "partindo", diga não.
  \Se a string for alguma locução prepositiva, diga sim.
  Se a segunda string não for "de", diga não.
  Diga sim.

Função para que se determine se uma string está precisando ser decomposta:
  Lance um percorredor sobre a string.
  Se a string for algum operador de concatenação contraído usando o percorredor, diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de concatenação contraído usando um percorredor:
  Se o segmento inicial deste percorredor de contrações for algum operador de concatenação,
    Mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor de contrações for "seguida", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor de contrações for "junto", mova o percorredor (usando diretrizes de compilação).
 \ Se o segmento inicial deste percorredor de contrações for "acompanhado", mova o percorredor (usando diretrizes de compilação).
  \Se o segmento inicial deste percorredor for uma variável, recue o percorredor.
  Se o segmento inicial deste percorredor de contrações for alguma contração de preposição com artigo definido, diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de concatenação:
  Se a string for "junto", diga sim. \ junto de ".., junto com o ...
  Se a string for "juntamente", diga sim. \ juntamente com o...
  Se a string for "seguido", diga sim. \ seguido de "....
  Se a string for "seguida", diga sim. \ seguido de "....
  Se a string for "acompanhado", diga sim. \ acompanhado de "...
  \Se a string for "em", diga sim.
  \Se a string for "&", diga sim.
  Diga não.

Função para que se determine se uma string é alguma contração de preposição com artigo definido:
  Se a string for "do", diga sim.
  Se a string for "da", diga sim.
  Se a string for "dos", diga sim.
  Se a string for "das", diga sim.
  Diga não.

\------------------------------------------------------------------------------------------------------------------------------------



 Rotina para que se compile um endereço da pasta (análise dos arquivos fornecidos): \#003
  Se existir algum problema de compilação, retorne.
  Escreva "Analisando código fonte dos arquivos..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de análise/verificação.
  Examine os arquivos fontes.
  Suspenda o temporizador de análise/verificação.

Rotina para que se examine uns arquivos fontes:
  \Itere.
  Se existir algum problema de compilação, retorne.
    Obtenha um arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente, retorne.
    Examine o arquivo fonte.
  Reitere.

\Um arquivo fonte é uma lista com um endereço completo e um trecho.

Rotina para que se examine um arquivo fonte:
  Se o arquivo fonte for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o trecho deste arquivo fonte. \ STRING INICIAL
  Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o início de algum tipo,
      Examine um tipo usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma variável global,
      Examine uma variável global usando o percorredor;
      Reitere.
    Se o segmento inicial deste percorredor for o início de alguma rotina,
      Examine uma rotina usando o percorredor;
      Reitere.
    [Se o segmento inicial deste percorredor for outra coisa]
    Apresente uma mensagem de erro contendo 
      "Código de Erro #004. O compilador não reconhece a sintaxe '" 
      junto com o segmento inicial deste percorredor seguido de "'." 
      junto com o texto CRLF e o percorredor.
  Reitere.

Rotina para que se mova um percorredor (usando diretrizes de compilação): \ talvez aqui conserte o comando "subtraia"
  [Itere.]
    Se o sinalizador de erros deste compilador estiver ativo,
       Limpe o segmento inicial deste percorredor;
       Retorne.
    Mova o percorredor retornando uma string de erro (englobando tudo).
    Se a string de erro não estiver em branco,
       Apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; \#191
       Retorne.
    \Se o segmento inicial deste percorredor for "del", recue o percorredor; Retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante,
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida,
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
      Reitere.
  \Reitere.

Rotina para que se mova um percorredor retornando uma string de erro (englobando tudo):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
    Mova o percorredor retornando a string de erro (validação de comentários de bloco);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas,
    Mova o percorredor retornando a string de erro (validação de strings literais);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de qualificadores);
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (validação de comentários de bloco):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Código de Erro #005. Observações devem terminar com um colchete direito ']'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o colchete direito,
    Atribua "Código de Erro #006. Observações precisam iniciar com um colchete esquerdo '['." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (validação de strings literais):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Código de Erro #007. Strings literais precisam terminar com aspas duplas: ""." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for as aspas duplas,
    Atribua "Código de Erro #008. Strings literais devem começar com aspas duplas: ""." para a string de erro;
    Retorne.

Rotina para que se mova um percorredor retornando uma string de erro (diretrizes de validação de qualificadores):
  Se a quantidade de caracteres deste segmento inicial deste percorredor for menor do que 2,
    Atribua "Código de Erro #009. Qualificadores devem terminar com um parêntese direito ')'." para a string de erro;
    Retorne.
  Se o conteúdo deste caractere final deste segmento inicial deste percorredor não for o parênteses direito,
    Atribua "Código de Erro #010. Qualificadores precisam iniciar com um parêntese direito '('." para a string de erro;
    Retorne.

Rotina para que se apresente uma mensagem de erro contendo uma string e um endereço de byte:
  Se existir algum problema de compilação,
    Retorne.
  Ative o sinalizador de erros deste compilador.
  Atribua a string à mensagem de erro deste compilador.
  Encontre o endereço do arquivo atual deste compilador e o número da linha de erro deste compilador usando o endereço de byte .
  Se o endereço do arquivo atual deste compilador estiver em branco,
    Retorne.
  Extraia um nome do arquivo desde o endereço do arquivo atual deste compilador.
  Anteponha "ALERTA: Não foi possível compilar o arquivo '" junto com o nome do arquivo seguido de "'. " junto com o texto CRLF para a mensagem de erro deste compilador.

Rotina para que se encontre um endereço completo e um número da linha usando um endereço de byte:
  Limpe o endereço completo.
  Atribua 0 ao número da linha.
  Encontre um arquivo fonte usando o endereço de byte .
  Se o arquivo fonte for inexistente, retorne.
  Atribua o endereço completo deste arquivo fonte ao endereço completo.
  Encontre o número da linha usando o arquivo fonte e o endereço de byte.

Rotina para que se encontre um número da linha usando um arquivo fonte e um endereço de byte :
  Se o endereço de byte for inexistente,
    Atribua 0 ao número da linha;
    Retorne.
  Lance um subtexto sobre o trecho deste arquivo fonte.
  Atribua 1 ao número da linha.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Se o caractere inicial deste subtexto for o endereço de byte , retorne.
    Se o conteúdo deste caractere inicial deste subtexto for o retorno de carro,
      Adicione 1 para o número da linha.
  Adicione 1 para o caractere inicial deste subtexto.
  Reitere.

Rotina para que se encontre um arquivo fonte usando um endereço de byte :
  Se o endereço de byte for inexistente,
    Esvazie o arquivo fonte;
    Retorne.
  Itere.
    Obtenha o arquivo fonte desde os arquivos fontes.
    Se o arquivo fonte for inexistente,
      Retorne.
    Se o endereço de byte for menor do que o caractere inicial deste trecho deste arquivo fonte,
      Reitere.
    Se o endereço de byte for maior do que o caractere final deste trecho deste arquivo fonte,
      Reitere.

Função para que se determine se uma string é o início de algum tipo:
  Se a string for algum artigo indefinido, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo indefinido:
  \PAL
  Se a string for "um", diga sim.
  Se a string for "uma", diga sim.
  Se a string for "uns", diga sim.
  Se a string for "umas", diga sim.
  \Se a string for "outro", diga sim.
  \Se a string for "outra", diga sim.
  \Se a string for "algum", diga sim.
  \Se a string for "alguma", diga sim.
  \Se a string for "alguns", diga sim.
  \Se a string for "algumas", diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim. \ para funcionamento dos possessivos - local correto
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo abrangente:
  Se a string for "esse", diga sim.
  Se a string for "essa", diga sim.
  Se a string for "aquele", diga sim.
  Se a string for "aquela", diga sim.
  Se a string for "esses", diga sim.
  Se a string for "essas", diga sim.
  Se a string for "aqueles", diga sim.
  Se a string for "aquelas", diga sim.
  Se a string for "certo", diga sim.
  Se a string for "certa", diga sim.
  Se a string for "certos", diga sim.
  Se a string for "certas", diga sim.
  Se a string for "determinado", diga sim.
  Se a string for "determinada", diga sim.
  Se a string for "determinados", diga sim.
  Se a string for "determinadas", diga sim.
  Diga não.

\ --------------------------------------------------------------------- VALIDAÇÃO DA SINTAXE DOS TIPOS ----------------------------------------------------------------

Rotina para que se examine um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum artigo indefinido,
    Ative um sinalizador denominado artigo indefinido.
  Adicione o tipo para os tipos usando o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome deste tipo usando o percorredor.
  Atribua o nome deste tipo ao nome plural deste tipo.
  Atribua 0 para uma contagem.
  Se o artigo indefinido estiver ativo,
    Pluralize o nome plural deste tipo;
    Adicione 1 à contagem.
  Se a contagem for igual ou maior do que 2,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #011. não foi possível detectar o idioma desta variável" junto com o texto CRLF e o endereço local deste tipo;
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine o tipo usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente a mensagem de erro contendo 
      "Código de Erro #012. O compilador esperava encontrar um operador de atribuição ('é' ou 'são'), porém encontrou o seguinte termo: '" 
       junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o tipo usando o percorredor (unidade de medida);
    Retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo 
      "Código de Erro #013. Esperado 'um/uma'. Encontrado '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #014. Insira um '.' após a declaração do tipo."
      junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se adicione um tipo para uns tipos usando um endereço local:
  Crie o tipo.
  Acrescente o tipo para o tipos.
  Atribua o endereço local ao endereço local deste tipo.

Rotina para que se examine um nome usando um percorredor:
  Limpe o nome.
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver sobre algum indicador de início de variável,
    Expanda o nome com o segmento inicial deste percorredor;
    Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o percorredor estiver sobre algum indicador de fim de variável,
      Pare.
    Expanda o nome com o segmento inicial deste percorredor.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.
  Se o nome estiver em branco,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #015. A variável '" junto com o segmento inicial deste percorredor 
      seguido de "' não foi definida ainda." junto com o texto CRLF e o percorredor;
    Retorne.

Função para que se determine se um percorredor está sobre algum indicador de início de variável:
  \ compare com indicador de fim de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for algum artigo, diga não.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Diga sim.

Função para que se determine se uma string é algum sinal de pontuação:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum sinal de pontuação, diga sim.
  Diga não.

Função para que se determine se um byte é algum sinal de pontuação:
  Se o byte for o ponto final, diga sim.
  Se o byte for o vírgula, diga sim.
  Se o byte for o ponto&vírgula, diga sim.
  Se o byte for o sinal de dois pontos, diga sim.
  Se o byte for o ponto de exclamação, diga sim.
  Se o byte for o ponto de interrogação, diga sim.
  Diga não.

Função para que se determine se uma string é algum símbolo:
  Se a quantidade de caracteres desta string não for 1, diga não.
  Se o conteúdo deste caractere inicial desta string for algum símbolo, diga sim.
  Diga não.

Função para que se determine se um byte é algum símbolo: 
  \ esta rotina deveria estar na biblioteca padrão
  Se o byte for o acento circunflexo, diga sim.
  Se o byte for o barra vertical, diga sim.
  Se o byte for o asterisco, diga sim.
  Se o byte for o sinal de adição, diga sim.
  Se o byte for o hífen, diga sim.
  Se o byte for o barra inclinada, diga sim.
  Se o byte for o símbolo menor do que, diga sim.
  Se o byte for o símbolo maior do que, diga sim.
  Se o byte for a chave esquerda, diga sim.
  Se o byte for a chave direita, diga sim.
  Se o byte for o sinal de igualdade, diga sim.
  \ Codepage Extended ANSI - Windows-1252 
  Se o byte for 128, diga sim.
  Se o byte for 130, diga sim.
  Se o byte estiver entre 132 e 137, diga sim.
  Se o byte for 139, diga sim.
  Se o byte estiver entre 145 e 153, diga sim.
  Se o byte for 155, diga sim.
  Se o byte estiver entre 161 e 180, diga sim.
  Se o byte estiver entre 183 e 191, diga sim.
  Se o byte for 215, diga sim.
  Se o byte for 247, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo:
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

Função para que se determine se uma string é algum artigo definido:
  Se a string for "o", diga sim.
  Se a string for "a", diga sim.
  Se a string for "os", diga sim.
  Se a string for "as", diga sim.
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo adjacente:
  Se a string for "este", diga sim.
  Se a string for "esta", diga sim.
  Se a string for "estes", diga sim.
  Se a string for "estas", diga sim.
  Diga não.

Função para que se determine se uma string é alguma conjunção:
  \# verificar o uso dos termos: "ambos", "mas" e "nenhum"
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  Se a string for "nem", diga sim.
  \INGLÊS - REMOVER
  Se a string for "neither", diga sim.
  Se a string for "nor", diga sim.
  Diga não.

Função para que se determine se uma string é algum possessivo inglês:
  Se a string for "'s", diga sim.
  Se a string for "'", diga sim.
  Diga não.

Função para que se determine se uma string é algum verbo:
  Se a string for "cabe", diga sim.
  Se a string for "couber", diga sim.
  Se a string for "começa", diga sim.  
  Se a string for "começar", diga sim.  
  Se a string for "conter", diga sim.
  Se a string for "contiver", diga sim.
  Se a string for "contém", diga sim.  
  Se a string for "deve", diga sim.
  Se a string for "devem", diga sim.
  Se a string for "deveria", diga sim.
  Se a string for "deveriam", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "estar", diga sim.
  Se a string for "estará", diga sim.
  Se a string for "estarão", diga sim.
  Se a string for "estava", diga sim.
  Se a string for "estavam", diga sim.
  Se a string for "estiver", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "está", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "excede", diga sim.
  Se a string for "excedem", diga sim.
  Se a string for "existe", diga sim.
  Se a string for "existem", diga sim.
  Se a string for "existir", diga sim.
  Se a string for "finaliza", diga sim.
  Se a string for "finalizar", diga sim.
  Se a string for "é", diga sim.  
  Se a string for "foi", diga sim.
  Se a string for "for", diga sim.
  Se a string for "foram", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "há", diga sim.
  Se a string for "houver", diga sim.  
  Se a string for "inicia", diga sim.
  Se a string for "iniciar", diga sim.
  Se a string for "necessita", diga sim.
  Se a string for "necessitar", diga sim.
  Se a string for "parece", diga sim.
  Se a string for "pode", diga sim.
  Se a string for "podem", diga sim.
  Se a string for "podemos", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "poderia", diga sim.
  Se a string for "possuem", diga sim.
  Se a string for "possui", diga sim.
  Se a string for "possuir", diga sim.
  Se a string for "puder", diga sim.
  Se a string for "puderem", diga sim.
  Se a string for "requer", diga sim.
  \Se a string for "seja", diga sim.
  Se a string for "ser", diga sim.
  Se a string for "será", diga sim.
  Se a string for "serão", diga sim.
  Se a string for "supera", diga sim.
  Se a string for "superam", diga sim.
  Se a string for "superar", diga sim.
  Se a string for "são", diga sim.
  Se a string for "tem", diga sim.
  Se a string for "ter", diga sim.
  Se a string for "termina", diga sim.
  Se a string for "terminar", diga sim.
  Se a string for "tiver", diga sim.
  Se a string for "têm", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador aritmético:
  Se a string for "mais", diga sim.
  Se a string for "menos", diga sim.
  Se a string for "vezes", diga sim.
  Se a string for "dividido", diga sim.
  \Se a string for "depois", diga sim.
  Se a string for "seguido", diga sim.
  Se a string for "juntamente", diga sim.
  Se a string for "junto", diga sim.
  Se a string for "acompanhado", diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre alguma preposição:
  Atribua o segmento inicial deste percorredor para um subtexto.
  Se o percorredor estiver sobre alguma preposição conectiva, diga sim. \ "a" no sentido de "para"
  Se o subtexto for "parde", diga sim. \ contração de para + de, usada internamente
  Se o subtexto for "partir", diga sim.
  Se o subtexto for "partindo", diga sim.
  Se o subtexto for "abaixo", diga sim.
  \Se o subtexto for "baixo", diga sim.
  Se o subtexto for "acima", diga sim.
  \Se o subtexto for "cima", diga sim.
  Se o subtexto for "ante", diga sim.
  Se o subtexto for "perante", diga sim.
  Se o subtexto for "antes", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "acerca", diga sim.
  Se o subtexto for "cerca", diga sim.
  Se o subtexto for "cuja", diga sim.
  Se o subtexto for "cujo", diga sim.
  Se o subtexto for "cujas", diga sim.
  Se o subtexto for "cujos", diga sim.
  Se o subtexto for "próximo", diga sim.
  Se o subtexto for "perto", diga sim.
  Se o subtexto for "com", diga sim.
  \Se o subtexto for "contendo", diga sim.
  Se o subtexto for "tal", diga sim.
  Se o subtexto for "como", diga sim.
  Se o subtexto for "contra", diga sim.
  Se o subtexto for "dada", diga sim.
  Se o subtexto for "dado", diga sim.
  Se o subtexto for "dando", diga sim.
  Se o subtexto for "gerando", diga sim.
  Se o subtexto for "resultando", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "desde", diga sim.
  Se o subtexto for "depois", diga sim.
  Se o subtexto for "após", diga sim.
  Se o subtexto for "durante", diga sim.
  Se o subtexto for "em", diga sim.
  Se o subtexto for "entre", diga sim.
  Se o subtexto for "dentre", diga sim.
  Se o subtexto for "até", diga sim.
  \Se o subtexto for "que", diga sim.
  \Se o subtexto for "esquerda", diga sim.
  Se o subtexto for "mediante", diga sim.
  Se o subtexto for "para", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "segundo", diga sim.
  Se o subtexto for "acordo", diga sim.
  Se o subtexto for "sem", diga sim.
  Se o subtexto for "então", diga sim.
  Se o subtexto for "sobre", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "versus", diga sim.
  Se o subtexto for "enquanto", diga sim.
  Se o subtexto for "aproximadamente", diga sim.
  Se o subtexto for "através", diga sim.
  Se o subtexto for "algum", diga sim.
  Se o subtexto for "sob", diga sim.
  Se o subtexto for "debaixo", diga sim.
  Se o subtexto for "entre", diga sim.
  \Se o subtexto for "baixo", diga sim. -> erro
  Se o subtexto for "por", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "referente", diga sim.
  Se o subtexto for "pertencente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "relativo", diga sim.
  Se o subtexto for "relativa", diga sim.
  Se o subtexto for "concernente", diga sim.
  Se o subtexto for "atinente", diga sim.
  Se o subtexto for "pertinente", diga sim.
  Se o subtexto for "retornando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se o subtexto for "usando", diga sim.
  Se o subtexto for "via", diga sim.
  Se o subtexto for "com", diga sim.
  Se o subtexto for "aproada", diga sim.
  Se o subtexto for "aproado", diga sim.
  Se o subtexto for "aproando", diga sim.
  Se o subtexto for "orientada", diga sim.
  Se o subtexto for "orientado", diga sim.
  Se o subtexto for "orientando", diga sim.
  Se o subtexto for "orientando-se", diga sim.
  Se o subtexto for "voltada", diga sim.
  Se o subtexto for "voltado", diga sim.
  Se o subtexto for "virada", diga sim.
  Se o subtexto for "virado", diga sim.
  Se o subtexto for "virando", diga sim.
  Se o subtexto for "virando-se", diga sim.
  Se o subtexto for "tão", diga sim.
  Se o subtexto for "tanto", diga sim.
  Se o subtexto for "quanto", diga sim.
  Se o subtexto for "quão", diga sim.
  Se o subtexto for "qual", diga sim.
  Se o subtexto for "after", diga sim.
  Se o subtexto for "regressivamente", diga sim.
  Se o subtexto for "dentro de", diga sim.
  Se o subtexto for "dentro", diga sim.
  Se o subtexto for "parecida", diga sim.
  Se o subtexto for "parecido", diga sim.
  Se o subtexto for "semelhante", diga sim.
  Se o subtexto for "similar", diga sim.
  Se o subtexto for "em comprimento", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "d'", diga sim.
  Se o subtexto for "só", diga sim.
  Se o subtexto for "somente", diga sim.
  Se o subtexto for "unicamente", diga sim.
  Se o subtexto for "exclusivamente", diga sim.
  Se o subtexto for "apenas", diga sim.
  Se o subtexto for "fora", diga sim.
  Se o subtexto for "menores", diga sim.
  Se o subtexto for "alta", diga sim.
  Se o subtexto for "alto", diga sim.
  Se o subtexto for "comprido", diga sim.
  Se o subtexto for "comprida", diga sim.
  Se o subtexto for "largo", diga sim.
  Se o subtexto for "larga", diga sim.
  Diga não.

Função para que se determine se uma string é algum qualificador:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o parênteses esquerdo, diga sim.
  Diga não.

Função para que se determine se uma string é algum valor literal:
  Se a string for algum ponteiro literal, diga sim.
  Se a string for algum valor numérico literal, diga sim.
  Se a string for algum string literal, diga sim.
  \Se a string for algum sinalizador literal, diga sim. ***
  Se a string for algum valor hexadecimal literal, diga sim.
  Diga não.

Função para que se determine se uma string é algum ponteiro literal:
  Se a string for "nulo", diga sim.
  Se a string for "nula", diga sim.
  Se a string for "nulos", diga sim.
  Se a string for "nulas", diga sim.
  Se a string for "inexistente", diga sim.
  Se a string for "inexistentes", diga sim.
  Se a string for "zerado", diga sim.
  \CAL
  Se a string for "nil", diga sim.
  Diga não.

Função para que se determine se uma string é algum valor numérico literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string não for algum indicador numérico, diga não.
  Se a string for algum número inteiro, diga sim.
  Se a string for alguma fração literal, diga sim.
  Se a string for algum numeral misto literal, diga sim.
  Diga não.

Função para que se determine se uma string é alguma string literal;
Função para que se determine se uma string é algum string literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for as aspas duplas, diga sim.
  Diga não.

Função para que se determine se uma string é algum valor hexadecimal literal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere inicial desta string for o cifrão, diga sim.
  Diga não.

Função para que se determine se uma string é uma palavra-chave de designação:
  Se a string for "chamado", diga sim.
  Se a string for "chamados", diga sim.
  Se a string for "chamada", diga sim.
  Se a string for "chamadas", diga sim.
  Se a string for "denominado", diga sim.
  Se a string for "denominados", diga sim.
  Se a string for "denominada", diga sim.
  Se a string for "denominadas", diga sim.
  Diga não.

Função para que se determine se uma string é algum operador de atribuição composto:
  Se a string for "igual", diga sim.
  Diga não.

Rotina para que se expanda uma string com uma segunda string:
  Se a segunda string estiver em branco, retorne.
  Se a string não estiver em branco,
    Acrescente o caractere de espaço para a string.
  Acrescente a segunda string para a string.

Função para que se determine se um percorredor está sobre algum indicador de fim de variável:
  \ compare com indicador de início de variável
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga sim.
  Se o segmento inicial deste percorredor for algum símbolo, diga sim.
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Se o segmento inicial deste percorredor for alguma conjunção, diga sim.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim.
  Se o percorredor estiver sobre algum possessivo reverso, diga sim. \ 
  Se o segmento inicial deste percorredor for algum verbo, diga sim.
  Se o segmento inicial deste percorredor for algum operador aritmético, diga sim.
  Se o percorredor estiver sobre alguma preposição, diga sim.
  Se o segmento inicial deste percorredor for algum qualificador, diga sim.
  Se o segmento inicial deste percorredor for algum valor literal, diga sim.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação, diga sim.
  Se o segmento inicial deste percorredor for "então", diga sim.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto, diga sim.
  Se o segmento inicial deste percorredor estiver em branco, diga sim.
  Se o segmento inicial deste percorredor for algum advérbio de negação, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre algum possessivo reverso:
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum pronome demonstrativo, diga sim.
  Diga não.

Função para que se determine se uma string é algum advérbio de negação:
  Se a string for "não", diga sim.
  Diga não.

Rotina para que se pluralize uma string:
  Lance um percorredor sobre a string.
  Atribua "" para uma string denominada string pluralizada.
  Itere.
    Mova o percorredor (palavras plurais). \ Aqui posso mudar a formação dos plurais.
    Se o segmento inicial deste percorredor estiver em branco, pare. \ Se atingirmos o final da string.
    Se a string pluralizada não estiver em branco,
      Acrescente " " para a string pluralizada.
    Acrescente o segmento inicial deste percorredor para a string pluralizada.
    Se o segmento inicial deste percorredor for "de",
      Ative um sinalizador;
      Reitere. \ PLURAL
    Se o sinalizador não estiver ativo,
      Aplique o plural adequado para a string pluralizada.
  Reitere.
  Atribua a string pluralizada à string.

Rotina para que se mova um percorredor (palavras plurais): \ talvez aqui conserte o comando "subtraia"
  [Itere.]
    Se o sinalizador de erros deste compilador estiver ativo,
       Limpe o segmento inicial deste percorredor;
       Retorne.
    Mova o percorredor retornando uma string de erro (plurais).
    \Se a string de erro estiver definida e contiver conteúdo,
    Se a string de erro não estiver em branco,
       Apresente uma mensagem de erro contendo a string de erro e o caractere inicial deste segmento inicial deste percorredor; \#191
       Retorne.
    \Se o segmento inicial deste percorredor for "del", recue o percorredor; Retorne.
    Se o segmento inicial deste percorredor estiver em branco,
      Retorne.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for irrelevante,
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for a barra invertida,
      Reitere.
    Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
      Reitere.
  \Reitere.

Rotina para que se mova um percorredor retornando uma string de erro (plurais):
  Limpe a string de erro.
  Mova o percorredor (englobando tudo).
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o colchete esquerdo,
    Mova o percorredor retornando a string de erro (validação de comentários de bloco);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for as aspas duplas,
    Mova o percorredor retornando a string de erro (validação de strings literais);
    Retorne.
  Se o conteúdo deste caractere inicial deste segmento inicial deste percorredor for o parênteses esquerdo,
    Mova o percorredor retornando a string de erro (diretrizes de validação de qualificadores);
    Retorne.

Rotina para que se aplique o plural adequado para uma string:
  \# https://www.normaculta.com.br/singular-e-plural/
  \# palavras que são exceções às regras
  Se a string for "caráter",
    Atribua "carateres" à string;
    Retorne.
  Se a string for "júnior",
    Atribua "juniores" à string;
    Retorne.
  Se a string for "sênior",
    Atribua "seniores" à string;
    Retorne.
  \# advérbios principais
  Se a string for "muito", retorne.
  Se a string for "pouco", retorne.
  Se a string for "mais", retorne.
  Se a string for "menos", retorne.
  Se a string for "bastante", retorne.
  Se a string for "quase", retorne.
  Se a string for "demais", retorne.
  Se a string for "bem", retorne.
  Se a string for "deveras", retorne.
  Se a string for "mal", retorne.
  Se a string for "melhor", retorne.
  Se a string for "pior", retorne.
  \# palavras terminadas com "ão"
  Se a string termina com "ão",
    Pluralize a string (terminada com "ão");
    Retorne.
  \# palavras terminadas com "d"
  Se a string termina com "d",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavras terminadas com "l"
  Se a string termina com "l",
    Pluralize a string (terminada com "l");
    Retorne.
  \# palavra terminadas com "m"
  Se a string termina com "m",
    Remova o último caractere desde a string;
    Acrescente "ns" para a string;
    Retorne.
  \# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
  Se a string termina com "n",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminadas com "r"
  Se a string termina com "r",
    Pluralize a string (terminada com "r");
    Retorne.
  \# palavras terminadas com "s"
  Se a string termina com "s",
    Pluralize a string (terminada com "s");
    Retorne.
  \# palavras terminadas com "t"
  Se a string termina com "t",
    Pluralize a string (terminada com outras letras);
    Retorne.
  \# palavra terminadas com "x"
  Se a string termina com "x",
    Pluralize a string (terminada com "x");
    Retorne.
  \# palavras terminadas com "z"
  Se a string termina com "z",
    Pluralize a string (terminada com "z");
    Retorne.
  Se a string termina com "#",
    Acrescente "s" para a string;
    Retorne.
  Se a string não termina com alguma vogal ou com alguma consoante,
    Acrescente "s" para a string;
    Retorne.
  \# regra padrão
  [Caso contrário,]
  Acrescente "s" para a string. \ Só acrescenta o "s" caso nenhuma das condições acima tenha siddo correspondida.
  \Volte.

Rotina para que se pluralize uma string (terminada com "ão"):
  \A formação do plural dos substantivos terminados -ão pode ser feita de três formas distintas: -ões, -ãos, -ães.
  \Alguns substantivos terminados em -ão admitem duas (ou até três) formas no plural:
  \refrão - refrãos ou refrães;
  \corrimão - corrimões ou corrimãos;
  \guardião - guardiões ou guardiães;
  \vilão - vilões, vilãos ou vilães.
    \TODOS os substantivos paroxítonos terminados em -ão formam o plural com -ãos.
  \ALGUNS substantivos oxítonos também têm o seu plural formado segundo essa regra:
  \órfão - órfãos;
  \sótão - sótãos;
  \órgão - órgãos;
  \cidadão - cidadãos;
  \irmão - irmãos;
  \cristão - cristãos.
  Se a string for "cidadão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "irmão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "cristão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "refrão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "mão",
    Acrescente "s" para a string;
    Retorne.
  Se a string for "são",
    Acrescente "s" para a string;
    Retorne.
  \-ão no singular para -ães no plural:
  \Alguns substantivos terminados em -ão formam o plural com -ães.
  Se a string for "pão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "capitão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "alemão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Se a string for "charlatão",
    Remova o último caractere desde a string;
    Acrescente "es" para a string;
    Retorne.
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.   \ remova o "ão". Acho que não precisa
  \caso encontre acentos em sílabas prévias, faça o seguinte
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "s" para a string;
    Retorne. \-> exemplo: órgão
  \# regra padrão
  \A maioria dos substantivos terminados em -ão forma o plural com -ões:
  \opinião - opiniões;
  \coração - corações;
  \eleição - eleições.
  Remova os dois últimos caracteres desde a string.
  Acrescente "ões" para a string.\ Retorne.

Função para que se determine se uma string possui alguma vogal acentuada:
  Preserve a string.
  Itere.
    Se a string estiver em branco, diga não.
    Se o conteúdo deste caractere final desta string for alguma vogal acentuada, diga sim.
    Subtraia 1 desde o caractere final desta string.
  Reitere.

Rotina para que se pluralize uma string (terminada com outras letras):
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "l"):
  \# palavras terminadas com "al"
  Se a string termina com "al",
    Pluralize a string (terminada com "al");
    Retorne. \ MAL -> MALES
  \# palavras terminadas com "el"
  Se a string termina com "el",
    Pluralize a string (terminada com "el");
    Retorne. \PASTEL - PASTÉIS
  \# palavras terminadas com "il"
  Se a string termina com "il",
    Pluralize a string (terminada com "il");
    Retorne. \-> FUZIL -> FUZIS
  \# palavras terminadas com "ol"
  Se a string termina com "ol",
    Pluralize a string (terminada com "ol");
    Retorne. \- LENÇOL -> LENÇÓIS
  \# palavras terminadas com "ul"
  Se a string termina com "ul",
    Pluralize a string (terminada com "ul");
    Retorne. \ AZUL -> AZUIS \ Cônsul - cônsules
  [Caso a string seja uma sigla, tipo URL]
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "al"):
  Se a string for "mal",
    Atribua "males" para a string;
    Retorne.
  Remova o último caractere desde a string. \remova a letra L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "el"):
  \Se a string for "pixel", atribua "pixels" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto. \ remova o el
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "éis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "il"):
  \Se a string for "canil", atribua "canis" para a string; Retorne.
  \Se a string for "covil", atribua "covis" para a string; Retorne.
  \Se a string for "funil", atribua "funis" para a string; Retorne.
  \Se a string for "barril", atribua "barris" para a string; Retorne.
  \Se a string for "fuzil", atribua "fuzis" para a string; Retorne.
  \Se a string for "redil", atribua "redis" para a string; Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova os dois últimos caracteres desde a string;
    Acrescente "eis" para a string;
    Retorne.
  Remova o último caractere desde a string. \ remova a letra L
  Acrescente "s" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ol"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Remova o último caractere desde a string;
    Acrescente "is" para a string;
    Retorne.
  Remova os dois últimos caracteres desde a string.
  Acrescente "óis" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "ul"):
  Se a string for "cônsul",
    Atribua "cônsules" à string;
    Retorne.
  Remova o último caractere desde a string. \ remova o L
  Acrescente "is" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "r"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "air",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íres" para a string;
    Retorne.
  Se a string termina com "aur",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úres" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "s"):
\Quando os substantivos terminados em -s são paroxítonos, a formação do plural fica invariável:.
  \# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
  Se a string termina com "as",
    Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "es",
      Acrescente "es" para a string;
    Retorne. \atlas
  Se a string termina com "os",
      Acrescente "es" para a string;
    Retorne. \atlas
  \# hiatos acentuados
  Se a string termina com "aís",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aús",
    Acrescente "es" para a string;
    Retorne.
  \# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
  Se a string termina com "ás",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "âs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ases" para a string;
    Retorne.
  Se a string termina com "és",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ês",
    Remova os dois últimos caracteres desde a string;
    Acrescente "eses" para a string;
    Retorne.
  Se a string termina com "ís",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ises" para a string;
    Retorne.
  Se a string termina com "ós",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ôs",
    Remova os dois últimos caracteres desde a string;
    Acrescente "oses" para a string;
    Retorne.
  Se a string termina com "ús",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uses" para a string;
    Retorne.
  \# palavras terminadas com "is", "us"
  Se a string termina com "is",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne.
  Se a string termina com "us",
    Pluralize a string (terminada com "is" ou com "us");
    Retorne. \ônibus / vírus
  \Se a string termina com "ts", exit.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string (terminada com "is" ou com "us"):
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada, retorne.
  \# hiatos
  Se a string termina com "ais",
    Remova os dois últimos caracteres desde a string;
    Acrescente "íses" para a string;
    Retorne. \cais não varia....
  Se a string termina com "aus",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úses" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Rotina para que se pluralize uma string  (terminada com "x"):
  \Se a string for "px",
    \acrescente "pxs" para a string;
    \Retorne.
  Se a string for "fax",
    Acrescente "es" para a string;
    Retorne.
  Acrescente "s" para a string. \ tratamento de exceções
   \ Retorne.

Rotina para que se pluralize uma string (terminada com "z"):
  \# hiatos acentuados
  Se a string termina com "aíz",
    Acrescente "es" para a string;
    Retorne.
  Se a string termina com "aúz",
    Acrescente "es" para a string;
    Retorne.
  \# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
  Se a string termina com "áz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "âz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "azes" para a string;
    Retorne.
  Se a string termina com "éz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "êz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ezes" para a string;
    Retorne.
  Se a string termina com "íz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "izes" para a string;
    Retorne.
  Se a string termina com "óz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "ôz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ozes" para a string;
    Retorne.
  Se a string termina com "úz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "uzes" para a string;
    Retorne.
  \# acentos em sílabas prévias
  Lance um subtexto sobre a string.
  Subtraia 2 desde o caractere final deste subtexto.
  Se o subtexto possui alguma vogal acentuada,
    Acrescente "es" para a string;
    Retorne.
  \# hiatos
  Se a string termina com "aiz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "ízes" para a string;
    Retorne.
  Se a string termina com "auz",
    Remova os dois últimos caracteres desde a string;
    Acrescente "úzes" para a string;
    Retorne.
  \# regra padrão
  Acrescente "es" para a string. \ Retorne.

Função para que se determine se uma string termina com alguma vogal ou com alguma consoante:
  Se a string terminar com algum vogal, diga sim.
  Se a string terminar com alguma consoante, diga sim.
  Diga não.

Função para que se determine se uma string termina com algum vogal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for algum vogal, diga não.
  Diga sim.

Função para que se determine se uma string termina com alguma consoante:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string não for alguma consoante, diga não.
  Diga sim.

Rotina para que se apresente uma mensagem de erro contendo uma string e um percorredor:
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo a string e o caractere inicial deste segmento inicial deste percorredor;
    Retorne.
  Apresente a mensagem de erro contendo a string e o caractere final deste segmento final deste percorredor.

Função para que se determine se uma string é algum operador de atribuição de estruturas compostas:
  Se a string for "tem", diga sim.
  Se a string for "têm", diga sim.
  Se a string for "contém", diga sim.
  Se a string for "contêm", diga sim.
  \Se a string for "possui", diga sim.
  Diga não.

Rotina para que se examine um tipo usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "estrutura" ao nome do tipo primitivo deste tipo.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #016. Esperado '.' no final da estrutura. Encontrado '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

Rotina para que se examine uns campos usando um percorredor:
  \Itere.
  Se existir algum problema de compilação, retorne.
    Adicione um campo para o campos usando "campo" e o caractere inicial deste segmento inicial deste percorredor.
    \ Um campo é uma variável.
    Examine o campo usando o percorredor.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Examine algumas pausas usando o percorredor.
  Reitere.

Rotina para que se adicione uma variável para umas variáveis usando uma categoria e um endereço local:
  Crie a variável usando a categoria.
  Acrescente a variável para as variáveis.
  Atribua o endereço local ao endereço local desta variável.

Rotina para que se crie uma variável usando um categoria:
  Aloque memória para a variável.
  Atribua a categoria à categoria desta variável.
  Atribua 1 à contagem desta variável.

Rotina para que se examine um campo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Examine o campo usando o percorredor (tipo geral).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for uma palavra-chave de designação,
      Examine o campo usando o percorredor (cláusula designadora);
      Reitere.
    Se o segmento inicial deste percorredor for "sob",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for "em",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for "sobre",
      Examine o campo usando o percorredor (cláusula de redefinição);
      Reitere.
    Se o segmento inicial deste percorredor for uma palavra-chave de referenciamento,
      Examine o campo usando o percorredor (cláusula de referência);
      Reitere.
  \Pare.

Rotina para que se examine um campo usando um percorredor (tipo geral):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Examine o campo usando o percorredor (tipo: array de bytes);
    Retorne.
  Examine o campo usando o percorredor (tipo normal).

Rotina para que se examine um campo usando um percorredor (tipo: array de bytes):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Reduza a proporção.
  Se o denominador desta proporção não for 1,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #017. Erro de sintaxe. Bytes contíguos devem ser declarados apenas com números inteiros." junto com o texto CRLF e o percorredor;
    Retorne.
  Atribua o numerador desta proporção à contagem deste campo.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "byte" ou "bytes",
    Apresente a mensagem de erro contendo 
      "Código de Erro #018. Erro de sintaxe. Esperado encotrar o identificador 'bytes' após a declaração de número. Identificador encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "byte" ao nome do tipo deste campo.

Rotina para que se examine um campo usando um percorredor (tipo normal):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #019. Erro de sintaxe. Esperado encontrar um artigo indefinido. Identificador encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste campo com o nome.

Rotina para que se examine um campo usando um percorredor (cláusula designadora):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o nome do tipo deste campo estiver em branco,
    Atribua o nome deste campo ao nome do tipo deste campo. \ O nome do tipo "array de bytes" já foi preenchido
  Examine o nome deste campo usando o percorredor.

Rotina para que se examine um campo usando um percorredor (cláusula de redefinição):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #020. Sintaxe incorreta. Esperado 'o/a'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o novo nome deste campo usando o percorredor.

Função para que se determine se uma string é uma palavra-chave de referenciamento:
  Se a string for "(referência)", diga sim.
  Diga não.

Rotina para que se examine um campo usando um percorredor (cláusula de referência):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de referência deste campo.

Função para que se determine se uma string é alguma pausa:
  Se a string for "e", diga sim.
  Se a string for "ou", diga sim.
  \default
  Se a string for ",", diga sim.
  Se a string for ";", diga sim.
  Diga não.

Rotina para que se examine algumas pausas usando um percorredor:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for alguma pausa, retorne.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se catalogue um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Catalogue o tipo usando o nome deste tipo.

Rotina para que se catalogue um tipo usando um nome:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Encontre um tipo denominado tipo procurado usando o nome e o catálogo de tipos.
  Se o tipo procurado for inexistente,
    Catalogue o tipo usando o nome e o catálogo de tipos;
    Retorne.
  [Se o tipo procurado estiver presente no catálogo de tipos, então:]
  Atribua o endereço local deste tipo para um endereço local.
  Se o endereço local for inexistente,
    Atribua o endereço local deste tipo procurado ao endereço local. \ aponta para um erro do tipo no código-fonte, não para um tipo gerado
  Se o endereço local não for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #021. O identificador '" junto com o nome seguido de 
      "' corresponde a um tipo já declarado anteriormente." junto com o texto CRLF e o endereço local.

Função para que se determine se uma string é algum operador de atribuição simples:
  Se a string for "é", diga sim.
  Se a string for "está", diga sim.
  Se a string for "são", diga sim.
  Se a string for "estão", diga sim.
  Se a string for "estamos", diga sim.
  Se a string for "for", diga sim.
  Se a string for "forem", diga sim.
  Se a string for "estiverem", diga sim.
  Se a string for "estarem", diga sim.
  Se a string for "possui", diga sim.
  \Se a string for "tem", diga sim. \records
  Diga não.

Rotina para que se examine um tipo usando um percorredor (unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para a razão de escala deste tipo.
  Se a razão de escala deste tipo for 0,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #022. Impossível utilizar 0 como razão de escala em tipos escalares." 
      junto com o texto CRLF e o endereço local deste tipo;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo primitivo deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #023. Esperado encontrar um '.' após a declaração de unidade de medida. Encontrado. '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue o tipo.

\Rotina para que se examine algum dado complementar de um tipo usando um percorredor:
Rotina para que se examine algum dado complementar para um tipo usando um percorredor:
  Se existir algum problema de compilação, retorne.
  \Se o segmento inicial deste percorredor for "to",
    \Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    \Retorne.
  Se o segmento inicial deste percorredor for "para",
    Examine algum dado complementar para o tipo usando o percorredor (ponteiros);
    Retorne.
  Se o segmento inicial deste percorredor for alguma palavra-chave de complementação,
    Examine algum dado complementar para o tipo usando o percorredor (estrutura);
    Retorne.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (ponteiros):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #024. Esperava encontrar 'Aponte para UM/UMA'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do conteúdo deste tipo usando o percorredor.

Função para que se determine se uma string é alguma palavra-chave de complementação:
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Diga não.

Rotina para que se examine algum dado complementar para um tipo usando um percorredor (estrutura):
  Mova o percorredor (usando diretrizes de compilação).
  Examine o campos deste tipo usando o percorredor.

\ ---------------------------------------------- VALIDAÇÃO DA SINTAXE DE VARIÁVEIS GLOBAIS ---------------------------------------------------------------

\ CONFERIR ARQUIVO "ETAPA INICIAL"

Função para que se determine se uma string é o início de alguma variável global:
  Se a string for algum artigo definido, diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione a variável global para as variáveis globais usando "variável global" [categoria] e o caractere inicial deste segmento inicial deste percorredor. [endereço local]
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for algum operador de atribuição de estruturas compostas,
    Examine a variável global usando o percorredor (cláusula 'tem');
    Retorne.
  Se o segmento inicial deste percorredor não for algum operador de atribuição simples,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #025. Erro de sintaxe. Esperado: 'é/está'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Examine a variável global usando o percorredor (literal termo);
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome do tipo desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor for o início de algum dado complementar,
    Examine a variável global usando o percorredor (dados complementares);
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de atribuição composto,
    Examine a variável global usando o percorredor (análise de valor);
    Retorne.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #026. Erro de sintaxe. Declaração de variáveis globais devem terminar com um '.'" junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine uma variável global usando um percorredor (cláusula 'tem'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  [embutido/incorporado/vinculado]
  Atribua "~inline "  junto com o nome desta variável global seguido de " tipo" para um nome.
  \Atribua "TIPO "  junto com o nome desta variável global seguido de " ~inline" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ 
  Adicione um tipo para os tipos usando o nome e o nome plural e "estrutura" e o endereço local desta variável global. \ ESTRUTURA
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine os campos deste tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #027. Esperado '.' no final de declarações de variáveis globais. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se catalogue uma variável global:
  Se existir algum problema de compilação, retorne.
  Se a variável global for inexistente, retorne.
  Se o nome desta variável global estiver no catálogo de variáveis globais,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #028. O identificador '" junto com o nome desta variável global 
      seguido de "' corresponde a uma variável global já declarada anteriormente." 
      junto com o texto CRLF e o endereço local desta variável global;
    Retorne.
  Catalogue a variável global usando o nome desta variável global e o catálogo de variáveis globais.

Rotina para que se examine uma variável global usando um percorredor (literal termo):
  Se existir algum problema de compilação, retorne.
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #029. Erro de sintaxe. Necessário inserir '.' ao inicializar variáveis globais." 
      junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine um corpo de variável global usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste corpo de variável global.
  Atribua -1 ao caractere final deste corpo de variável global.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste corpo de variável global.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Função para que se determine se uma string é o início de algum dado complementar:
  \PAL
  Se a string for "com", diga sim.
  Se a string for "contendo", diga sim.
  Diga não.

Rotina para que se examine uma variável global usando um percorredor (dados complementares):
  Se existir algum problema de compilação, retorne.
  Atribua "~inline " junto com o nome desta variável global seguido de " tipo" para um nome.
  Atribua o nome seguido de "s" para um nome plural. \ 
  Adicione um tipo para os tipos usando o nome e o nome plural e o nome do tipo desta variável global e o endereço local desta variável global.
  Catalogue o tipo.
  Atribua o nome deste tipo ao nome do tipo desta variável global.
  Examine algum dado complementar para o tipo usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #030. Erro de sintaxe. Esperado '.' após informações complementares." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Rotina para que se examine uma variável global usando um percorredor (análise de valor):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum termo de equivalência,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #031. Esperava encontrar 'igual a'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o corpo de variável global desta variável global usando o percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #032. Erro de sintaxe. Esperado '.' ao final de uma declaração variável variável global" junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Catalogue a variável global.

Função para que se determine se uma string é algum termo de equivalência: \ igual a 
  Se a string for "a", diga sim.
  Se a string for "para", diga sim.
  \Se a string for "que", diga sim.
  Diga não.

Rotina para que se duplique uma variável global retornando uma segunda variável global:
  Se a variável global for inexistente, retorne.
  Se a segunda variável global for inexistente,
    Aloque memória para a segunda variável global.
  Atribua a categoria desta variável global para a categoria desta segunda variável global.
  Atribua o nome desta variável global para o nome desta segunda variável global.
  Atribua o nome do tipo desta variável global para o nome do tipo desta segunda variável global.
  Atribua o corpo de variável global desta variável global para o corpo de variável global desta segunda variável global.

\ -------------------------------------------------------------------- VALIDAÇÃO DA SINTAXE DOS CABEÇALHOS DE ROTINAS -----------------------------------------------------

Função para que se determine se uma string é o início de alguma rotina:
  Se a string for "Para", diga sim.
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  \ Se a string for "Passos", diga sim.
  \ Se a string for "Etapas", diga sim.
  \ Se a string for "Instruções", diga sim.
  \ Se a string for "Diretrizes", diga sim.
  \ Se a string for "Método", diga sim.
  \ Se a string for "Roteiro", diga sim.
  \ Se a string for "Descrição", diga sim.
  \ Se a string for "Processo", diga sim.
  \ Se a string for "Ações", diga sim.
  \ Se a string for "Caminho", diga sim.
  \ Se a string for "Guia", diga sim.
  \ Se a string for "Modelo", diga sim.
  \ Se a string for "Estratégia", diga sim.
  \ Se a string for "Manual", diga sim.
  Diga não.

Rotina para que se examine uma rotina usando um percorredor:
  \ Define o cabeçalho de rotina.
  Se existir algum problema de compilação, retorne.
  Adicione a rotina para as rotinas usando o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor for açúcar sintático,
    Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for "para",
    Apresente uma mensagem de erro contendo 
      "Código de Erro #033. Erro. Esperado 'para'. Encontrado '" 
      junto com o segmento inicial deste percorredor 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  \Se o segmento inicial deste percorredor for "para",
    Mova o percorredor (usando diretrizes de compilação). \ Obtém a próxima palavra
  Se o segmento inicial deste percorredor for "que",
    Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "se",
    Mova o percorredor (usando diretrizes de compilação).
  Examine o cabeçalho de rotina desta rotina usando o percorredor.
  Se o segmento inicial deste percorredor for o ponto&vírgula,
    Examine a rotina usando o percorredor (sobrecarga de métodos);
    Retorne. \ *** usado para nomes alternativos de rotinas
  Se o segmento inicial deste percorredor não for o sinal de dois pontos,
    Apresente a mensagem de erro contendo 
      "Código de Erro #034. Erro de sintaxe no cabeçalho de rotina. ':' ausente ou mal posicionado" 
      e o endereço local desta rotina;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine as instruções desta rotina usando o percorredor.

Rotina para que se adicione uma rotina para umas rotinas usando um endereço local:
  Crie a rotina.
  Acrescente a rotina para as rotinas.
  Atribua o endereço local ao endereço local desta rotina.

Rotina para que se crie uma rotina:
  Aloque memória para a rotina.

Função para que se determine se uma string é açúcar sintático:
  \PAL
  \Se a string for "Passos", diga sim.
  \Se a string for "Etapas", diga sim.
  Se a string for "Procedimento", diga sim.
  Se a string for "Rotina", diga sim.
  Se a string for "Função", diga sim.
  Diga não.

Rotina para que se examine um cabeçalho de rotina usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial deste cabeçalho de rotina.
  Atribua -1 ao caractere final deste cabeçalho de rotina.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula, retorne.
    Se o segmento inicial deste percorredor for o sinal de dois pontos, retorne.
    Se o segmento inicial deste percorredor for o ponto final, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final deste cabeçalho de rotina.
    Mova o percorredor (usando diretrizes de compilação).
  Reitere.

Rotina para que se examine uma rotina usando um percorredor (sobrecarga de métodos):
  \ *** para cabeçalhos alternativos de rotinas
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o início de alguma rotina,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #035. Erro de sintaxe. Verifique se existe um 'para' após o ';'." e o percorredor original;
    Retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor original ao caractere inicial destas instruções desta rotina.
  Atribua o caractere final deste segmento inicial deste percorredor original ao caractere final destas instruções desta rotina.
  Mova o percorredor original (usando diretrizes de compilação).

Rotina para que se examine uma instruções usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Atribua o caractere inicial deste segmento inicial deste percorredor ao caractere inicial destas instruções.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Atribua o caractere final deste segmento inicial deste percorredor ao caractere final destas instruções.
    Se o segmento inicial deste percorredor for o sinal de dois pontos,
      Apresente uma mensagem de erro contendo 
        "Código de Erro #036. Mova o ':' para o final do cabeçalho desta rotina." junto com o texto CRLF e o percorredor;
      Retorne.
    Se o segmento inicial deste percorredor não for o ponto final,
      Mova o percorredor (usando diretrizes de compilação);
      Reitere.
    Mova o percorredor (usando diretrizes de compilação).
    Se o segmento inicial deste percorredor for o enunciado de alguma rotina ou variável, retorne.
  Reitere.

Função para que se determine se uma string é o enunciado de alguma rotina ou variável:
  Se a string for açúcar sintático, diga sim.
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Diga não.

\-------------------------------------------------------------------------------------ROTINAS EXTRAS--------------------------------------------------------------

Função para que se determine se uma string termina com alguma consoante e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for alguma consoante, diga não.
  Se a string não terminar com a segunda string, diga não.
  Diga sim.

Função para que se determine se uma string termina com algum vogal e uma segunda string:
  Lance um subtexto sobre a string.
  Subtraia a quantidade de caracteres desta segunda string desde o caractere final deste subtexto.
  Se o subtexto estiver em branco, diga não.
  Se o conteúdo deste caractere final deste subtexto não for algum vogal, diga não.
  Se a string não terminar com a segunda string, diga não.
  Diga sim.

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (identificação dos tipos das variáveis): \ #004
  Se existir algum problema de compilação, retorne.
  Escreva "Identificando os tipos das variáveis..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de resolução de tipos.
  Destrinche os tipos (expansão de listas).
  Destrinche os tipos (registro de plurais).
  Destrinche os tipos (tipos de dados primitivos).
  Destrinche os tipos (dados complementares).
  Suspenda o temporizador de resolução de tipos.

\--------------------------------------------------------------------------LISTAS DUPLAMENTE ENCADEADAS---------------------------------------------------

Rotina para que se destrinche uns tipos (expansão de listas):
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde os tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (análise de listas).
  Reitere.

Rotina para que se destrinche um tipo (análise de listas): 
 \ Necessário quando tipo base do tipo ainda não foi determinado
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Se o nome deste tipo for "lista", retorne.
  Se o tipo não puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne.
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  \ O código abaixo adiciona a lista estruturada 
  \ Obs: o número de campos pré-definidos da lista estruturada é igual a 4.
  \ Este valor está definido em 2 lugares. Pesquise por "do que 4" (anteriormente eram 6 campos)
  Atribua o nome deste tipo seguido de " estruturada" para um nome.
  Atribua o nome deste tipo seguido de " estruturadas" para um nome plural.
  Atribua o nome deste tipo base seguido de " estruturada" para um nome do tipo primitivo.
  Adicione um tipo estruturado para os tipos usando 
    O nome e 
    O nome plural e 
    O nome do tipo primitivo.
  Adicione um campo para os campos deste tipo estruturado usando 
    "próximo " junto com o nome deste tipo e 
    "próximo" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Adicione um campo português para os campos deste tipo estruturado usando 
    "próxima " junto com o nome deste tipo e 
    "próxima" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "próximo " junto com o nome deste tipo ao novo nome deste campo português.
  Adicione um segundo campo para os campos deste tipo estruturado usando 
    "precedente " junto com 
    O nome deste tipo e 
    "precedente" e 
    O nome deste tipo 
    e o sinalizador de ignição.
  Adicione um segundo campo português para os campos deste tipo estruturado usando 
    O nome deste tipo seguido de 
    " anterior" e 
    "anterior" e \ vem antes do nome do tipo
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "precedente " junto com o nome deste tipo ao novo nome deste segundo campo português.
  Se os campos deste tipo não estiverem vazios,
    Acrescente os campos deste tipo para os campos deste tipo estruturado.
  Catalogue o tipo estruturado.
  \ Corrige o tipo original para assemelhar-se a um ponteiro
  Atribua o nome deste tipo estruturado ao nome do conteúdo deste tipo.
  \ LISTAS
  Adicione um tipo encadeado para os tipos usando 
    O nome plural deste tipo e "" e 
    O nome plural deste tipo base.
  Adicione um terceiro campo para os campos deste tipo encadeado usando 
    "primeiro " junto com o nome deste tipo e 
    "primeiro" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Adicione um terceiro campo português para os campos deste tipo encadeado usando 
    "primeira " junto com o nome deste tipo e 
    "primeira" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "primeiro " junto com o nome deste tipo ao novo nome deste terceiro campo português.
  \Adicione um terceiro campo português feminino para os campos deste tipo encadeado usando 
    \"primeira " junto com o nome deste tipo e "primeira" e o nome deste tipo e o sinalizador de ignição.
  \Atribua "primeiro " junto com o nome deste tipo ao novo nome deste terceiro campo português feminino.
  Adicione um quarto campo para os campos deste tipo encadeado usando 
    "último " junto com o nome deste tipo e 
    "último" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Adicione um quarto campo português para os campos deste tipo encadeado usando 
    "última " junto com o nome deste tipo e 
    "última" e 
    O nome deste tipo e 
    O sinalizador de ignição.
  Atribua "último " junto com o nome deste tipo ao novo nome deste quarto campo português.
  \Adicione um quarto campo português feminino para os campos deste tipo encadeado usando 
    \"última " junto com o nome deste tipo e "última" e o nome deste tipo e o sinalizador de ignição.
  \Atribua "último " junto com o nome deste tipo ao novo nome deste quarto campo português feminino.
  Catalogue o tipo encadeado.

Função para que se determine se um tipo pode ser reduzido para uma string usando o nome do tipo primitivo:
  Se o tipo for inexistente, diga não.
  Se o nome deste tipo for a string, diga sim.
  Se o sinalizador de recursividade deste tipo estiver ativo, diga não.
  Ative o sinalizador de recursividade deste tipo.
  Encontre um tipo base usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base for inexistente,
    Desative o sinalizador de recursividade deste tipo;
    Diga não.
  Se o tipo base puder ser reduzido para a string usando o nome do tipo primitivo,
    Desative o sinalizador de recursividade deste tipo;
    Diga sim.
  Desative o sinalizador de recursividade deste tipo.
  Diga não.

Rotina para que se encontre um tipo e um apelido usando um nome:
  Esvazie o tipo.
  Limpe o apelido.
  Encontre o tipo e o apelido usando o nome (progressivamente).
  Se o tipo não for inexistente, retorne.
  Encontre o tipo e o apelido usando o nome (regressivamente).
  \ TRECHO DA VERSÃO ANTIGA
  \ Lance um subtexto sobre o nome.
  \ Itere.
    \ Se o subtexto estiver em branco, retorne.
    \ Encontre o tipo usando o subtexto e o catálogo de tipos.
    \ Se o tipo não for inexistente, pare.
    \ Passe para a próxima palavra  no subtexto.
  \ Reitere.
  \ Atribua o caractere inicial deste nome para caractere inicial dum segundo subtexto. \ 
  \ Atribua o caractere inicial deste subtexto menos 2 ao caractere final deste segundo subtexto.
  \ Se o segundo subtexto não estiver em branco, atribua o segundo subtexto ao apelido.
  \ Se o segundo subtexto estiver em branco, atribua o subtexto ao apelido.

Rotina para que se encontre um tipo e um apelido usando um nome (progressivamente):
  \ original - sem alterações
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para a próxima palavra  no subtexto. \próximo
  Reitere.
  Atribua o caractere inicial deste nome para o caractere inicial dum segundo subtexto.
  Atribua o caractere inicial deste subtexto MENOS 2 ao caractere final deste segundo subtexto.
  Se o segundo subtexto não estiver em branco,
    Atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco,
    Atribua o subtexto ao apelido.

Rotina para que se passe para a próxima palavra  em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere inicial deste subtexto for irrelevante, pare.
  Adicione 1 para o caractere inicial deste subtexto.
  Reitere.
  Ignore os caracteres ignoráveis no início no subtexto.

Rotina para que se passe para a palavra anterior em um subtexto:
  Se o subtexto estiver em branco, retorne.
  Se o conteúdo deste caractere final deste subtexto for irrelevante, pare.
  Subtraia 1 desde o caractere final deste subtexto.
  Reitere.
  Ignore algum caractere ignorável final no subtexto.

Rotina para que se ignore algum caractere ignorável final em um subtexto:
  Itere.
    Se o subtexto estiver em branco, retorne.
    Se o conteúdo deste caractere final deste subtexto não for irrelevante, retorne.
    Subtraia 1 desde o caractere final deste subtexto.
  Reitere.

Rotina para que se encontre um tipo e um apelido usando um nome (regressivamente):
  Esvazie o tipo.
  Limpe o apelido.
  Lance um subtexto sobre o nome.
  Itere.
    Se o subtexto estiver em branco, retorne.
    Encontre o tipo usando o subtexto e o catálogo de tipos.
    Se o tipo não for inexistente, pare.
    Passe para a palavra anterior no subtexto. \ anterior
  Reitere.
  Atribua o caractere final deste nome para o caractere final dum segundo subtexto.
  Atribua o caractere final deste subtexto MAIS 2 ao caractere inicial deste segundo subtexto.
  Se o segundo subtexto não estiver em branco,
    Atribua o segundo subtexto ao apelido.
  Se o segundo subtexto estiver em branco,
    Atribua o subtexto ao apelido.

Função para que se determine se um tipo pode ser reduzido para um nome do tipo:
  Se o tipo for inexistente, diga não.
  Preserve o tipo.
  Itere.
    Se o tipo for inexistente, diga não.
    Se o nome deste tipo for o nome do tipo, diga sim.
    Se o tipo base deste tipo for o tipo, diga não.
    Atribua o tipo base deste tipo ao tipo.
  Reitere.

Rotina para que se adicione um campo para uns campos usando um nome e um apelido e um nome do tipo e um sinalizador:
  Adicione o campo para o campos usando "campo" e nil.
  Atribua o nome ao nome deste campo.
  Atribua o apelido ao apelido deste campo.
  Atribua o nome do tipo ao nome do tipo deste campo.
  Atribua um sinalizador de referência ao sinalizador de referência deste campo.

\-------------------------------------------------------------------------------------- REGISTRO DE PLURAIS ------------------------------------------------------------

Rotina para que se destrinche uns tipos (registro de plurais):
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (registro de plurais).
  Reitere.

Rotina para que se destrinche um tipo (registro de plurais):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome plural deste tipo estiver em branco, retorne.
  Se o tipo puder ser reduzido para "lista" usando o nome do tipo primitivo, retorne.
  Catalogue o tipo usando o nome plural deste tipo.

\-------------------------------------------------------------------------- TIPOS BASE / TIPOS PRIMITIVOS ---------------------------------------------------------------------

Rotina para que se destrinche uns tipos (tipos de dados primitivos): 
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (tipos de dados primitivos).
  Reitere.

\ A rotina abaixo é recursiva
Rotina para que se destrinche um tipo (tipos de dados primitivos):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o tipo base deste tipo não for inexistente, retorne.
  Encontre o tipo base deste tipo usando o nome do tipo primitivo deste tipo e o catálogo de tipos.
  Se o tipo base deste tipo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #037. O identificador '" junto com o nome do tipo primitivo deste tipo 
      seguido de "' corresponde a um tipo base inválido." junto com o texto CRLF e o endereço local deste tipo;
    Retorne.
  Ative o sinalizador de recursividade deste tipo.
  Se o sinalizador de recursividade deste tipo base deste tipo estiver ativo,
    Apresente a mensagem de erro contendo 
      "Código de Erro #038. Definição recursiva encontrada no tipo '" junto com o nome do tipo primitivo deste tipo 
      seguido de "'." junto com o texto CRLF e o endereço local deste tipo;
    Retorne.
  Destrinche o tipo base deste tipo (tipos de dados primitivos). \ RECURSÃO
  Desative o sinalizador de recursividade deste tipo.

\-------------------------------------------------------------------------- INFORMAÇÕES COMPLEMENTARES ---------------------------------------------------------------------

Rotina para que se destrinche uns tipos (dados complementares):
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Destrinche o tipo (dados complementares).
  Reitere.

Rotina para que se destrinche um tipo (dados complementares):
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o sinalizador de informações complementares deste tipo estiver ativo, retorne.
  Se o tipo base deste tipo for o tipo, retorne. \ para os tipos pré-definidos
  Verifique por informações opcionais inválidas no tipo.
  Ative o sinalizador de recursividade deste tipo.
  Destrinche o tipo base deste tipo (dados complementares). \ RECURSÃO
  Se o tipo puder ser reduzido para "ponteiro",
    Destrinche o tipo (dados opcionais - ponteiro).
  Se o tipo puder ser reduzido para "estrutura",
    Destrinche o tipo (dados opcionais - estrutura). \ mudar aqui
  Se o tipo puder ser reduzido para "número",
    Destrinche o tipo (dados opcionais - tipos fracionários).
  Desative o sinalizador de recursividade deste tipo.
  Ative o sinalizador de informações complementares deste tipo.

Rotina para que se verifique por informações opcionais inválidas em um tipo:
  Se existir algum problema de compilação, retorne.
  Se o tipo for inexistente, retorne.
  Se o nome do conteúdo deste tipo não estiver em branco,
    Verifique por informações opcionais inválidas no tipo (conteúdo).
  Se o campos deste tipo não estiverem vazios,
    Verifique por informações opcionais inválidas no tipo (campos).
  Se a razão de escala deste tipo não for 0,
    Verifique por informações opcionais inválidas no tipo (tipos fracionários).

Rotina para que se verifique por informações opcionais inválidas em um tipo (conteúdo):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro",
    Apresente uma mensagem de erro contendo 
      "Código de Erro #039. A palavra-chave 'para' só pode ser utilizada com variáveis do tipo ponteiro." 
      junto com o texto CRLF e o endereço local deste tipo;
    Retorne.

Rotina para que se verifique por informações opcionais inválidas em um tipo (campos):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "estrutura",
    Apresente uma mensagem de erro contendo 
      "Código de Erro #040. A palavra-chave 'com' deve ser utilizada apenas em estruturas e listas." 
      junto com o texto CRLF e o endereço local deste tipo;
    Retorne.

Rotina para que se verifique por informações opcionais inválidas em um tipo (tipos fracionários):
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "número",
    Apresente uma mensagem de erro contendo 
      "Código de Erro #041. Proporções e escalas de medida só devem ser utilizadas em tipos de dados numéricos." 
      junto com o texto CRLF e o endereço local deste tipo;
    Retorne.

Rotina para que se destrinche um tipo (dados opcionais - ponteiro):
  Se existir algum problema de compilação, retorne.
  Se o tipo do conteúdo deste tipo não for inexistente, retorne.
  Se o nome do conteúdo deste tipo estiver em branco,
    Atribua o tipo do conteúdo deste tipo base deste tipo ao tipo do conteúdo deste tipo;
    Retorne.
  Encontre o tipo do conteúdo deste tipo usando o nome do conteúdo deste tipo e o catálogo de tipos. \?
  Se o tipo do conteúdo deste tipo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #042. Não foi possível determinar o tipo do conteúdo apontado por este ponteiro." 
      junto com o texto CRLF e o endereço local deste tipo;
    Retorne.

Rotina para que se destrinche um tipo (dados opcionais - estrutura):
  Se existir algum problema de compilação, retorne.
  Se os campos deste tipo estiverem vazios,
    Copie os campos deste tipo base deste tipo aos campos deste tipo;
    Retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo (regressivamente).
    Se o campo for inexistente, pare.
    Se o campo estiver duplicada nos campos deste tipo,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #043. O campo '" junto com o nome deste campo 
      seguido de "' já foi definido anteriormente na estrutura '" 
      junto com o nome deste tipo junto com "'." junto com o texto CRLF
      e o endereço local deste campo;
    Retorne.
    Destrinche o campo.
    Se existir algum problema de compilação, retorne.
    Se o sinalizador de recursividade deste tipo deste campo estiver ativo,
    Apresente a mensagem de erro contendo 
      "Código de Erro #044. Encontrada uma definição recursiva no campo '" 
      junto com o nome deste tipo deste campo seguido de "' da estrutura '" 
      junto com o nome deste tipo junto com "'." junto com o texto CRLF
      e o endereço local deste campo;
    Retorne.
    Destrinche o tipo deste campo (dados complementares).
    Se o sinalizador de referência deste campo não estiver ativo, reitere.
    Se o tipo deste campo não puder ser reduzido para "ponteiro",
      Apresente a mensagem de erro contendo 
        "Código de Erro #045. O campo '" 
        junto com o nome deste campo 
        seguido de "' não é do tipo ponteiro" e o endereço local deste campo;
      Retorne.
  Reitere.
  Elimine apelidos duplicados desde os campos deste tipo.
  Se o tipo não puder ser reduzido para "lista estruturada", retorne.
  Se a contagem destes campos deste tipo for maior do que 4, retorne.
  \ Já copiado? Eram 2 quando era próximo e anterior, agora 4 para incluir as variantes
  Copie os campos deste tipo base deste tipo aos campos deste tipo (apenas campos de dados).

Rotina para que se copie uns campos para uns segundo campos:
  \Itere.
    Obtenha um campo desde o campos.
    Se o campo for inexistente, retorne.
    Copie o campo para um segundo campo.
    Acrescente o segundo campo para o segundo campos.
  Reitere.

Rotina para que se copie um campo para um segundo campo:
  Se o campo for inexistente,
    Esvazie o segundo campo;
    Retorne.
  Aloque memória para o segundo campo.
  Atribua o endereço local deste campo ao endereço local deste segundo campo.
  Atribua o nome deste campo ao nome deste segundo campo.
  Atribua o apelido deste campo ao apelido deste segundo campo.
  Atribua o nome do tipo deste campo ao nome do tipo deste segundo campo.
  Atribua o tipo deste campo ao tipo deste segundo campo.
  Atribua a contagem deste campo à contagem deste segundo campo.
  Atribua o novo nome deste campo ao novo nome deste segundo campo.
  Atribua o sinalizador de referência deste campo ao sinalizador de referência deste segundo campo.
  Atribua o deslocamento deste campo ao deslocamento deste segundo campo.

\Função para que se determine se um campo está duplicado em uns campos;
Função para que se determine se uma variável está duplicada em umas variáveis:
  \Itere.
    Obtenha uma segunda variável desde as variáveis.
    Se a segunda variável for inexistente, diga não.
    Se o nome desta segunda variável estiver em branco, reitere.
    Se a segunda variável for a variável, reitere.
    Se o nome desta segunda variável for o nome desta variável, diga sim.
  Reitere.

Rotina para que se destrinche um campo:
  Se existir algum problema de compilação, retorne.
  Se o campo for inexistente, retorne.
  Destrinche o campo tal como uma variável.
  Se o apelido deste campo não for algum nome de campo válido,
    Limpe o apelido deste campo. \ poderia encurtar para "Limpe-o" ou "limpe ele" "it"
  Se o nome deste campo não for algum nome de campo válido,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #046. O identificador '" junto com o nome deste campo seguido de 
      "' corresponde a um nome de campo inválido." junto com o texto CRLF e o endereço local deste campo;
    Retorne.

Função para que se determine se um nome é algum nome de campo válido:
  Se o nome for alguma palavra-chave de obtenção de tamanho de variável, diga não.
  Se o nome for algum conteúdo, diga não.
  Se o nome for algum endereçamento, diga não.
  Diga sim.

Função para que se determine se um nome é alguma palavra-chave de obtenção de tamanho de variável:
  Se o nome for "magnitude", diga sim.
  \ A "magnitude" retorna o tamanho em bytes de algo
  \ Exemplo: a magnitude desta estrutura
  Diga não.

Função para que se determine se um nome é algum conteúdo:
  Se o nome for "conteúdo", diga sim.
  \Este comando é usado apenas com ponteiros (endereços de memória).
  \ Serve pra saber para quais valores o ponteiro está apontando, ou seja, o conteúdo do ponteiro .
  \"Um endereço de byte" ou "O ponteiro de byte", por exemplo, refere-se ao endereço de um byte.
  \"O conteúdo deste endereço de byte" refere-se, portanto aos dados no contidos no byte
  Diga não.

Função para que se determine se um nome é algum endereçamento:
  Se o nome for "endereçamento", diga sim.  \ retorna o endereço do dado
  Diga não.

Rotina para que se elimine apelidos duplicados desde umas variáveis:
  Crie um catálogo usando 101.
  Elimine apelidos duplicados desde as variáveis usando o catálogo.
  Destrua o catálogo.

Rotina para que se elimine apelidos duplicados desde umas variáveis usando um catálogo:
  Se o catálogo for inexistente, retorne.
  Itere.
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Elimine apelidos duplicados usando a variável e o catálogo.
  Reitere.

Rotina para que se elimine apelidos duplicados usando uma variável e um catálogo:
  Se a variável for inexistente, retorne.
  Se o catálogo for inexistente, retorne.
  Encontre uma segunda variável usando o apelido desta variável e o catálogo.
  Se a segunda variável for inexistente, \ encontre-a
    Encontre a segunda variável usando o nome desta variável e o catálogo.
  Se a segunda variável for inexistente, \ catalogue-a
    Catalogue a variável usando o apelido desta variável e o catálogo;
    Retorne.
  Limpe o apelido desta segunda variável.
  Limpe o apelido desta variável.

Rotina para que se copie uns campos para uns outros campos (apenas campos de dados):
  \Se o primeiro campo destes campos for inexistente, retorne.
  Se a contagem destes campos for menor do que 4, retorne. \ próximo/próxima, anterior/precedente
  Atribua o próximo campo
    deste próximo campo
    deste próximo campo
    deste próximo campo
    deste primeiro campo destes campos
    para um campo.
  Itere.
    Se o campo for inexistente, retorne.
    Copie o campo para um novo campo.
    Acrescente o novo campo para os outros campos.
    Obtenha o campo desde os campos.
  Reitere.

Rotina para que se destrinche um tipo (dados opcionais - tipos fracionários):
  Se existir algum problema de compilação, retorne.
  Atribua o tipo base deste tipo para um tipo base.
  Se a razão de escala deste tipo for 0,
    Atribua a razão de escala deste tipo base deste tipo à razão de escala deste tipo;
    Retorne.
  Se a razão de escala deste tipo base for 0, retorne.
  Multiplique a razão de escala deste tipo pela razão de escala deste tipo base.
  Atribua o tipo base deste tipo base ao tipo base deste tipo.

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (identificação de variáveis globais): \ #005
  Se existir algum problema de compilação, retorne.
  Escreva "Identificando variáveis globais..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de resolução de variáveis globais.
  Destrinche as variáveis globais.
  Suspenda o temporizador de resolução de variáveis globais.

Rotina para que se destrinche umas variáveis globais:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma variável global desde as variáveis globais.
    Se a variável global for inexistente, retorne.
    Destrinche a variável global.
  Reitere.

Rotina para que se destrinche uma variável global:
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o corpo de variável global desta variável global não estiver em branco,
    Destrinche a variável global (compilação do corpo).
  Se o nome do tipo desta variável global estiver em branco,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #047. A variável global '" junto com o nome desta variável global 
      seguido de "' possui um tipo inválido." e o endereço local desta variável global;
    Retorne.
  Destrinche a variável global tal como uma variável.

Rotina para que se destrinche uma variável global (compilação do corpo):
  Se a variável global for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre o corpo de variável global desta variável global.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum valor literal,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #048. Erro de tipo. O tipo: '" junto com o segmento inicial deste percorredor 
      seguido de "' deve possuir um valor literal." junto com o texto CRLF e o percorredor;
    Retorne.
  Compile um valor literal usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo 
      "Código de Erro #049. Esperado '.' após a declaração de uma variável global."\ ao invés de " 
      [junto com o segmento inicial deste percorredor ] junto com o texto CRLF e o percorredor;
    Retorne.
  Se o nome do tipo desta variável global estiver em branco,
    Atribua o nome deste tipo deste valor literal ao nome do tipo desta variável global.
  Atribua o valor literal ao valor literal desta variável global.
  Catalogue o valor literal.

Rotina para que se compile um valor literal usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Adicione o valor literal para os valores literais usando o caractere inicial deste segmento inicial deste percorredor .
  \Se o segmento inicial deste percorredor for algum sinalizador literal,
    \compile o valor literal usando o percorredor (valores booleanos);
    \Retorne.
  \Se o segmento inicial deste percorredor for algum número ordinal,
    \Compile o valor literal usando o percorredor (números ordinais);
    \Retorne.
  Se o segmento inicial deste percorredor for algum valor hexadecimal literal,
    Compile o valor literal usando o percorredor (valores hexadecimais);
    Retorne.
  Se o segmento inicial deste percorredor for algum valor numérico literal,
    Compile o valor literal usando o percorredor (valor numérico - análise preliminar);
    Retorne.
  Se o segmento inicial deste percorredor for algum ponteiro literal,
    Compile o valor literal usando o percorredor (ponteiros);
    Retorne.
  Se o segmento inicial deste percorredor for alguma string literal,
    Compile o valor literal usando o percorredor (cadeia de caracteres);
    Retorne.
  \Se o segmento inicial deste percorredor não for nada disso,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #050. O valor literal '" \ Erro interno
      junto com o segmento inicial deste percorredor seguido de 
      "' não pode ser compilado." junto com o texto CRLF e o percorredor.

Rotina para que se adicione um valor literal para umas variáveis usando um endereço local:
  Adicione o valor literal tal como uma variável para as variáveis usando "valor literal" e o endereço local.
  Gere o nome deste valor literal usando "~L".

Rotina para que se gere um nome usando uma string:
  Atribua a string ao nome.
  Adicione 1 para a contagem de nomes deste compilador.
  Converta a contagem de nomes deste compilador para uma segunda string.
  Acrescente a segunda string para o nome.

Rotina para que se compile um valor literal usando um percorredor (valores hexadecimais):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta a parte da cifra binária para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "texto hexadecimal" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

\Rotina para que se converta uma parte da cifra binária para uma string:
  \Empregue [a rotina] converta uma cifra hexadecimal para um texto hexadecimal.

Rotina para que se destrinche uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Se o tipo desta variável não for inexistente, retorne.
  Se o nome do tipo desta variável não estiver em branco,
    Destrinche a variável (usando o nome do tipo declarado);
    Retorne.
  Encontre o tipo desta variável e o apelido desta variável usando o nome desta variável.
  Se o tipo desta variável não for inexistente,
    Atribua o nome deste tipo desta variável ao nome do tipo desta variável;
    Retorne.
  \Se o tipo desta variável for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #051. Não foi possível determinar o tipo da variável '" 
      junto com o nome desta variável seguido de "'." junto com o texto CRLF e o endereço local desta variável.

Rotina para que se destrinche uma variável (usando o nome do tipo declarado):
  Encontre o tipo desta variável usando o nome do tipo desta variável e o catálogo de tipos.
  Se o tipo desta variável for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #052. Não foi possível determinar o tipo da variável '" 
      junto com o nome do tipo desta variável seguido de "'." e o endereço local desta variável;
    Retorne.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o percorredor estiver acompanhado por alguma unidade de medida,
    Compile o valor literal usando o percorredor (valor numérico - unidade de medida);
    Retorne.
  Se o segmento inicial deste percorredor for algum número inteiro,
    Compile o valor literal usando o percorredor (valor numérico - números inteiros);
    Retorne.
  Se o segmento inicial deste percorredor for alguma proporção literal,
    Compile o valor literal usando o percorredor (valor numérico - números fracionários);
    Retorne.
  Se o segmento inicial deste percorredor for algum numeral misto literal,
    Compile o valor literal usando o percorredor (valor numérico - números fracionários);
    Retorne.

Função para que se determine se um percorredor está acompanhado por alguma unidade de medida:
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o percorredor não estiver sobre algum indicador de início de variável, diga não.
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente, diga não.
  Se o nome não for algum operador de multiplicação, diga sim. \ TODO: substituir por "operador aritmético"
  Se o segmento inicial deste percorredor for o início de alguma expressão matemática, diga não.
  Diga sim.

Função para que se determine se uma string é algum operador de multiplicação:
  Se a string for "vezes", diga sim.
  Diga não.

Função para que se determine se uma string é o início de alguma expressão matemática:
  Se a string for algum sinal aritmético, diga sim.
  Se a string for algum artigo indefinido, diga sim.
  Se a string for algum artigo definido, diga sim.
  Se a string for algum valor literal, diga sim.
  Diga não.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - unidade de medida):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo usando o nome e o catálogo de tipos.
  Se o tipo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #053. O identificador '" junto com o nome seguido de 
      "' faz referência a unidade de medida inexistente." e o endereço local deste valor literal;
    Retorne.
  Se o tipo não puder ser reduzido para "número",
    Apresente a mensagem de erro contendo 
      "Código de Erro #054. O identificador '" junto com o nome seguido de 
      "' não corresponde um tipo numérico válido." e o endereço local deste valor literal;
    Retorne.
  Atribua a razão de escala deste tipo para uma proporção denominada proporção fixa.
  Se a razão de escala deste tipo for 0,
    Atribua 1/1 para a proporção fixa.
  \Se a razão de escala deste tipo não for 0,
    Multiplique a proporção fixa pelo proporção.
  Reduza a proporção fixa.
  Se o denominador deste proporção fixa for 0,
    Apresente a mensagem de erro contendo 
      "Código de Erro #055. Proporção com denominador igual a 0. Unidade de medida inválida."
      [junto com o nome deste tipo seguido de "'."] e o endereço local deste valor literal.
  Atribua o numerador deste proporção fixa dividido pelo denominador desta proporção fixa para um número.
  Atribua o nome deste tipo ao nome do tipo deste valor literal.
  Converta o número para o data deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - números inteiros):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para um número.
  Converta o número para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (valor numérico - números fracionários):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para uma proporção.
  Converta a proporção para o data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "proporção" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (ponteiros):
  Se existir algum problema de compilação, retorne.
  Converta 0 para os data deste valor literal. \ era "nulo" ao invés de 0
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "ponteiro" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se compile um valor literal usando um percorredor (cadeia de caracteres):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor aos data deste valor literal.
  Remova as aspas desses data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "string" ao nome do tipo deste valor literal.
  \Atribua "texto" ao nome do tipo deste valor literal.
  Destrinche o valor literal.

Rotina para que se catalogue um valor literal:
  Se existir algum problema de compilação, retorne.
  Se o valor literal for inexistente, retorne.
  Se o nome deste valor literal estiver no catálogo de variáveis hexadecimais,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #056. Esta variável já foi inicializada anteriormente." \ Erro interno
      [junto com o nome deste valor literal]
      e o endereço local deste valor literal;
    Retorne.
  Catalogue o valor literal usando o nome deste valor literal e o catálogo de variáveis hexadecimais.

\ ------------------------------------------------------------------------------ ROTINAS EXTRAS ----------------------------------------------------------

Rotina para que se compile um valor literal usando um percorredor (valores booleanos):
  Se existir algum problema de compilação, retorne.
  Converta o segmento inicial deste percorredor para um sinalizador.
  Converta o sinalizador para os data deste valor literal.
  Mova o percorredor (usando diretrizes de compilação).
  Atribua "sinalizador" ao nome do tipo deste valor literal.
  Destrinche o valor literal. \ 

Rotina para que se compile um valor literal usando um percorredor (números ordinais):
  Se existir algum problema de compilação, retorne.
  Atribua o segmento inicial deste percorredor aos data deste valor literal.
  Remova o último caractere desses data deste valor literal.
  \Converta o segmento inicial deste percorredor para um número.
  \Converta o número para os data deste valor literal.
  \Converta 0 para os data deste valor literal. \ era nulo ao invés de 0
  Mova o percorredor (usando diretrizes de compilação).
  \Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal. \ 

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (cabeçalhos de rotinas): \ #006
  Se existir algum problema de compilação, retorne.
  Escreva "Agrupando os nomes das rotinas..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de compilação de cabeçalhos de rotina.
  Compile os cabeçalhos apropriados para as rotinas.
  Suspenda o temporizador de compilação de cabeçalhos de rotina.

Rotina para que se compile os cabeçalhos apropriados para umas rotinas:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Compile o cabeçalho próprio à rotina.
  Reitere.

Rotina para que se compile o cabeçalho próprio para uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Lance um percorredor sobre a cabeçalho de rotina desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum comando de deliberação,
    Compile o cabeçalho próprio à rotina usando o percorredor (rotina deliberativa);
    Retorne.
  Se o percorredor for o início de alguma função possessiva reversa,
    Compile o cabeçalho próprio à rotina usando o percorredor (função do possessivo reverso);
    Retorne.
  Se o percorredor for o início de alguma função,
    Compile o cabeçalho próprio à rotina usando o percorredor (função);
    Retorne.
  Se o segmento inicial deste percorredor for "compativelmente",
    Compile o cabeçalho próprio à rotina usando o percorredor (modo de compatibilidade);
    Retorne.
  Compile o cabeçalho próprio à rotina usando o percorredor (procedimento).

Função para que se determine se uma string é algum comando de deliberação:
  \Se a string for "decida", diga sim.
  Se a string for "determine", diga sim.
  \Se a string for "esclareça", diga sim.
  Diga não.

Rotina para que se compile o cabeçalho próprio para uma rotina usando um percorredor (rotina deliberativa):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #057. Esperado encontrar 'para que se determine se'. Encontrado '" 
      junto com o segmento inicial deste percorredor junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de deliberação desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Se algumas dentre as unidades semânticas desta rotina forem advérbios de negação,
    Apresente a mensagem de erro contendo 
      "Código de Erro #058. É proibido utilizar o identificador 'não' em cabeçalhos de funções booleanas." junto com o texto CRLF e o percorredor;
    Retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo 
    "Código de Erro #059. A rotina para que se ''" junto com a representação interna da rotina desta rotina 
    seguido de "' já havia sido definida anteriormente." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Função para que se determine se uma string é algum comando condicional:
  Se a string for "se", diga sim.
  Se a string for "quando", diga sim.
  Diga não.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum artigo definido,
    Compile as unidades semânticas e o parâmetros usando o percorredor (artigo definido);
    Reitere.
  Se o percorredor estiver sobre algum artigo indefinido,
    Compile as unidades semânticas e o parâmetros usando o percorredor (artigo indefinido);
    Reitere.
  Se o percorredor estiver sobre alguma string de unidade semântica,
    Compile as unidades semânticas e o parâmetros usando o percorredor (string de unidade semântica);
    Reitere.
  \Se o percorredor estiver sobre uma rotina não definida,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #060. A rotina 'para que se '" junto com o segmento inicial deste percorredor 
      seguido de "' não foi localizada." junto com o texto CRLF e o percorredor.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo definido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Anteponha "o " para o nome.
  Adicione uma unidade semântica para as unidades semânticas usando o nome.

\ Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando uma string:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  \-------------------------------------------------------------- VERBO SER -------------------------------------------------------
  Se a string for "é",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "for",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "foi",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "foram",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "forem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
    Se a string for "seja",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "sejam",
    Atribua "é" à string desta unidade semântica;
    Retorne.
    Se a string for "são",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "forem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  \-------------------------------------------------------------- VERBO ESTAR -------------------------------------------------------
    Se a string for "está",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estão",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiver",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estiverem",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  Se a string for "estamos",
    Atribua "é" à string desta unidade semântica;
    Retorne.
  \-------------------------------------------------------------- VERBO TER --------------------------------------------------------------
  Se a string for "tiver",
    Atribua "tem" à string desta unidade semântica;
    Retorne.
  \-------------------------------------------------------------- VERBO HAVER ----------------------------------------------------------
  Se a string for "houver",
    Atribua "há" à string desta unidade semântica;
    Retorne.
  \------------------------------------------------------------- VERBO EXISTIR ----------------------------------------------------------  
  Se a string for "existir",
    Atribua "existe" à string desta unidade semântica;
    Retorne.
  \-------------------------------------------------------------- DEMAIS VERBOS -------------------------------------------------------
  Se a string for "começar",
    Atribua "começa" à string desta unidade semântica;
    Retorne.
  Se a string for "começa",
    Atribua "começa" à string desta unidade semântica;
    Retorne.
  Se a string for "termina",
    Atribua "termina" à string desta unidade semântica;
    Retorne.
  Se a string for "terminar",
    Atribua "termina" à string desta unidade semântica;
    Retorne.
  Se a string for "puder",
    Atribua "pode" à string desta unidade semântica;
    Retorne.
  Se a string for "puderem",
    Atribua "pode" à string desta unidade semântica;
    Retorne.
  Se a string for "possuir",
    Atribua "possui" à string desta unidade semântica;
    Retorne.
  Se a string for "cabe",
    Atribua "cabe" à string desta unidade semântica;
    Retorne.
  Se a string for "couber",
    Atribua "cabe" à string desta unidade semântica;
    Retorne.
  \ ----------------------------------------------- USANDO | DESDE | DADO ----------------------------------------------------------------------
  Se a string for "desde",
    Atribua "usando" à string desta unidade semântica;
    Retorne.  
  Se a string for "dada",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dado",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dadas",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "dados",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "com",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "usando",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  Se a string for "contendo",
    Atribua "usando" à string desta unidade semântica;
    Retorne.
  \ ----------------------------------------------------------------------- PREPOSIÇÕES -----------------------------------------------------
  Se a string for "em",
    Atribua "para" à string desta unidade semântica;
    Retorne.
  Se a string for "a",
    Atribua "para" à string desta unidade semântica;
    Retorne.
  \---------------------------------------------------------------------- CONTRAÇÕES ------------------------------------------------------
  Se a string for "pelo",
    Atribua "por o" à string desta unidade semântica;
    Retorne.
  Se a string for "pela",
    Atribua "por o" à string desta unidade semântica;
    Retorne.
  \ sobre
  Se a string for "sob",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  Se a string for "sobre",
    Atribua "sobre" à string desta unidade semântica;
    Retorne.
  Se a string for "parde",
  \ contração de "para" com "de, usada internamente pelo compilador para distinguir a preposição "de" 
    Atribua "de" à string desta unidade semântica;
    Retorne.
  \ ------------------------------------------------------------------- DEMAIS CASOS ------------------------------------------------------
  Atribua a string à string desta unidade semântica.

Função para que se determine se um percorredor está sobre algum artigo indefinido:
  Se o percorredor estiver sobre alguma preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo indefinido, diga não.
  Diga sim.

Função para que se determine se um percorredor está sobre alguma preposição conectiva:
  Se o segmento inicial deste percorredor não for alguma preposição especial, diga não.
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Se o segmento inicial deste percorredor for algum número literal, diga sim.
  Diga não.

Função para que se determine se uma string é alguma preposição especial:
  Se a string for "a", diga sim.
  Se a string for "de", diga sim.
  Diga não.

Função para que se determine se uma string é algum número literal:
  Se a string for algum valor numérico literal, diga sim.
  Se a string for algum ponteiro literal, diga sim.
  Se a string for algum valor hexadecimal literal, diga sim.
  Diga não.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (artigo indefinido):
  Se existir algum problema de compilação, retorne.
  Adicione um parâmetro para o parâmetros usando "parâmetro" e o caractere inicial deste segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome deste parâmetro com o nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação,
    Compile a parte designadora usando o percorredor e o parâmetro.
  Destrinche o parâmetro.
  Se o parâmetro estiver duplicada nos parâmetros,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #061. O identificador '" junto com o nome deste parâmetro seguido de 
      "' já foi declarado como parâmetro anteriormente nesta rotina." e o endereço local deste parâmetro;
    Retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o tipo deste parâmetro.

Rotina para que se compile a parte designadora usando um percorredor e uma variável:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Atribua o nome desta variável ao nome do tipo desta variável.
  Mova o percorredor (usando diretrizes de compilação).
  Examine o nome desta variável usando o percorredor.

Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando um tipo:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  Atribua o tipo ao tipo desta unidade semântica.

Função para que se determine se um percorredor está sobre alguma string de unidade semântica:
  Se o segmento inicial deste percorredor estiver em branco, diga não.
  Se o percorredor estiver sobre algum artigo definido, diga não.
  Se o percorredor estiver sobre algum artigo indefinido, diga não.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga não.
  Se o segmento inicial deste percorredor for algum valor literal, diga não.
  Se o segmento inicial deste percorredor for algum sinal de pontuação, diga não.
  Se o segmento inicial deste percorredor for algum símbolo, diga não.
  Se o segmento inicial deste percorredor for "então", diga não.
  Diga sim.

Função para que se determine se um percorredor está sobre algum artigo definido:
  Se o percorredor estiver sobre alguma preposição conectiva, diga não.
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
  Diga sim.

Rotina para que se compile umas unidades semânticas e uns parâmetros usando um percorredor (string de unidade semântica):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Função para que se determine se algumas dentre umas unidades semânticas são advérbios de negação:
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, diga não. \ return false
    Se a string desta unidade semântica for algum advérbio de negação, diga sim.\ return true
  Reitere.

Rotina para que se converta umas unidades semânticas para uma representação interna da rotina:
  Converta as unidades semânticas para 
    a representação interna da rotina usando 
    a última unidade semântica destas unidades semânticas.

Rotina para que se converta umas unidades semânticas para uma representação interna da rotina usando uma unidade semântica:
  Limpe a representação interna da rotina.
  Itere.
    Obtenha uma unidade semântica denominada unidade atual desde as unidades semânticas.
    Se a unidade atual for inexistente, retorne.
    Acrescente a unidade atual para a representação interna da rotina.
    Se a unidade atual for a unidade semântica, retorne.
  Reitere.

Rotina para que se acrescente uma unidade semântica para uma representação interna da rotina :
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco,
    Acrescente o caractere de espaço para a representação interna da rotina.
  Se o tipo desta unidade semântica não for inexistente,
    Acrescente "[" e o nome deste tipo desta unidade semântica e "]" para a representação interna da rotina (rapidamente);
    Retorne. \ moniker
  Se a string desta unidade semântica não estiver em branco,
    Acrescente a string desta unidade semântica para a representação interna da rotina;
    Retorne.
  
\ Rotina para que se acrescente 3 strings distintas para uma string.
Rotina para que se acrescente uma string e uma segunda string e uma terceira string para uma quarta string (rapidamente):
  Atribua a quantidade de caracteres desta quarta string para uma quantidade de caracteres.
  Adicione a quantidade de caracteres desta string para a quantidade de caracteres.
  Adicione a quantidade de caracteres desta segunda string para a quantidade de caracteres.
  Adicione a quantidade de caracteres desta terceira string para a quantidade de caracteres.
  Reaponte um ponteiro usando a quantidade de caracteres.
  Atribua o ponteiro para um endereço de byte .
  Copie bytes desde o caractere inicial desta quarta string para o endereço de byte pelo quantidade de caracteres desta quarta string.
  Adicione a quantidade de caracteres desta quarta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta string para o endereço de byte pelo quantidade de caracteres desta string.
  Adicione a quantidade de caracteres desta string para o endereço de byte .
  Copie bytes desde o caractere inicial desta segunda string para o endereço de byte pelo quantidade de caracteres desta segunda string.
  Adicione a quantidade de caracteres desta segunda string para o endereço de byte .
  Copie bytes desde o caractere inicial desta terceira string para o endereço de byte pelo quantidade de caracteres desta terceira string.
  Desassocie o caractere inicial desta quarta string.
  Atribua o ponteiro ao caractere inicial desta quarta string.
  Atribua o ponteiro mais a quantidade de caracteres menos 1 ao caractere final desta quarta string.

Função para que se determine se uma representação interna da rotina está em um catálogo:
  Encontre um referência usando a representação interna da rotina e o catálogo.
  Se o referência for inexistente, diga não.
  Se o ponteiro deste referência for inexistente, diga não.
  Diga sim.

Rotina para que se catalogue uma rotina usando umas unidades semânticas e um catálogo:
  Se a rotina for inexistente, retorne.
  Limpe um cabeçalho compactado.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Acrescente a unidade semântica para o cabeçalho compactado.
    Se a unidade semântica for a última unidade semântica destas unidades semânticas, pare.
    Catalogue o cabeçalho compactado usando o catálogo (especial).
  Reitere.
  Catalogue a rotina usando o cabeçalho compactado tal como uma representação interna da rotina e o catálogo (especial).

Rotina para que se catalogue um cabeçalho compactado usando um catálogo (especial):
  Encontre uma referência usando o cabeçalho compactado e o catálogo.
  Se a referência não for inexistente, retorne.
  Catalogue o cabeçalho compactado no catálogo.

Rotina para que se catalogue uma rotina usando uma representação interna da rotina e um catálogo (especial):
  Encontre uma referência usando a representação interna da rotina e o catálogo.
  Se a referência não for inexistente,
    Atribua a rotina ao ponteiro deste referência;
    Retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo.

\ Rotina nova criada pelo Dahn para - reverse functions
\ para atribua o xxx uv a/the yyy para zzz
Função para que se determine se um percorredor é o início de alguma função possessiva reversa:
  Se o sinalizador de erros deste compilador estiver ativo, diga não.
  Se o segmento inicial deste percorredor não for algum comando de atribuição, diga não.
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo definido, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor não estiver sobre algum possessivo reverso, diga não.
  Diga sim.

Função para que se determine se uma string é algum comando de atribuição:
  \"Rotina para que se acrescente uma string para uma segunda string usando uma terceira string (para expandir contrações)"
  Se a string for "atribua", diga sim.
  Diga não.

\ Rotina nova criada pelo Dahn para o possessivo reverso
\ Por exemplo, na rotina "para que se atribua o campo duma estrutura para uma variável:"
\ Internamente o compilador altera a estrutura da frase para:
\ "Para que se atribua a estrutura's campo para uma variável:"
Rotina para que se compile o cabeçalho próprio para uma rotina usando um percorredor (função do possessivo reverso):
  Se existir algum problema de compilação, retorne.
  Ative o sinalizador de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação). \ ignora "atribua"
  Mova o percorredor (usando diretrizes de compilação). \ ignora o artigo definido
  Examine um nome usando o percorredor. \ o nome do campo
  Mova o percorredor (usando diretrizes de compilação). \ ignora o "de"
  Se o segmento inicial deste percorredor for algum artigo indefinido, \ "dum" -> "de um"
    Ative um sinalizador.
  Se o sinalizador estiver ativo,
    Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o sinalizador não estiver ativo,
    Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo definido).
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for alguma preposição de atribuição,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #062. Esperado: 'para'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo 
      "Código de Erro #063. A 'rotina para que se " junto com a representação interna da rotina 
      seguido de "' já foi definida anteriormente." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo 
      "Código de Erro #064. Erro. Esperado encontrar um artigo indefinido. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Compile as unidades semânticas desta rotina e o parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo 
      "Código de Erro #065. O compilador detectou instruções inválidas no final desta rotina." 
      [junto com o segmento inicial deste percorredor seguido de "'." junto com] junto com o texto CRLF e o percorredor;
    Retorne.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ Para os employs

Função para que se determine se uma string é alguma preposição de atribuição:
  Se a string for "em", diga sim.
  Se a string for "para", diga sim.
  Diga não.

Função para que se determine se um percorredor é o início de alguma função:
  Se existir algum problema de compilação, diga não.  
  \Se o segmento inicial deste percorredor não for algum comando de atribuição, diga não.
  Se o segmento inicial deste percorredor não for "atribua", diga não.
  Preserve o percorredor.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo, diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o segmento inicial deste percorredor for algum possessivo inglês, diga sim.
  Diga não.

Rotina para que se compile o cabeçalho próprio para uma rotina usando um percorredor (função):
  Se existir algum problema de compilação, retorne.
  Ative o sinalizador de função desta rotina.
  Adicione uma unidade semântica para as unidades semânticas desta rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido,
    Ative um sinalizador.
  Se o sinalizador estiver ativo,
    Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o sinalizador não estiver ativo,
    Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessivo inglês,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #066. Funções de atribuição requerem a utilização de um apóstro seguido de um s ['s]" junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para as unidades semânticas desta rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para",
    Apresente a mensagem de erro contendo 
      "Código de Erro #067. Esperado 'para' após o identificador. Encontrado '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne. \ not translated - no possessives em Spanish
  Adicione uma terceira unidade semântica para as unidades semânticas desta rotina usando "para".
  Converta as unidades semânticas desta rotina para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas,
    Apresente a mensagem de erro contendo 
      "Código de Erro #068. A rotina para que se '" junto com a representação interna da rotina 
      seguido de "' já foi definida anteriormente." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo 
      "Código de Erro #069. Esperava encontrar um artigo indefinido. Encontrado '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor (artigo indefinido).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo 
      "Código de Erro #070. O compilador detectou instruções inválidas no final desta rotina." junto com o texto CRLF e o percorredor;
    Retorne. \ not translated - no possessives em Spanish
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas. \ para utilizar com os employs

Rotina para que se compile o cabeçalho próprio para uma rotina usando um percorredor (modo de compatibilidade): \ callback
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Ative o sinalizador de compatibilidade desta rotina.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #071. A 'rotina para que se '" junto com a representação interna da rotina desta rotina 
      seguido de "' já foi definida anteriormente." e o endereço local desta rotina;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

Rotina para que se compile o cabeçalho próprio para uma rotina usando um percorredor (procedimento):
\Erro noodle
  Se existir algum problema de compilação, retorne.
  Compile as unidades semânticas desta rotina e os parâmetros desta rotina usando o percorredor.
  Converta as unidades semânticas desta rotina para a representação interna da rotina desta rotina.
  Se a representação interna da rotina desta rotina estiver no catálogo geral de rotinas,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #072. A 'rotina para que se '" junto com a representação interna da rotina desta rotina 
      seguido de "' já foi definida anteriormente." e o endereço local desta rotinas;
    Retorne.
  Catalogue a rotina usando as unidades semânticas desta rotina e o catálogo geral de rotinas.

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (cálculo de tamanhos e deslocamentos): \ #007
  Se existir algum problema de compilação, retorne.
  Escreva "Calculando tamanhos de variáveis e deslocamentos de memória..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de etapas de cálculo.
  Calcule os comprimentos referentes aos tipos.
  Calcule os deslocamentos nos tipos.
  Calcule os deslocamentos das redefinições no tipos.
  Suspenda o temporizador de etapas de cálculo.

Rotina para que se calcule os comprimentos referentes para uns tipos;
Rotina para que se calcule os comprimentos relacionados com uns tipos:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Calcule a quantidade de caracteres referentes ao tipo.
  Reitere.

Rotina para que se calcule a quantidade de caracteres referentes para um tipo;
Rotina para que se calcule a quantidade de caracteres relacionados com um tipo:
  Se o tipo for inexistente, retorne.
  Se a quantidade de caracteres deste tipo não for -1, retorne. \ sai da RECURSÃO
  Calcule a quantidade de caracteres referentes ao tipo base deste tipo. \ RECURSÃO
  Se os campos deste tipo estiverem vazios,
    Atribua a quantidade de caracteres deste tipo base deste tipo à quantidade de caracteres deste tipo;
    Retorne.
  \ Se os campos deste tipo não estiverem vazios,
    Atribua 0 à quantidade de caracteres deste tipo.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde o campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo não estiver em branco, reitere.
    Calcule a quantidade de caracteres relacionados com o tipo deste campo. \ RECURSÃO
    Adicione a quantidade de caracteres deste tipo deste campo vezes a contagem deste campo para a quantidade de caracteres deste tipo.
  Reitere.

Rotina para que se calcule os deslocamentos em uns tipos:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Calcule os deslocamentos no tipo.
  Reitere.

Rotina para que se calcule os deslocamentos em um tipo:
  Se o tipo for inexistente, retorne.
  Atribua 0 para um deslocamento.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo não estiver em branco, reitere.
    Atribua o deslocamento ao deslocamento deste campo.
    Adicione a quantidade de caracteres deste tipo deste campo vezes a contagem deste campo para o deslocamento.
  Reitere.

Rotina para que se calcule os deslocamentos das redefinições em uns tipos:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde o tipos.
    Se o tipo for inexistente, retorne.
    Calcule os deslocamentos das redefinições no tipo.
  Reitere.

Rotina para que se calcule os deslocamentos das redefinições em um tipo:
  Se o tipo for inexistente, retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, retorne.
    Se o novo nome deste campo estiver em branco, reitere.
    Encontre um segundo campo usando o novo nome deste campo e os campos deste tipo.
    Se o segundo campo for inexistente,
      Apresente uma mensagem de erro contendo "Código de Erro #073. O campo '" 
        junto com o novo nome deste campo seguido de "' não pode ser localizado na estrutura '"
        junto com o nome deste tipo seguido de "'." e o endereço local deste campo;
      Retorne.
    Atribua o deslocamento deste segundo campo ao deslocamento deste campo.
  Reitere.

Rotina para que se encontre uma variável usando um nome e umas variáveis:
  Esvazie a variável.
  Itere.
    Obtenha a variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Se o nome desta variável for o nome, retorne.
    Se o apelido desta variável for o nome, retorne.
  Reitere.

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (adição de rotinas de memória incorporadas): \ #008
  Se existir algum problema de compilação, retorne.
  Escreva "Adicionando tarefas predefinidas na memória..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de adição de rotinas pré-definidas de mémoria .
  Adicione as rotinas de alocação e desalocação e finalização e destruição.
  Suspenda o temporizador de adição de rotinas pré-definidas de mémoria.

Rotina para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um tipo desde os tipos.
    Se o tipo for inexistente, retorne.
    Adicione a rotina de finalização para o tipo.
    Adicione a rotina de alocação para o tipo.
    Adicione a rotina de desalocação para o tipo.
    Adicione a rotina de destruição para o tipo.
 Reitere.

Rotina para que se adicione a rotina de finalização para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser finalizado, retorne.
  Se o nome deste tipo for "string",
    Adicione a rotina de finalização para o tipo (cadeia de caracteres);
    Retorne.
  Se o tipo puder ser reduzido para "string", retorne.
  \ impede a geração de finalizadores para tipos derivados de string
  Adicione a rotina de finalização para o tipo (estrutura).

Função para que se determine se um tipo deveria ser finalizado: 
  [determina se o compilador deveria desalocar a memória alocada para algum tipo]
  Se o tipo for inexistente, diga não.
  Se o tipo puder ser reduzido para "subtexto", diga não.
  \ Substrings apontam para partes de strings reais, que por sua vez, serão desalocadas
  Se o tipo puder ser reduzido para "string", diga sim.
  \ O caso padrão para strings
  Se os campos deste tipo deveriam ser finalizados, diga sim.
  \ Para strings dentro de estruturas
  Diga não.

Função para que se determine se uns campos deveriam ser finalizados;
Função para que se determine se uns campos deveria ser finalizado:
  Obtenha um campo desde o campos.
  Se o campo for inexistente, diga não.
  Se o tipo deste campo deveria ser finalizado, diga sim.
  Reitere.

Rotina para que se adicione a rotina de finalização para um tipo (cadeia de caracteres):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina.
  \ push eax -> Empilha o valor presente no registrador EAX na stack
  \ A instrução push primeiro subtrai 4 do registrador ESP (o ponteiro da pilha)
  \ Depois coloca o operando no conteúdo apontado por ele
  \ A stack no x86 começa com o maior endereço e vai decrescendo, por isso a subtração
  Acrescente "Desassocie o caractere inicial de esta string . " para a string do corpo desta rotina. \ "string"
  Acrescente "Decodifique $58." para a string do corpo desta rotina.
  \ pop eax -> Move o elemento do topo da pilha (ESP), transferindo ele para o registrador EAX 
  \ Depois ele adiciona 4 para o valor do ESP
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho próprio para a rotina.

Rotina para que se adicione a rotina de finalização para um tipo (estrutura):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "~Finalize um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Decodifique $50. " para a string do corpo desta rotina. \push eax
  Itere.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente, pare.
    Se o tipo deste campo não deveria ser finalizado, reitere.
    Acrescente "~Finalize o " junto com o nome deste tipo seguido de "'s " 
      junto com o nome deste campo seguido de ". " para a string do corpo desta rotina.
  Reitere.
  Acrescente "Decodifique $58." para a string do corpo desta rotina. \ pop eax 
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho próprio à rotina.

Rotina para que se adicione a rotina de alocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Aloque memória para um " junto com o nome deste tipo 
    para a string do cabeçalho desta rotina. \ 
  Acrescente "Associe o " junto com o nome deste tipo 
    seguido de " usando " para a string do corpo desta rotina. \ Acomodar
  Acrescente a quantidade de caracteres deste tipo do conteúdo deste tipo 
    seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho próprio à rotina.

Rotina para que se adicione a rotina de desalocação para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não puder ser reduzido para "ponteiro", retorne.
  Se o tipo do conteúdo deste tipo for inexistente, retorne.
  Adicione uma rotina para as rotinas usando nil. \ Desaloque memória para o
  Acrescente "Desaloque um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo 
    seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo deveria ser finalizado [automaticamente por uma rotina],
    Acrescente "~Finalize o conteúdo de este " 
      junto com o nome deste tipo seguido de ". " para a string do corpo desta rotina.
  \ Chamado quando o tipo precisa ter uma rotina de destruição gerada automaticamente para ele
  Acrescente "Desassocie o " junto com o nome deste tipo 
    seguido de "." para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho próprio à rotina.

Rotina para que se adicione a rotina de destruição para um tipo:
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o tipo não deveria ser ignorado, retorne.
  Se o tipo puder ser reduzido para "listas",
    Adicione a rotina de destruição para o tipo (listas);
    Retorne.
  Se o tipo puder ser reduzido para "ponteiro",
    Adicione a rotina de destruição para o tipo (ponteiros);
    Retorne.

Função para que se determine se um tipo deveria ser ignorado:
  [ou seja, determina se o compilador deveria gerar automaticamente uma rotina de finalização para o tipo]
  \ Página 93
  Se o tipo for inexistente, diga não.
  Se o nome deste tipo for "lista", diga não.
  \ Não, porque este é um tipo primitivo que não é nem alocado nem destruído,
  \ Ele simplesmente existe, assim podemos adicionar os campos "próximo" e anterior" para os tipos derivados dele
  Se o nome deste tipo for "listas", diga não.
  \ Não, porque este é um tipo primitivo usado para ancorar listas de listas, o mesmo do de cima
  Se o tipo puder ser reduzido para "listas", diga sim.
  \ Sim, porque embora pareça ser contraditório, esta é uma instância do tipo, por exemplo "umas páginas"
  Se o tipo não puder ser reduzido para "ponteiro", diga não.
  \ Não porque porque ponteiros são variáveis estáticas (somente o endereço na variável que muda)
  \ O ponteiro em si não é algo que pode ser alocado dinamicamente então não precisa ser desalocado
  Se o tipo do conteúdo deste tipo for inexistente, diga não.
  \ Não porque é um ponteiro nulo, não há nada para desalocar
  Se o tipo do conteúdo deste tipo não puder ser reduzido para "ponteiro", diga sim.
  \ Sim, porque é um ponteiro para algo que foi alocado, e que não é um ponteiro.
  Se o tipo do conteúdo deste tipo não deveria ser ignorado, diga não. \ RECURSÃO
  \ Não, porque é um ponteiro para algo que não deveria ser desalocado, por exemplo um ponteiro para uma lista
  Diga sim.\ Esta linha é para os demais casos, e para a linha recursiva acima.

Rotina para que se adicione a rotina de destruição para um tipo (listas):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o primeiro campo destes campos deste tipo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #074. O identificador '" junto com o nome deste primeiro campo destes campos deste tipo 
      seguido de "' não é um campo válido nesta lista. Verifique se o campo foi corretamente definido anteriormente."
      junto com o texto CRLF;
    Retorne. \
  Se o tipo deste primeiro campo destes campos deste tipo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #075. O identificador '" junto com o nome deste tipo deste primeiro campo destes campos deste tipo 
      seguido de "' não é um tipo válido para esta variável. Verifique se o campo foi corretamente definido anteriormente."
      junto com o texto CRLF;
    Retorne.
  Atribua "Destrua [" junto com o nome deste tipo 
    seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o primeiro " junto com o nome deste tipo deste primeiro campo destes campos deste tipo
    junto com " de este " junto com o nome deste tipo 
    seguido de " for inexistente, retorne. " para a string do corpo desta rotina. \ listas duplamente encadeadas
  Atribua o nome deste tipo deste primeiro campo destes campos deste tipo para um nome.
  Acrescente "Atribua o primeiro " junto com o nome 
    junto com " de este "junto com o nome deste tipo 
    seguido de " para um " junto com o nome 
    seguido de ". " para a string do corpo desta rotina.\ traduzir
  Acrescente "Remova o " junto com o nome 
    seguido de " desde o " junto com o nome deste tipo 
    seguido de ". " para a string do corpo desta rotina.
  Acrescente "Destrua o " junto com o nome 
    seguido de ". " para a string do corpo desta rotina.
  Acrescente "Reitere. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho próprio à rotina.

Rotina para que se apresente uma mensagem de erro contendo uma string:
  Se existir algum problema de compilação,
    Retorne.
  Ative o sinalizador de erros deste compilador.
  Atribua esta string à mensagem de erro deste compilador.

Rotina para que se adicione a rotina de destruição para um tipo (ponteiros):
  Se o tipo for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Atribua "Destrua [" junto com o nome deste tipo 
    seguido de "]" para uma representação interna da rotina.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Adicione uma rotina para as rotinas usando nil.
  Acrescente "Destrua um " junto com o nome deste tipo para a string do cabeçalho desta rotina.
  Acrescente "Se o " junto com o nome deste tipo 
    seguido de " for inexistente, retorne. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "ponteiro",
    Acrescente "Destrua o conteúdo de este " junto com o nome deste tipo 
      seguido de "'. " para a string do corpo desta rotina.
  Se o tipo do conteúdo deste tipo puder ser reduzido para "listas",
    Acrescente "Destrua o conteúdo de este " junto com o nome deste tipo 
      seguido de "'. " para a string do corpo desta rotina.
  Itere.
    Obtenha um campo desde os campos deste tipo do conteúdo deste tipo.
    Se o campo for inexistente, pare.
    Se o sinalizador de referência deste campo estiver ativo, reitere.
    Se o tipo deste campo não deveria ser ignorado, reitere.
    Acrescente "Destrua o " junto com o nome deste campo 
      seguido de " de este " junto com o nome deste tipo 
      seguido de ". " para a string do corpo desta rotina.
  Reitere.
  Acrescente "Desaloque o " junto com o nome deste tipo 
    seguido de ". " para a string do corpo desta rotina. \ traduzir aqui
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho próprio à rotina.

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (catalogue as rotinas por utilização): \ #009
  Se existir algum problema de compilação, retorne.
  Escreva "Catalogando tarefas..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de ferramentas de catalogação.
  Catalogue as rotinas por utilização.
  Scrub o catálogo de rotinas úteis. \ higienizar? purificar? sanear?
  Organize o catálogo de rotinas úteis.
  Suspenda o temporizador de ferramentas de catalogação.

Rotina para que se catalogue umas rotinas por utilização:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Catalogue a rotina por utilização.
  Reitere.

Rotina para que se catalogue uma rotina por utilização:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o sinalizador de função desta rotina estiver ativo, retorne.
  Se a contagem destes parâmetros desta rotina for 0, retorne.
  Copie as unidades semânticas desta rotina para umas unidades semânticas.
  Reduza as unidades semânticas por utilização.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a representação interna da rotina estiver no catálogo geral de rotinas, retorne.
  Encontre uma referência usando a representação interna da rotina e o catálogo de rotinas úteis.
  Se a referência não for inexistente,
    Atribua nulo ao ponteiro deste referência;
    Retorne.
  Catalogue a rotina usando a representação interna da rotina e o catálogo de rotinas úteis.

Rotina para que se copie umas unidades semânticas para umas outras unidades semânticas:
  Destrua as outras unidades semânticas.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Copie a unidade semântica para uma nova unidade semântica.
    Acrescente a nova unidade semântica para as outras unidades semânticas.
  Reitere.

Rotina para que se copie uma unidade semântica para uma segunda unidade semântica:
  \ Obs: esta rotina não copia as substrings
  Se a unidade semântica for inexistente,
    Esvazie a segunda unidade semântica;
    Retorne.
  Aloque memória para o segunda unidade semântica.
  Atribua a string desta unidade semântica à string desta segunda unidade semântica.
  Atribua o tipo desta unidade semântica ao tipo desta segunda unidade semântica.
  Atribua a variável desta unidade semântica à variável desta segunda unidade semântica.
  Atribua o tipo atual desta unidade semântica ao tipo atual desta segunda unidade semântica.

Rotina para que se organize o catálogo de rotinas úteis:
  \Itere.
  Se existir algum problema de compilação, retorne.
    Obtenha um recipiente usando o catálogo de rotinas úteis.
    Se o recipiente for inexistente, retorne.
    Se as referências deste recipiente estiverem vazios, reitere.
    Organize o catálogo de rotinas úteis usando as referências deste recipiente.
  Reitere.

Rotina para que se organize o catálogo de rotinas úteis usando umas referências:
  \Itere.
  Obtenha uma referência desde as referências.
    Se a referência for inexistente, retorne.
    Atribua o ponteiro desta referência para uma rotina.
    Se a rotina for inexistente,
      Apresente uma mensagem de erro contendo
        "Código de Erro #076. A rotina não foi localizada no catálogo geral de rotinas"
        junto com o texto CRLF; \ Erro interno
      Retorne.
    Copie as unidades semânticas desta rotina para umas unidades semânticas.
    Reduza as unidades semânticas por utilização.
    Catalogue a rotina usando as unidades semânticas e o catálogo geral de rotinas.
    Destrua as unidades semânticas.
  Reitere.

Rotina para que se reduza umas unidades semânticas por utilização:
  \Itere.
    Obtenha uma unidade semântica desde as unidades semânticas.
    Se a unidade semântica for inexistente, retorne.
    Se o tipo desta unidade semântica for inexistente, reitere.
    Reduza o tipo desta unidade semântica para um tipo por utilização.
    Se o tipo não for inexistente,
      Atribua o tipo ao tipo desta unidade semântica.
  Reitere.

Rotina para que se reduza um tipo para um segundo tipo por utilização:
  Atribua o tipo ao segundo tipo.
  Itere.
    Se o segundo tipo for inexistente, retorne.
    Se o nome deste segundo tipo for "texto hexadecimal", retorne.
    Se o nome deste segundo tipo for "string", retorne.
    Se o nome deste segundo tipo for "número", retorne.
    Se o nome deste segundo tipo for "ponteiro", retorne.
    Se o nome deste segundo tipo for "lista",
      Esvazie o segundo tipo;
      Retorne.
    \PAL
    Se o tipo base deste segundo tipo for o segundo tipo,
      Esvazie o segundo tipo;
      Retorne.
    Atribua o tipo base deste segundo tipo ao segundo tipo.
  Reitere.

Rotina para que se encontre uma referência usando uma string e um catálogo:
  Se o catálogo for inexistente, retorne.
  Se a string estiver em branco,
    Esvazie a referência;
    Retorne.
  Obtenha um recipiente usando a string e o catálogo.
  Encontre a referência usando a string e as referências deste recipiente.


Rotina para que se encontre uma referência usando uma string e umas referências:
  Esvazie a referência.
  Itere.
    Obtenha a referência desde as referências.
    Se a referência for inexistente, retorne.
    Se a string for a string deste referência, retorne.
  Reitere.

Rotina para que se scrub um catálogo:
  Itere.
    Obtenha um recipiente usando o catálogo.
    Se o recipiente for inexistente,
      Retorne.
    Se as referências deste recipiente estiverem vazios,
      Reitere.
    Scrub as referências deste recipiente.
  Reitere.

Rotina para que se scrub umas referências:
  Permute as referências com uns segunda referências.
  Itere.
    Atribua a primeira referência destes segunda referências para uma referência.
    Se a referência for inexistente,
      Retorne.
    Remova a referência desde a segunda referências.
    Se o ponteiro deste referência for inexistente,
      Destrua a referência;
      Reitere.
    Acrescente a referência para as referências.
  Reitere.

\------------------------------------------------------------------------------------------------------------------------------------



Rotina para que se compile um endereço da pasta (conteúdo das rotinas): \ #010
  Se existir algum problema de compilação, retorne.
  Escreva "Agrupando o conteúdo das rotinas..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de compilação do conteúdo das rotinas.
  Compile os corpos referentes às rotinas.
  Suspenda o temporizador de compilação do conteúdo das rotinas.

Rotina para que se compile os corpos referentes para as rotinas:
  Compile o corpo relacionado com a rotina denominada "Inicialize antes da execução".
  Compile o corpo relacionado com a rotina denominada "Execute o programa".
  Compile o corpo relacionado com a rotina denominada "Finalize após execução".

Rotina para que se compile o corpo relacionado com a rotina denominada uma string:
  Se existir algum problema de compilação, retorne.
  Encontre uma rotina usando a string e o catálogo geral de rotinas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #077. A rotina 'para que se " junto com a string 
      seguido de "' não foi encontrada no catálogo geral de rotinas" junto com o texto CRLF;
    Retorne.
  Compile o corpo relacionado com a rotina.

Rotina para que se compile o corpo relacionado com uma rotina:
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Se o sinalizador de compilação desta rotina estiver ativo, retorne.
  Ative o sinalizador de compilação desta rotina.
  Lance um percorredor sobre as instruções desta rotina.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for o ponto&vírgula,
    Compile o corpo relacionado com a rotina usando o percorredor (sobrecarga de métodos);
    Retorne. \ *** alternate wording
  \Se o segmento inicial deste percorredor for uma palavra-chave de reutilização de rotina,
    \compile o corpo relacionado com a rotina usando o percorredor (cláusula de reutilização);
    \Retorne.
  Atribua a rotina utilizada atualmente para um rotina denominada rotina armazenada.
  Atribua a rotina à rotina utilizada atualmente.
  Crie o catálogo de apelidos desta rotina usando 101. [buckets]
  Elimine apelidos duplicados desde os parâmetros desta rotina usando o catálogo de apelidos desta rotina.
  Compile o corpo relacionado com a rotina (etapa preliminar).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, pare.
    Compile a próxima instrução usando o percorredor.
  Reitere.
  Compile o corpo relacionado com a rotina (etapa conclusiva).
  Atribua a rotina armazenada à rotina utilizada atualmente.
  \Destrua o catálogo de apelidos desta rotina.

Rotina para que se compile o corpo relacionado com uma rotina usando um percorredor (sobrecarga de métodos):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ *** do we need this? I think so
  Atribua a próxima rotina desta rotina para um rotina alvo.
  Se a rotina alvo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #078. Não foi possível encontrar o cabeçalho alternativo desta rotina." junto com o texto CRLF e o percorredor;
    Retorne.
  Atribua a representação interna da rotina deste rotina alvo ao representação de emprego desta rotina.
  Compile o corpo relacionado com a rotina alvo.

Rotina para que se compile o corpo relacionado com uma rotina (etapa preliminar):
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando a etiqueta preliminar.
  Adicione um segundo fragmento usando a etiqueta de laço.

Rotina para que se adicione um fragmento usando uma etiqueta:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.

Rotina para que se crie um fragmento usando uma etiqueta:
  Aloque memória para o fragmento.
  Atribua a etiqueta à etiqueta deste fragmento.

Rotina para que se compile a próxima instrução usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for algum comando condicional,
    Compile a próxima instrução usando o percorredor (cláusula de condicional);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento,
    Compile a próxima instrução usando o percorredor (cláusula de inicio de laço);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção,
    Compile a próxima instrução usando o percorredor (cláusula de isolamento);
    Retorne.
  Se o segmento inicial deste percorredor não for o início de alguma declaração,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #079. Esperado invocação de rotina. Encontrado: " 
    junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Compile a próxima instrução usando o percorredor (demais cláusulas).
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #080. Invocação de rotina inexistente (ou uso de palavra-chave reservada)." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de condicional):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile umas unidades semânticas usando o percorredor.
  Remova alguns termos negativos desde as unidades semânticas retornando um sinalizador.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente,
    Adicione push fragmentos usando as unidades semânticas.
  Se a rotina for inexistente,
    Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #081. A rotina 'para que se determine se "
      junto com a representação interna da rotina 
      seguido de "' não existe." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o sinalizador de deliberação desta rotina não estiver ativo,
    Apresente a mensagem de erro contendo 
      "Código de Erro #082. Necessário utilizar um decisor." junto com o texto CRLF e o percorredor;
      Retorne.
  \ Se o segmento inicial deste percorredor não for a vírgula,
    \apresente a mensagem de erro contendo 
      \"Acho que você esqueceu de uma vírgula, eu achei isso aqui: " 
      \junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
      \Retorne.
  Se o segmento inicial deste percorredor não for qualquer separador de comandos,
    Apresente a mensagem de erro contendo 
      "Código de Erro #083. Necessário incluir uma vírgula ao invés de: '"
      junto com o segmento inicial deste percorredor 
      seguido de "'." junto com o texto CRLF e o percorredor;
      Retorne.
  Adicione um fragmento usando a etiqueta de demanda interna e a rotina.
  Se o sinalizador estiver ativo,
    Adicione um segundo fragmento usando a etiqueta de negação lógica.
  Adicione um terceiro fragmento usando a etiqueta de desvio falso.
  Mova o percorredor (usando diretrizes de compilação).
  Itere.
    Compile a próxima instrução usando o percorredor (demais cláusulas). \ retorno
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor for o ponto&vírgula,
      Mova o percorredor (usando diretrizes de compilação);
      Reitere.
    Se o segmento inicial deste percorredor não for o ponto final,
      Apresente a mensagem de erro contendo 
        "Código de Erro #084. Necessário incluir um '.' ou ';' ao invés de: " 
        junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione um quarto fragmento usando a etiqueta delimitadora de bloco condicional.

Rotina para que se compile umas unidades semânticas usando um percorredor:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Se o percorredor estiver sobre alguma string de unidade semântica,
      Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor;
      Mova o percorredor (usando diretrizes de compilação);
      Reitere.
    Se o segmento inicial deste percorredor não for o início de alguma expressão matemática,
      Retorne.
    Compile uma expressão matemática usando o percorredor.
    Se existir algum problema de compilação,
      Retorne.
    Adicione uma segunda unidade semântica para as unidades semânticas usando a expressão matemática.
  Reitere.

\Rotina para que se compile umas unidades semânticas usando um percorredor:
  \[Itere.]
  \Se existir algum problema de compilação, retorne.
    \Se o segmento inicial deste percorredor for alguma string de unidade semântica,
      \Adicione uma unidade semântica para as unidades semânticas usando o segmento inicial deste percorredor; mova o percorredor (usando diretrizes de compilação); Reitere.
    \Se o segmento inicial deste percorredor não for o início de alguma expressão matemática, retorne.
    \Compile uma expressão matemática usando o percorredor.
    \Se existir algum problema de compilação, retorne.
    \Adicione uma segunda unidade semântica para as unidades semânticas usando o expressão matemática.
  \Reitere.

Rotina para que se compile uma expressão matemática usando um percorredor:
  Se existir algum problema de compilação, retorne.
  Compile um termo usando o percorredor.
  Atribua o termo para a expressão matemática.
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for algum operador aritmético, retorne.
    Se o segmento inicial deste percorredor for algum operador de divisão,
      Compile a expressão matemática usando o percorredor (operador de divisão);
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de subtração,
      Compile a expressão matemática usando o percorredor (operador de subtração);
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de adição,
      Compile a expressão matemática usando o percorredor (operador de adição);
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de concatenação,
      Compile a expressão matemática usando o percorredor (operador de concatenação);
      Reitere.
    Se o segmento inicial deste percorredor for algum operador de multiplicação,
      Compile a expressão matemática usando o percorredor (operador de multiplicação);
      Reitere.
    Se o segmento inicial deste percorredor for "junto",
      Compile a expressão matemática usando o percorredor (operador de concatenação);
      Reitere.
    Se o segmento inicial deste percorredor for "juntamente",
      Compile a expressão matemática usando o percorredor (operador de concatenação);
      Reitere.
    Se o segmento inicial deste percorredor for "seguido",
      Compile a expressão matemática usando o percorredor (operador de concatenação);
      Reitere.
    Se o segmento inicial deste percorredor for "acompanhado",
      Compile a expressão matemática usando o percorredor (operador de concatenação);
      Reitere.

O número de comparação é um número igual a 0.

Rotina para que se compile um termo usando um percorredor:
  Limpe o termo.
  Se existir algum problema de compilação, retorne.
  Compile o termo usando o percorredor (análise preliminar).
  Se o percorredor estiver sobre alguma conjunção modificadora, retorne.
  \ A linha acima foi adicionada por causa do projeto de desenhar caracteres usando gráficos de tartaruga (grade invisível) ***
    Se o segmento inicial deste percorredor for "tal",
      Mova o percorredor (usando diretrizes de compilação);
      Compile o termo usando o percorredor (cláusula comparativa).
  Se o segmento inicial deste percorredor for "/",
    Compile o termo usando o percorredor (proporção de execução).

Rotina para que se limpe um termo:
  Esvazie a variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (análise preliminar):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor for o sinal de subtração,
    Compile o termo usando o percorredor (subtração de termo);
    Retorne.
  Se o segmento inicial deste percorredor for o sinal de adição,
    Compile o termo usando o percorredor (adição de termo);
    Retorne.
  Se o segmento inicial deste percorredor for o início de alguma variável,
    Compile o termo usando o percorredor (variável);
    Retorne.
  Se o segmento inicial deste percorredor for o início de alguma variável local,
    Compile o termo usando o percorredor (nova variável local);
    Retorne.
  Se o segmento inicial deste percorredor for algum valor literal,
    Compile o termo usando o percorredor (valor literal);
    Retorne.
  Apresente uma mensagem de erro contendo 
    "Código de Erro #085. O Compilador esperava encontrar um termo. Encontrado: '"
    junto com o segmento inicial deste percorredor seguido de "'." 
    junto com o texto CRLF e o percorredor.

Rotina para que se compile um termo usando um percorredor (subtração de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um novo termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste novo termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #086. Comando 'inverta' inválido. A variável: "
      junto com o frase deste novo termo seguido de "' não foi encontrada." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando 
    o nome do tipo deste novo termo e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Atribua" e 
    a variável deste novo termo e 
    "para" e 
    a variável intermediária e 
    o endereço local deste novo termo.
  Adicione dois fragmentos usando 
    "Inverta o sinal de" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se adicione uma variável intermediária usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie a variável intermediária;
    Retorne.
  Adicione a variável intermediária para 
    as variáveis locais desta rotina utilizada atualmente usando "variável local" e o endereço local.
  Gere o nome desta variável intermediária usando "~I".
  Atribua o nome do tipo ao nome do tipo desta variável intermediária.
  Destrinche a variável intermediária.

Rotina para que se adicione fragmentos diversos usando 
                  uma string e 
                  uma variável e 
                  uma segunda string e 
                  uma segunda variável e 
                  um endereço local:
  Adicione um fragmento usando 
    a etiqueta de inserção de endereço [na stack] e 
    a segunda variável.
  Adicione um segundo fragmento usando 
    a etiqueta de inserção de endereço [na stack] e 
    a variável.
  Adicione uma unidade semântica para 
    umas unidades semânticas 
    usando a string.
  Adicione uma segunda unidade semântica 
    para as unidades semânticas 
    usando o tipo desta variável.
  Adicione uma terceira unidade semântica 
    para as unidades semânticas 
    usando a segunda string.
  Adicione uma quarta unidade semântica 
    para as unidades semânticas 
    usando o tipo desta segunda variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente,
    Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #087. A rotina 'para que se " junto com a representação interna da rotina 
      seguido de "' não foi encontrada." e o endereço local;
    Retorne.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.

Rotina para que se adicione um fragmento usando uma etiqueta e uma variável:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Ative o sinalizador de compilação na variável.

Rotina para que se ative o sinalizador de compilação em uma variável;
Rotina para que se ligue o sinalizador de compilação em uma variável:
  Se a variável for inexistente, retorne.
  Se o sinalizador de compilação desta variável estiver ativo, retorne.
  Ative o sinalizador de compilação desta variável.
  Se a categoria desta variável não for "variável global", retorne.
  Se o valor literal desta variável for inexistente, retorne.
  Encontre uma rotina usando 
    "atribua" e 
    o tipo deste valor literal desta variável e 
    "para" e 
    o tipo desta variável.
  Se a rotina for inexistente,
    Encontre a rotina usando 
      "converta" e 
      o tipo deste valor literal desta variável e 
      "para" e 
      o tipo desta variável;
    Ative um sinalizador.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #088. O tipo e o valor da variável variável global  não estão correspondendo." e 
      o endereço local desta variável;
    Retorne.
  Compile o corpo relacionado com a rotina.
  Se o sinalizador estiver ativo,
    Atribua "converta o " junto com o nome deste valor literal desta variável 
      seguido de " para o " junto com o nome desta variável 
      seguido de ". " ao texto inicializador desta variável.
  Se o sinalizador não estiver ativo,
    Atribua "atribua o " junto com o nome deste valor literal desta variável 
      seguido de " para o " junto com o nome desta variável 
      seguido de ". " ao texto inicializador desta variável.

Rotina para que se encontre uma rotina usando uma string e um tipo e uma segunda string e um segundo tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o segundo tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Rotina para que se encontre uma rotina usando umas unidades semânticas:
  Esvazie a rotina.
  Encontre a rotina usando uma representação interna da rotina e 
    a primeira unidade semântica destas unidades semânticas e 
    o catálogo geral de rotinas.

Rotina para que se encontre uma rotina usando uma representação interna da rotina e uma unidade semântica e um catálogo:
  Se a unidade semântica for inexistente, retorne.
  Esvazie a rotina.
  Preserve a representação interna da rotina.
  Atribua o tipo desta unidade semântica ao tipo atual desta unidade semântica.
  Lance o subtexto atual desta unidade semântica sobre a string desta unidade semântica.
  Itere.
    Acrescente a unidade semântica para a representação interna da rotina (inserção de colchetes).
    Encontre uma referência usando a representação interna da rotina e o catálogo.
    Se a referência não for inexistente,
      Atribua o ponteiro deste referência à rotina.
    Se a referência não for inexistente,
      Encontre a rotina usando 
        a representação interna da rotina e 
        a próxima unidade semântica desta unidade semântica e 
        o catálogo.
    Se a rotina não for inexistente, pare.
    Defina o tipo dessa unidade semântica.
    Se a unidade semântica estiver indefinida, pare.
    Atribua a representação interna da rotina original para a representação interna da rotina.
  Reitere.

Rotina para que se acrescente uma unidade semântica para uma representação interna da rotina (inserção de colchetes):
  Se a unidade semântica for inexistente, retorne.
  Se a representação interna da rotina não estiver em branco,
    Acrescente o caractere de espaço para a representação interna da rotina.
  Se o subtexto atual desta unidade semântica não estiver em branco,
    Acrescente o subtexto atual desta unidade semântica para a representação interna da rotina ;
    Retorne.
  Se o tipo atual desta unidade semântica não for inexistente,
    Acrescente "[" e o nome deste tipo atual desta unidade semântica e "]" para a representação interna da rotina (rapidamente);
    Retorne.

Rotina para que se defina o tipo de uma unidade semântica:
  Se a unidade semântica for inexistente, retorne.
  Se o subtexto atual desta unidade semântica não estiver em branco,
    Limpe o subtexto atual desta unidade semântica;
    Retorne.
  Se o tipo atual desta unidade semântica for inexistente, retorne.
  Se o tipo atual desta unidade semântica for algum tipo pré-definido,
    Atribua inexistente ao tipo atual desta unidade semântica;
    Retorne.
  Atribua o tipo base deste tipo atual desta unidade semântica ao tipo atual desta unidade semântica.

Função para que se determine se um tipo é algum tipo pré-definido:
  Se o tipo for inexistente, diga não.
  Se o tipo for o tipo base deste tipo, diga sim.
  Diga não.

Função para que se determine se uma unidade semântica está indefinida:
  Se a unidade semântica for inexistente, diga sim.
  \Se a unidade semântica não for inexistente, diga não.\
  Se o tipo atual desta unidade semântica não for inexistente, diga não.
  \Se o tipo atual desta unidade semântica for inexistente, diga sim.
  Se o subtexto atual desta unidade semântica não estiver em branco, diga não.
  \Se o subtexto atual desta unidade semântica estiver em branco, diga sim.
  Diga sim.

Rotina para que se adicione um fragmento usando uma etiqueta e uma rotina:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a rotina à rotina deste fragmento.
  Compile o corpo relacionado com a rotina.

Rotina para que se adicione dois fragmentos usando uma string e uma variável e um endereço local:
  Adicione um fragmento usando a etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente,
    Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #089. A rotina 'para que se " junto com a representação interna da rotina 
      seguido de "' ainda não foi definida." e o endereço local;
    Retorne.
  Adicione um segundo fragmento usando a etiqueta de demanda interna e a rotina.

Rotina para que se compile um termo usando um percorredor (adição de termo):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #090. Comando '+' incorreto. A variável do termo '" junto com a frase deste termo 
      seguido de "' não foi localizada." junto com o texto CRLF e o percorredor;
    Retorne.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (variável):
  Se existir algum problema de compilação, retorne.
  Se a rotina utilizada atualmente for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #091. Esta rotina é inexistente." junto com 
      "Não sei o que você está tentando fazer aqui." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso,
    Compile o termo usando o percorredor e o nome (possessivo reverso);
    Retorne.
  Encontre uma variável usando o nome.
  Atribua a variável à variável deste termo.
  Atribua "o " à frase deste termo.
  Acrescente o nome para a frase deste termo.
  Compile o termo usando o percorredor (possessivos).

Rotina para que se compile um termo usando um percorredor e um nome denominado nome do campo(possessivo reverso):
  \ Rotina recursiva criada pelo Dahn para o SAL
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação). \ após o indicador do possessivo reverso ("de")
  Se o segmento inicial deste percorredor não for algum artigo,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #092. O compilador esperava encontrar um artigo após o 'de'. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'."
      junto com o texto CRLF e o percorredor;
    Retorne.
  Atribua o segmento inicial deste percorredor para um segmento inicial denominado pronome.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um novo nome usando o percorredor.
  Se o percorredor estiver sobre algum possessivo reverso,
    Ative um sinalizador de possessivo reverso.
  Se o sinalizador de possessivo reverso estiver ativo,
    Compile o termo usando o percorredor e o novo nome (possessivo reverso). \ RECURSÃO
  Se o sinalizador de possessivo reverso não estiver ativo,
    Compile o termo usando o percorredor e o novo nome e o pronome (reversão de contrações do possessivo).
  Compile o termo usando o nome do campo e o percorredor (possessivo reverso).
  \ Retorne.

Rotina para que se compile um termo usando um percorredor e um nome denominado nome do campo e um segmento inicial denominado pronome (reversão de contrações do possessivo):
  \ Rotina nova criada pelo Dahn para o SAL
  Se o pronome for o início de alguma variável,
    Compile o termo usando o percorredor e o nome do campo e o pronome (reversão de contrações de variáveis do possessivo);
    Retorne.
  Compile o termo usando o percorredor e o nome do campo (decomposição do possessivo reverso - variável local).

Rotina para que se compile um termo usando um percorredor e um nome denominado nome da estrutura e um segmento inicial (reversão de contrações de variáveis do possessivo):
  \ Rotina nova criada pelo Dahn para o SAL
  Encontre uma variável usando o nome da estrutura.
  Se a variável for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #093. Não foi possível encontrar a estrutura: " 
      junto com o nome da estrutura seguido de "."
      junto com o texto CRLF e o percorredor.
  Atribua a variável à variável deste termo.
  Atribua "O " à frase deste termo.
  Acrescente o nome da estrutura para a frase deste termo.

Rotina para que se compile um termo usando um percorredor e uma variável nome (decomposição do possessivo reverso - variável local):
  \ Rotina nova criada pelo Dahn para version 2
  Se existir algum problema de compilação, retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "variável local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Expanda o nome desta variável local com a variável nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação,
    Compile a parte designadora usando o percorredor e a variável local.
  Destrinche a variável local.
  Se a variável local estiver duplicada em os parâmetros desta rotina utilizada atualmente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #094. O termo: "junto com o nome desta variável local 
      seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local;
    Retorne.
  Se a variável local estiver duplicada em as variáveis locais desta rotina utilizada atualmente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #095. O termo: " junto com o nome desta variável local seguido de 
      "' já está sendo usado coma variável local." e o endereço local desta variável local;
    Retorne.
  Elimine apelidos duplicados usando a variável local e o catálogo de apelidos desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a frase deste termo.

Função para que se determine se uma string é o início de alguma variável:
  Se a string for algum artigo definido, diga sim.
  \Se a string for "do", diga sim. \ para reverse-possessives
  \Se a string for "cada", diga sim.
  Diga não.

Rotina para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
  \ similar para "compile um termo usando um percorredor (possessivo)" \ Rotina nova criada pelo Dahn para
  Se existir algum problema de compilação, retorne.
  Se o campo nome for alguma palavra-chave de obtenção de tamanho de variável,
    Compile o termo usando o percorredor (possessivo - magnitude);
    Retorne.
  Se o campo nome for algum conteúdo,
    Compile o termo usando o percorredor (possessivo - conteúdo);
    Retorne.
  Se o campo nome for algum endereçamento,
    Compile o termo usando o percorredor (possessivo - endereçamento);
    Retorne.
  Compile o termo usando o percorredor e o campo nome (possessivo - campo).

Rotina para que se encontre uma variável usando um nome:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie a variável;
    Retorne.
  Encontre a variável usando o nome e as variáveis locais desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e os parâmetros desta rotina utilizada atualmente.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis globais.
  Se a variável não for inexistente, retorne.
  Encontre a variável usando o nome e o catálogo de variáveis hexadecimais.

Função para que se determine se uma string é o início de alguma variável local:
  Se a string for algum artigo indefinido, diga sim.
  Diga não.

Rotina para que se compile um termo usando um percorredor (nova variável local):
  Se existir algum problema de compilação, retorne.
  Se a rotina utilizada atualmente for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #096. Rotina não localizada. Não foi possível desempilhar o item da stack." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando 
    "variável local" e o caractere inicial deste segmento inicial deste percorredor.
  \PAL
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Expanda o nome desta variável local com o nome.
  Se o segmento inicial deste percorredor for uma palavra-chave de designação,
    Compile a parte designadora usando o percorredor e a variável local.
  Destrinche a variável local.
  Se a variável local estiver duplicada nos parâmetros desta rotina utilizada atualmente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #097. O parâmetro: " junto com o nome desta variável local 
      seguido de "' já está sendo usado como parâmetro." e o endereço local desta variável local;
    Retorne.
  Se a variável local estiver duplicada nas variáveis locais desta rotina utilizada atualmente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #098. A variável local " junto com o nome desta variável local 
      seguido de "' já foi declarada nesta rotina. Utilize um nome de variável diferente." 
      e o endereço local desta variável local;
    Retorne.
  Elimine apelidos duplicados usando a variável local e o catálogo de apelidos desta rotina utilizada atualmente.
  Atribua a variável local à variável deste termo.
  Limpe a frase deste termo.
  Compile o termo usando o percorredor (possessivos).

Rotina para que se compile um termo usando um percorredor (valor literal):
  Se existir algum problema de compilação, retorne.
  Compile um valor literal usando o percorredor.
  Atribua o valor literal à variável deste termo.
  Limpe o frase deste termo.
  Compile o termo usando o percorredor (possessivos).

Rotina para que se compile um termo usando um percorredor (possessivos):
  \Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor não for algum possessivo inglês, retorne.
    Compile o termo usando o percorredor (possessivo).
  Reitere.

Rotina para que se compile um termo usando um percorredor (possessivo):
  \ Rotina similar a "compile um termo usando um percorredor (possessivo reverso)
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se o nome for alguma palavra-chave de obtenção de tamanho de variável,
    Compile o termo usando o percorredor (possessivo - magnitude);
    Retorne.
  Se o nome for algum conteúdo,
    Compile o termo usando o percorredor (possessivo - conteúdo);
    Retorne.
  Se o nome for algum endereçamento,
    Compile o termo usando o percorredor (possessivo - endereçamento);
    Retorne.
  Compile o termo usando o percorredor e o nome (possessivo - campo).

Rotina para que se compile um termo usando um percorredor (possessivo - magnitude):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #099. Comando magnitude inválido. A variável: " 
      junto com a frase deste termo seguido de "'não foi localizada." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um valor literal para os valores literais usando o caractere inicial deste segmento inicial deste percorredor.
  Converta a quantidade de caracteres deste tipo deste termo para os data deste valor literal.
  Atribua "número" ao nome do tipo deste valor literal.
  Destrinche o valor literal.
  Atribua o valor literal à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (possessivo - conteúdo):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #100. Palavra-chave 'conteúdo' detectada, mas o termo '"
      junto com a frase deste termo seguido de "' não foi devidamente definido." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo deste termo não puder ser reduzido para "ponteiro",
    Apresente a mensagem de erro contendo 
      "Código de Erro #101. A palavra-chave 'conteúdo' só pode ser utilizada em ponteiros." junto com o texto CRLF e o percorredor;
    Retorne.
  Compile o termo usando o percorredor (cláusula de redirecionamento).

Rotina para que se compile um termo usando um percorredor (cláusula de redirecionamento):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #102. Cláusula redirecionamento inválida. O termo '"
      junto com a frase deste termo seguido de "' não foi encontrado." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo do conteúdo deste tipo deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #103. O identificador '"
      junto com a frase deste termo seguido de 
      "' refere-se a um ponteiro que não possui um tipo de dado definido." junto com o texto CRLF junto com
      "Certifique-se de que todos os ponteiros estejam associados a um tipo de dado válido antes de usá-los." junto com 
      "Verifique a linha que contém a implementação deste ponteiro e atribua um tipo de dado para o qual ele aponta." junto com o texto CRLF junto com
      "Um ponteiro deve apontar para um tipo específico, como um número. Exemplo: " junto com o texto CRLF junto com o texto CRLF 
      junto com a frase deste termo junto com  " é um ponteiro [que aponta] PARA um <tipo de dado>."
      junto com o texto CRLF  junto com o texto CRLF e o percorredor;
    Retorne.
  Se a categoria deste termo for "variável temporária de compilação",
    Compile o termo usando o percorredor (redirecionamentos de endereços - campos de estruturas);
    Retorne.
  Adicione uma variável temporária de compilação usando 
    o nome deste tipo do conteúdo deste tipo deste termo e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando 
    a etiqueta de carregamento de endereço e 
    a variável deste termo e 
    a variável temporária de compilação.
  Adicione um segundo fragmento usando a etiqueta de redirecionamento e a variável temporária de compilação.
  Atribua a variável temporária de compilação à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (redirecionamentos de endereços - campos de estruturas):
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #104. O termo '" junto com a frase deste termo \ ALTERAÇÃO - TESTAR
      seguido de "' não foi encontrado na estrutura." junto com o texto CRLF e o percorredor;
    Retorne.
  Atribua o nome deste tipo do conteúdo deste tipo deste termo ao nome do tipo deste termo.
  Atribua o tipo do conteúdo deste tipo deste termo ao tipo deste termo.
  Adicione um fragmento usando a etiqueta de redirecionamento e a variável deste termo.
  Limpe a frase deste termo.


Rotina para que se compile um termo usando um percorredor (possessivo - endereçamento):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #105. palavra-chave 'endereçamento' detectada, mas a variável do termo: " 
      junto com a frase deste termo seguido de " não foi localizada." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando "ponteiro" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando a etiqueta de carregamento de endereço e a variável deste termo e a variável intermediária.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se adicione uma variável temporária de compilação usando um nome do tipo e um endereço local:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie a variável temporária de compilação;
    Retorne.
  Adicione a variável temporária de compilação para as variáveis locais desta rotina utilizada atualmente usando "variável temporária de compilação" e o endereço local.
  Gere o nome deste variável temporária de compilação usando "~S".
  Atribua o nome do tipo ao nome do tipo deste variável temporária de compilação.
  Destrinche a variável temporária de compilação.

Rotina para que se adicione um fragmento usando uma etiqueta e uma variável e uma segunda variável:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua a segunda variável à segunda variável deste fragmento.
  Ative o sinalizador de compilação na variável.
  Ative o sinalizador de compilação na segunda variável.

Rotina para que se compile um termo usando um percorredor e um nome (possessivo - campo):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo não for inexistente,
    Atribua o tipo deste termo para um tipo.
  Encontre um campo de estrutura usando a frase deste termo e o tipo e o nome.
  Se o campo de estrutura não estiver vazio,
    Compile o termo usando o percorredor e o campo de estrutura;
    Retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #106. A variável do termo '" junto com a frase deste termo 
      seguido de "' não foi localizada." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo puder ser reduzido para "ponteiro",
    Atribua o tipo do conteúdo deste tipo ao tipo.
  Se o tipo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #107. O tipo: "junto com o nome 
      seguido de "' não foi localizada na estrutura: " 
      junto com o nome deste tipo deste termo 
      seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um campo desde os campos deste tipo.
    Se o campo for inexistente,
      Apresente a mensagem de erro contendo 
        "Código de Erro #108. O campo '" junto com o nome 
        seguido de "' não foi localizado na estrutura '"
        junto com o nome deste tipo deste termo 
        seguido de "'." junto com o texto CRLF e o percorredor;
      Retorne.
    Encontre um campo de estrutura-membro usando "" e o tipo deste campo e o nome.
    Se o campo de estrutura-membro estiver vazio,
      Reitere.
  Atribua o campo para o campo dum primeiro campo de estrutura.
  Se o tipo deste termo puder ser reduzido para "ponteiro",
    Ative o sinalizador de redirecionamento deste primeiro campo de estrutura.
  Compile o termo usando o percorredor e o primeiro campo de estrutura.
  Compile o termo usando o percorredor e o campo de estrutura-membro.

Rotina para que se encontre um campo de estrutura usando uma frase e um tipo e um nome:
  Limpe o campo de estrutura.
  Encontre o campo de estrutura usando o tipo e o nome.
  Se o campo deste campo de estrutura não for inexistente, retorne.
  Se a frase não estiver em branco,
    Encontre uma rotina usando "Atribua" e a frase e "'s " junto com o nome e "para". \ traduzir
  Se a rotina não for inexistente,
    Atribua a rotina à rotina de função deste campo de estrutura;
    Retorne.
  Se o tipo for inexistente, retorne.
  Encontre a rotina usando "Atribua" e o tipo e "'s " junto com o nome e "para".
  \ Lembrar de renomear o "Atribua" se for necessário
  Se a rotina não for inexistente,
    Ative o sinalizador de empilhamento deste campo de estrutura;
    Atribua a rotina à rotina de função deste campo de estrutura;
    Retorne.
  \ O código abaixo serve para continuar buscando os campos da estrutura quando um mebro é um ponteiro. Esta é uma funcionalidade controversa.
  \ Se o tipo do conteúdo deste tipo não for inexistente,
    \ Encontre a rotina usando "atribua" e o tipo do conteúdo deste tipo e "'s " junto com o nome e "para".
  \ Se a rotina não for inexistente,
    \ Ative o sinalizador de redirecionamento deste campo de estrutura;
    \ Atribua a rotina à rotina de função deste campo de estrutura;
    \ Retorne.

Rotina para que se limpe um campo de estrutura:
  Preencha bytes com o caractere null começando sob o endereçamento deste campo de estrutura pelo magnitude deste campo de estrutura.

Rotina para que se encontre um campo de estrutura usando um tipo e um nome:
  Se o tipo for inexistente, retorne.
  Encontre um campo usando o nome e os campos deste tipo.
  Se o campo não for inexistente,
    Atribua o campo ao campo deste campo de estrutura;
    Retorne.
  Se o tipo do conteúdo deste tipo não for inexistente,
    Encontre o campo usando o nome e os campos deste tipo do conteúdo deste tipo.
  Se o campo não for inexistente,
    Ative o sinalizador de redirecionamento deste campo de estrutura;
    Atribua o campo ao campo deste campo de estrutura;
    Retorne.
    
Rotina para que se encontre uma rotina usando uma string e uma segunda string e uma terceira string e uma quarta string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando a quarta string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.
  
Rotina para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando a terceira string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.
  
Função para que se determine se uma campo de estrutura está vazia;
Função para que se determine se umas campo de estrutura estão vazias;
Função para que se determine se uns campo de estrutura estão vazios;
Função para que se determine se um campo de estrutura está vazio:
  Se o campo deste campo de estrutura não for inexistente, diga não.
  Se a rotina de função deste campo de estrutura não for inexistente, diga não.
  Diga sim.

Rotina para que se compile um termo usando um percorredor e um campo de estrutura:
  Se existir algum problema de compilação, retorne.
  Se o sinalizador de redirecionamento deste campo de estrutura estiver ativo,
    Compile o termo usando o percorredor (cláusula de redirecionamento).
  Se a rotina de função deste campo de estrutura não for inexistente,
    Compile o termo usando o percorredor e o campo de estrutura (função);
    Retorne.
  Se a categoria deste termo for "variável temporária de compilação",
    Compile o termo usando o percorredor e 
    o campo de estrutura (campos de estruturas);
    Retorne.
  Atribua o campo deste campo de estrutura para um campo.
  Adicione uma variável temporária de compilação usando o nome deste tipo deste campo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando a etiqueta de carregamento de endereço e a variável deste termo e a variável temporária de compilação.
  Se o deslocamento deste campo não for 0,
    Adicione um terceiro fragmento usando a etiqueta de acréscimo e a variável temporária de compilação e o deslocamento deste campo.
  Atribua a variável temporária de compilação à variável deste termo.
  Limpe a frase deste termo.
  
Rotina para que se compile um termo usando um percorredor e um campo de estrutura (função):
  Se existir algum problema de compilação, retorne.
  Atribua a rotina de função deste campo de estrutura para uma rotina.
  Atribua o último parâmetro destes parâmetros desta rotina para um parâmetro.
  Se o parâmetro for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #109. Parâmetro inexistente. " junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo deste parâmetro for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #110. Tipo de parâmetro inexistente. " junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando o nome deste tipo deste parâmetro e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando a etiqueta de inserção de endereço [na stack] e a variável intermediária.
  Se o sinalizador de empilhamento deste campo de estrutura estiver ativo,
    Adicione um segundo fragmento usando a etiqueta de inserção de endereço [na stack] e a variável deste termo.
  Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.
  
Rotina para que se compile um termo usando um percorredor e um campo de estrutura (campos de estruturas):
  Se existir algum problema de compilação, retorne.
  Atribua o campo deste campo de estrutura para um campo.
  Atribua o nome deste tipo deste campo ao nome do tipo deste termo.
  Atribua o tipo deste campo ao tipo deste termo.
  Se o deslocamento deste campo não for 0,
    Adicione um terceiro fragmento usando a etiqueta de acréscimo e a variável deste termo e o deslocamento deste campo.
  Limpe a frase deste termo.

Rotina para que se adicione um fragmento usando uma etiqueta e uma variável e um número:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a variável à variável deste fragmento.
  Atribua o número ao número deste fragmento.
  Ative o sinalizador de compilação na variável.

Função para que se determine se um percorredor está sobre alguma conjunção modificadora:
  \ adicionado para as rotinas de frágico de tartatuga ***
  Preserve o percorredor.
  Se o segmento inicial deste percorredor for "like", diga sim.
  \Se o segmento inicial deste percorredor for "tal qual", diga sim.
  Se o segmento inicial deste percorredor não for "as", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido, diga não.
  Diga sim.

Rotina para que se compile um termo usando um percorredor (cláusula comparativa):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #111. Comando 'como' inválido. Variável: " 
      junto com a frase deste termo seguido de "' inexistente." junto com o texto CRLF e o percorredor;
    Retorne.
  \ TODO: Refatorar as linha acima que estão repetidas em outros 19 lugares.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo 
      "Código de Erro #112. Esperado Artigo indefinido após a palavra-chave 'como'. Encontrado: " 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome do tipo usando o percorredor.
  Encontre um tipo usando o nome do tipo e o catálogo de tipos.
  Se o tipo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #113. Tipo: '" junto com o nome do tipo 
      seguido de "' inválido." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável temporária de compilação usando o nome deste tipo e o caractere inicial deste segmento inicial deste percorredor.
  Adicione um fragmento usando a etiqueta de carregamento de endereço e a variável deste termo e a variável temporária de compilação.
  Atribua a variável temporária de compilação à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile um termo usando um percorredor (proporção de execução):
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #114. Operador '/' detectado, mas o numerador do termo: "
      junto com a frase deste termo seguido de " não foi localizada." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um segundo termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste segundo termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #115. Operador '/' detectado, mas o denominador do termo: "
      junto com o frase deste segundo termo seguido de "' não foi localizado." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando "proporção" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Atribua" e 
    a variável deste termo e 
    "e" e 
    a variável deste segundo termo e 
    "para" e 
    a variável intermediária e
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se adicione fragmentos diversos usando 
      uma string e 
      uma variável e 
      uma segunda string e 
      uma segunda variável e 
      uma terceira string e 
      uma terceira variável e 
      um endereço de byte :
  Adicione um fragmento usando a etiqueta de inserção de endereço [na stack] e o terceira variável.
  Adicione um segundo fragmento usando a etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um terceiro fragmento usando a etiqueta de inserção de endereço [na stack] e a variável.
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Adicione uma quinta unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma sexta unidade semântica para as unidades semânticas usando o tipo desta terceira variável.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina for inexistente,
    Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #116. A rotina para que se '" junto com a representação interna da rotina 
      seguido de "' não pôde ser localizada." e o endereço de byte;
    Retorne.
  Adicione um quarto fragmento usando a etiqueta de demanda interna e a rotina.

Rotina para que se atribua um termo para um segundo termo:
  Atribua a variável deste termo à variável deste segundo termo.
  Atribua a frase deste termo para a frase deste segundo termo.

Função para que se determine se uma string é algum operador de divisão:
  Se a string for "dividido", diga sim.
  Diga não.

Rotina para que se compile uma expressão matemática usando um percorredor (operador de divisão):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum objeto indireto,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #117. Você deve usar o termo 'dividido POR'." junto com o texto CRLF e o percorredor;
    Retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #118. Comando 'dividido por' inválido. Erro na variável ''" 
      junto com a frase desta expressão matemática 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #119. Não é possível dividir por '" 
      junto com a frase deste termo seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando 
    o nome do tipo desta expressão matemática e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Atribua" e 
    a variável desta expressão matemática e 
    "para" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Divida" e 
    a variável intermediária e 
    "por" e 
    a variável deste termo e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matemática.
  Limpe a frase desta expressão matemática.

Função para que se determine se uma string é algum objeto indireto:
  Se a string for "via", diga sim.
  Se a string for "por", diga sim. \ TODO: Testar a compatibilidade
  Diga não.

Função para que se determine se uma string é algum operador de subtração:
  Se a string for "menos", diga sim.
  Diga não.

Rotina para que se compile uma expressão matemática usando um percorredor (operador de subtração):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #120. Não é possível subtrair de '" 
      junto com a frase desta expressão matemática 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #121. Não é possível subtrair de '" junto com a frase deste termo 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando 
    o nome do tipo desta expressão matemática e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Atribua" e 
    a variável desta expressão matemática e 
    "para" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Subtraia" e 
    a variável deste termo e 
    "desde" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matemática.
  Limpe a frase desta expressão matemática.

Função para que se determine se uma string é algum operador de adição:
  Se a string for "mais", diga sim.
  Diga não.

Rotina para que se compile uma expressão matemática usando um percorredor (operador de adição):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #122. Não é possível somar o '" 
      junto com a frase desta expressão matemática 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #123. Não é possível adicionar o '" 
      junto com a frase deste termo 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando 
    o nome do tipo desta expressão matemática e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Atribua" e 
    a variável desta expressão matemática e 
    "para" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Adicione" e 
    a variável deste termo e 
    "para" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matemática.
  Limpe a frase desta expressão matemática.



Rotina para que se compile uma expressão matemática usando um percorredor (operador de concatenação):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for alguma palavra de concatenação,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #124. Necessário escrever 'junto DE/junto COM/etc'." e 
      o percorredor;
    Retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #125. A variável da expressão matemática: " 
      junto com a frase desta expressão matemática 
      seguido de " é inválida." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #126. A variável do termo '" junto com a frase deste termo 
      seguido de "' é inválida." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando 
    "string" e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando 
    a variável desta expressão matemática e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Converta o termo por concatenação usando o percorredor.
  \\ aqui faz a concatenação
  Adicione fragmentos diversos usando 
    "Acrescente" e 
    a variável deste termo e 
    "para" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matemática.
  Limpe a frase desta expressão matemática.

Função para que se determine se uma string é alguma palavra de concatenação:
  Se a string for "com", diga sim.
  Se a string for "de", diga sim.
  Se a string for "a", diga sim. \ junto à
  Se a string for "seguida", diga sim.
  Diga não.

Rotina para que se adicione o atribua ou converta fragmentos usando 
    uma variável e 
    uma segunda variável e 
    um endereço local:
  Adicione um fragmento usando 
    a etiqueta de inserção de endereço [na stack] e a segunda variável.
  Adicione um segundo fragmento usando 
    a etiqueta de inserção de endereço [na stack] e a variável.
  Encontre uma rotina usando 
    "Atribua" e 
    o tipo desta variável e 
    "para" e 
    o tipo desta segunda variável.
  Se a rotina for inexistente,
    Encontre a rotina usando 
      "Converta" e 
      o tipo desta variável e 
      "para" e 
      o tipo desta segunda variável.
  Se a rotina não for inexistente,
    Adicione um terceiro fragmento usando a etiqueta de demanda interna e a rotina;
    Retorne.
  \ Mensagem de Erro
  Adicione uma unidade semântica para umas unidades semânticas usando "Atribua/Converta".
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo desta variável.
  Adicione uma terceira unidade semântica para as unidades semânticas usando "para/a".
  Adicione uma quarta unidade semântica para as unidades semânticas usando o tipo desta segunda variável.
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Apresente uma mensagem de erro contendo 
    "Código de Erro #127. A rotina para que se " junto com 
    a representação interna da rotina seguido de 
    " ainda não foi definida." e o endereço local.

Rotina para que se converta um termo por concatenação usando um percorredor: 
  \\ concatenação
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #128. A variável do termo '" junto com 
      a frase deste termo seguido de 
      "' não pode ser encontrada." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo deste termo puder ser reduzido para "string", retorne.
  Adicione uma variável intermediária usando "string" e o caractere inicial deste segmento inicial deste percorredor.
  Adicione o atribua ou converta fragmentos usando 
    a variável deste termo e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável deste termo.
  Limpe a frase deste termo.

Rotina para que se compile uma expressão matemática usando um percorredor (operador de multiplicação):
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente uma mensagem de erro contendo 
        "Código de Erro #129. Não é póssível multiplicar por '"
      junto com a frase desta expressão matemática 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #130. Não é póssível multiplicar por '" 
      junto com a frase deste termo 
      seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável intermediária usando 
    o nome do tipo desta expressão matemática e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Atribua" e 
    a variável desta expressão matemática e 
    "para" e 
    a variável intermediária e 
    o caractere inicial deste segmento inicial deste percorredor.
  Adicione fragmentos diversos usando 
    "Multiplique" e 
    a variável intermediária e 
    "por" e 
    a variável deste termo e 
    o caractere inicial deste segmento inicial deste percorredor.
  Atribua a variável intermediária à variável desta expressão matemática.
  Limpe a frase desta expressão matemática.

Rotina para que se adicione uma unidade semântica para umas unidades semânticas usando uma expressão matemática:
  Crie a unidade semântica.
  Acrescente a unidade semântica para as unidades semânticas.
  Atribua a frase desta expressão matemática à string desta unidade semântica.
  Atribua a variável desta expressão matemática à variável desta unidade semântica.
  Se a variável desta expressão matemática não for inexistente,
    Atribua o tipo desta expressão matemática ao tipo desta unidade semântica.

Rotina para que se crie uma unidade semântica:
  Aloque memória para a unidade semântica.

Rotina para que se remova alguns termos negativos desde umas unidades semânticas retornando um sinalizador:
  Desative o sinalizador.
  Permute as unidades semânticas com umas segunda unidades semânticas.
  Itere.
    Atribua a primeira unidade semântica destas segunda unidades semânticas para uma unidade semântica.
    Se a unidade semântica for inexistente, retorne.
    Remova a unidade semântica desde a segunda unidades semânticas.
    \PAL
    Se a string desta unidade semântica for "não",
      Inverta o sinalizador;
      Destrua a unidade semântica;
      Reitere.
    \CAL
    Acrescente a unidade semântica para as unidades semânticas.
    Se a string desta unidade semântica for "nothing",
      Inverta o sinalizador;
      Atribua "something" à string desta unidade semântica; Reitere.
    Se a string desta unidade semântica for "nada",
      Inverta o sinalizador;
      Atribua "something" à string desta unidade semântica;
      Reitere.
  Reitere.

Rotina para que se adicione push fragmentos usando umas unidades semânticas:
  Se a rotina utilizada atualmente for inexistente, retorne.
  Itere.
    Obtenha uma unidade semântica desde as unidades semânticas (regressivamente).
    Se a unidade semântica for inexistente, retorne.
    Se a variável desta unidade semântica for inexistente, reitere.
    Se o subtexto atual desta unidade semântica não estiver em branco, reitere.
    Se o tipo atual desta unidade semântica for inexistente, reitere.
    Adicione um fragmento usando a etiqueta de inserção de endereço [na stack] e a variável desta unidade semântica.
  Reitere.

Função para que se determine se um subtexto é qualquer separador de comandos:
  Se o subtexto for a vírgula, diga sim.
  Se o subtexto for "então", diga sim.
  [Caso contrário] 
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (demais cláusulas):
  Se existir algum problema de compilação, retorne.
  Se o segmento inicial deste percorredor estiver em branco, retorne.
  Se o segmento inicial deste percorredor for algum comando de retorno de rotina,
  \parei aqui
    Compile a próxima instrução usando o percorredor (cláusula de retorno);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de repetição,
    Compile a próxima instrução usando o percorredor(cláusula de repetição);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de interrupção de repetições,
    Compile a próxima instrução usando o percorredor (cláusula de interrupção);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de confirmação ou negação,
    Compile a próxima instrução usando o percorredor (palavra-chave 'diga'); \ 
    Retorne.
  Se o segmento inicial deste percorredor for "Decodifique",
    Compile a próxima instrução usando o percorredor (cláusula de decodificação);
    Retorne.
  Se o segmento inicial deste percorredor for "Push", \ traduzir para "Empilhe"
    Compile a próxima instrução usando o percorredor (cláusula de empilhamento);
    Retorne.
  Se o segmento inicial deste percorredor for alguma chamada de biblioteca externa,
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe');
    Retorne.
  Se o segmento inicial deste percorredor for algum point,
    Compile a próxima instrução usando o percorredor (palavra-chave 'aponte');
    Retorne.
  Se o segmento inicial deste percorredor for algum comando condicional,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #131. O aninhamento de condicionais não é permitido." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de proteção,
    Apresente a mensagem de erro contendo 
      "Código de Erro #132. A palavra-chave 'Preserve' não pode ser usada nesse tipo de comando." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de percorrimento,
    Apresente a mensagem de erro contendo 
      "Código de Erro #133. Loops não são permitidos em expressões condicionais." junto com o texto CRLF e o percorredor;
    Retorne.
  \Se o segmento inicial deste percorredor for uma palavra-chave de reutilização de rotina,
    \Apresente a mensagem de erro contendo 
      \"Código de Erro #134. O comando 'Empregue' deve ser o único comando de uma rotina." junto com o texto CRLF e o percorredor;
    \Retorne.
  \Se o segmento inicial deste percorredor for "senão",
    \mova o percorredor (usando diretrizes de compilação);
    \Retorne.
  \Se o segmento inicial deste percorredor for "caso",
    \mova o percorredor (usando diretrizes de compilação);
    \Retorne.
  \Se o segmento inicial deste percorredor for "contrário",
    \mova o percorredor (usando diretrizes de compilação);
    \Retorne.
  Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna).

Função para que se determine se uma string é algum comando de retorno de rotina:
  Se a string for "Retorne", diga sim.
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de retorno):
  Se o sinalizador de deliberação desta rotina utilizada atualmente estiver ativo,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #135. Funções booleanas devem retornar apenas 'sim' ou 'não'" junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de retorno.
  Mova o percorredor (usando diretrizes de compilação).

Função para que se determine se uma string é algum comando de repetição:
  \Se a string for "recomece", diga sim.
  \Se a string for "repita", diga sim.
  Se a string for "reitere", diga sim.
  \Se a string for "reinicie", diga sim.
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor(cláusula de repetição):
  Adicione um fragmento usando a etiqueta de repetição.
  Mova o percorredor (usando diretrizes de compilação).

Função para que se determine se uma string é algum comando de interrupção de repetições:
  Se a string for "pare", diga sim.
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de interrupção):
  Adicione um fragmento usando a etiqueta de interrupção.
  Mova o percorredor (usando diretrizes de compilação).

Função para que se determine se uma string é algum comando de confirmação ou negação:
  Se a string for "diga", diga sim.
  \Se a string for "responda", diga sim.
  Diga não.

\ VERSÃO ANTERIOR
\Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'diga'):
  \Se o sinalizador de deliberação desta rotina utilizada atualmente não estiver ativo,
    \Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna);
    \Retorne.
  \Mova o percorredor (usando diretrizes de compilação).
  \Compile uma expressão matemática usando o percorredor.
  \Se existir algum problema de compilação, retorne.
  \Se a variável desta expressão matemática for inexistente,
    \Apresente uma mensagem de erro contendo 
      \"No es válido este 'diga', no entiendo la variável: " 
      \junto com a frase desta expressão matemática seguido de "." junto com o texto CRLF e o percorredor; Retorne.
  \Se o tipo desta expressão matemática não puder ser reduzido para "sinalizador",
    \Apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." junto com o texto CRLF e o percorredor;
    \Retorne.
  \Adicione um fragmento usando a etiqueta de carregamento de registrador EAX e a variável desta expressão matemática.
  \Adicione um segundo fragmento usando a etiqueta de retorno.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'diga'):
  Se o sinalizador de deliberação desta rotina utilizada atualmente não estiver ativo,
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada interna);
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando de deliberação literal,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #136. Funções booleanas devem terminar com um 'sim' ou 'não'." junto com o texto CRLF e o percorredor;
    Retorne.
  Desative um sinalizador.
  Se o segmento inicial deste percorredor for algum decisor literal afirmativo,
    Ative o sinalizador.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo 
      "Código de Erro #137. O compilador esperava encontrar um '.' Encontrado o termo: " 
      junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de carregamento de registrador EAX e o sinalizador.
  Adicione um segundo fragmento usando a etiqueta de retorno.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada interna):
  Compile umas unidades semânticas usando o percorredor.
  Encontre uma rotina usando as unidades semânticas.
  Se a rotina não for inexistente,
    Adicione push fragmentos usando as unidades semânticas.
  Se a rotina não for inexistente,
    Destrua as unidades semânticas;
    Adicione um fragmento usando a etiqueta de demanda interna e a rotina;
    Retorne.
  \ Se a rotina for inexistente,
  Converta as unidades semânticas para uma representação interna da rotina.
  Destrua as unidades semânticas.
  Atribua a representação interna da rotina ao texto retornado.
  Apresente uma mensagem de erro contendo 
    "Código de Erro #138. A rotina para que se " junto com a representação interna da rotina 
    seguido de " não foi localizada." junto com o texto CRLF e o percorredor.

Função para que se determine se uma string é algum comando de deliberação literal:
  Se a string for "sim", diga sim.
  \Se a string for "positivo", diga sim.
  \Se a string for "positivamente", diga sim.
  \Se a string for "afirmativamente", diga sim.
  Se a string for "não", diga sim.
  \Se a string for "negativo", diga sim.
  \Se a string for "negativamente", diga sim.
  \Se a string for "no", diga sim.
  Diga não.

Função para que se determine se uma string é algum decisor literal afirmativo:
  Se a string for "sim", diga sim.
  \Se a string for "positivo", diga sim.
  \Se a string for "positivamente", diga sim.
  \Se a string for "afirmativamente", diga sim.
  Diga não.

Rotina para que se adicione um fragmento usando uma etiqueta e um sinalizador:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua o sinalizador ao sinalizador deste fragmento.

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de decodificação):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum valor hexadecimal literal,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #139. Encontrado '"junto com o segmento inicial deste percorredor 
      seguido de "'. Esperado encontrar valor hexadecimal" junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de decodificação.
  Atribua o segmento inicial deste percorredor para um parte da cifra binária.
  Adicione 1 para o caractere inicial desta parte da cifra binária.
  Converta a parte da cifra binária para o código deste fragmento.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de empilhamento):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma expressão matemática usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente uma mensagem de erro contendo 
    "Código de Erro #140. Comando de empilhamento inválido devido a variável '" 
    junto com a frase desta expressão matemática seguido de "' ser inexistente." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo desta expressão matemática não for valor empilhável,
    Apresente a mensagem de erro contendo 
      "Código de Erro #141. Valores do tipo: " junto com o nome deste tipo desta expressão matemática 
      seguido de "' não podem ser empilhados." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de inserção de valor [na stack] e a variável desta expressão matemática.

Função para que se determine se um tipo é valor empilhável:
  Se o tipo for inexistente, diga não.
  Se a quantidade de caracteres deste tipo for 4, diga sim.
  Se a quantidade de caracteres deste tipo for 2, diga sim.
  Se a quantidade de caracteres deste tipo for 1, diga sim.
  Diga não.

Função para que se determine se uma string é alguma chamada de biblioteca externa:
  \Se a string for "chame", diga sim.
  Se a string for "invoque", diga sim.
  \Se a string for "acione", diga sim.
  Se a string for "processe", diga sim.
  \Se a string for "informe", diga sim.
  \ no caso de comandos como "repasse os parâmetros x e y e z para a função "FunctionName" da biblioteca "MyLibrary.dll"
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe'):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum string literal,
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada externa);
    Retorne.
  Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - chamada indireta).

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada externa):
  Atribua o segmento inicial deste percorredor para uma string.
  Remova as aspas dessa string.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum string literal,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #142. Nomes de bibliotecas dinâmicas devem ser escritos entre aspas. Encontrado: " 
      junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Atribua o segmento inicial deste percorredor para uma segunda string.
  Remova as aspas dessa segunda string.
  Mova o percorredor (usando diretrizes de compilação).
  Adicione uma função para as DLLs usando a string e a segunda string.
  Se o segmento inicial deste percorredor for "com",
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "usando",
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for alguma palavra-chave de devolução,
    Compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  Adicione um fragmento usando a etiqueta de demanda externa e a função.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #143. A variável do termo '" junto com a frase deste termo 
      seguido de "' não pode ser localizada." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um segundo fragmento usando a etiqueta de obtenção do registrador EAX e a variável deste termo.

Rotina para que se adicione uma função para umas DLLs usando um nome da DLL e um nome da função:
  Encontre uma DLL usando o nome da DLL.
  Se a DLL for inexistente,
    Adicione a DLL para as DLLs usando o nome da DLL.
  Encontre a função usando o nome da função e as funções desta DLL.
  Se a função não for inexistente, retorne.
  Crie a função.
  Acrescente a função para as funções desta DLL.
  Atribua o nome da função ao nome desta função.

Rotina para que se encontre uma DLL usando uma string:
  Esvazie a DLL.
  Itere.
    Obtenha a DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Se o nome desta DLL for a string, retorne.
  Reitere.

Rotina para que se adicione uma DLL para umas DLLs usando um nome da DLL:
  Crie a DLL.
  Acrescente a DLL para as DLLs.
  Atribua o nome da DLL ao nome desta DLL.

Rotina para que se crie uma DLL:
  Aloque memória para a DLL.

Rotina para que se encontre uma função usando uma string e uns funções:
  Esvazie a função.
  Itere.
    Obtenha a função desde as funções.
    Se a função for inexistente, retorne.
    Se o nome desta função for a string, retorne.
  Reitere.

Rotina para que se crie uma função:
  Aloque memória para a função.

Função para que se determine se uma termo está vazia;
Função para que se determine se uns termo estão vazias;
Função para que se determine se uns termo estão vazios;
Função para que se determine se um termo está vazio:
  Se a variável deste termo não for inexistente, diga não.
  Se a frase deste termo não estiver em branco, diga não.
  Diga sim.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - cláusula com):
  \ Esta rotina é recursiva já que os parâmetros são passados da direita para a esquerda (exigência do Windows)
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma expressão matemática usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #144. A variável da expressão matemática '"
      junto com a frase desta expressão matemática 
      seguido de "' é inexistente." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo desta expressão matemática não for valor empilhável,
    Apresente a mensagem de erro contendo 
      "Código de Erro #145. O tipo '" junto com o nome deste tipo desta expressão matemática 
      seguido de "' da expressão matemática não é um valor empilhável." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for algum operador de continuidade,
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com). \ RECURSÃO
  Adicione um fragmento usando a etiqueta de inserção de valor [na stack] e a variável desta expressão matemática.

Função para que se determine se uma string é algum operador de continuidade:
  Se a string for "e", diga sim.
  Diga não.

Função para que se determine se uma string é alguma palavra-chave de devolução:
  Se a string for "retornando", diga sim.
  Se a string for "recebendo", diga sim.
  Se a string for "obtendo", diga sim.
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando):
  Mova o percorredor (usando diretrizes de compilação).
  Compile o termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #146. O termo da variável: '" junto com a frase deste termo 
      seguido de "'. aparenta estar vazio." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo deste termo não for valor empilhável,
    Apresente a mensagem de erro contendo 
      "Código de Erro #147. Uma varíavel de 1, 2, ou 4 bytes é necessária na cláusula de devolução." 
      junto com o texto CRLF e o percorredor.

Rotina para que se adicione um fragmento usando uma etiqueta e uma função:
  Se a rotina utilizada atualmente for inexistente,
    Esvazie o fragmento;
    Retorne.
  Crie o fragmento usando a etiqueta.
  Acrescente o fragmento para os fragmentos desta rotina utilizada atualmente.
  Atribua a função à função deste fragmento.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'processe' - chamada indireta):
  Compile uma expressão matemática usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável desta expressão matemática for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #148. A variável da expressão matemática'" 
      junto com a frase desta expressão matemática 
      seguido de "' não pode ser localizada." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o tipo desta expressão matemática não puder ser reduzido para "ponteiro",
    Apresente a mensagem de erro contendo 
      "Código de Erro #149. Comando 'Processe' exige o tipo ponteiro." junto com o texto CRLF e o percorredor;
    Retorne.
  Se o segmento inicial deste percorredor for "com",
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for "usando",
    Compile a próxima instrução usando o percorredor (palavra-chave 'processe' - cláusula com).
  Se o segmento inicial deste percorredor for alguma palavra-chave de devolução,
    Compile a próxima instrução usando o percorredor retornando um termo (palavra-chave 'processe' - cláusula retornando).
  Adicione um fragmento usando a etiqueta de demanda indireta e a variável desta expressão matemática.
  Se o termo estiver vazio, retorne.
  Se a variável deste termo for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #150. A variável do termo '" 
      junto com a frase deste termo 
      seguido de "' é inexistente." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um segundo fragmento usando a etiqueta de obtenção do registrador EAX e a variável deste termo.

Função para que se determine se uma string é algum point:
  Se a string for "aponte", diga sim.
  Se a string for "direcione", diga sim.
  Se a string for "redirecione", diga sim.
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (palavra-chave 'aponte'):
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #151. A variável '" junto com a frase deste termo 
      seguido de "' deste termo não pode ser encontrada." junto com o texto CRLF e o percorredor;
    Retorne.
  Se a categoria deste termo for "valor literal",
    Apresente a mensagem de erro contendo 
      "Código de Erro #152. Identificado valor literal na categoria deste termo." 
      junto com o texto CRLF e o percorredor.
  Se a quantidade de caracteres deste tipo deste termo não for 4,
    Apresente a mensagem de erro contendo 
      "Código de Erro #153. Variável de tamanho diferente de 32 bits." 
      junto com o texto CRLF e o percorredor.
  Se o segmento inicial deste percorredor não for "para",
    Apresente a mensagem de erro contendo 
      "Código de Erro #154. A palavra-chave 'para é necessária após o comando 'aponte'. Termo encontrado: " 
      junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Mova o percorredor (usando diretrizes de compilação).
  \Mova o percorredor (usando diretrizes de compilação). \ artigo definido
  Se o segmento inicial deste percorredor não for "rotina",
    Apresente a mensagem de erro contendo 
      "Código de Erro #155. A sintaxe do comando é 'Aponte para a rotina'. Encontrado termo: " 
      junto com o segmento inicial deste percorredor seguido de "." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para uma representação interna da rotina.
  Destrua a referência da rotina.
  Encontre uma rotina usando a representação interna da rotina e o catálogo geral de rotinas.
  Se a rotina for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #156. A rotina para que se " junto com a representação interna da rotina 
      seguido de " é inexistente." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione um fragmento usando a etiqueta de endereço de rotina e a rotina.
  Atribua a variável deste termo à variável deste fragmento.

Rotina para que se compile uma referência da rotina usando um percorredor:
  Se o segmento inicial deste percorredor for "para",
    Mova o percorredor (usando diretrizes de compilação).
  Se o percorredor for o início de alguma função,
    Compile a referência da rotina usando o percorredor (função);
    Retorne.
  Se o segmento inicial deste percorredor for algum comando de deliberação,
    Compile a referência da rotina usando o percorredor (decide).
  Itere.
    Se existir algum problema de compilação, retorne.
    Se o segmento inicial deste percorredor estiver em branco, retorne.
    Se o segmento inicial deste percorredor for ".", retorne.
    Se o segmento inicial deste percorredor for algum artigo definido,
      Compile a referência da rotina usando o percorredor (artigo definido);
      Reitere.
    Se o segmento inicial deste percorredor for algum artigo indefinido,
      Compile a referência da rotina usando o percorredor (artigo indefinido);
      Reitere.
    Se o percorredor está sobre alguma string de unidade semântica,
      Compile a referência da rotina usando o percorredor (string de unidade semântica);
      Reitere.
    Apresente uma mensagem de erro contendo 
      "Código de Erro #157. O termo '" junto com o segmento inicial deste percorredor 
      seguido de "' não é válido neste tipo de comando." 
      junto com o texto CRLF e o percorredor.
  [Reitere.]

Rotina para que se compile uma referência da rotina usando um percorredor (função):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para a referência da rotina usando "atribua".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo indefinido,
    Ative um sinalizador.
  Se o sinalizador estiver ativo,
    Compile a referência da rotina usando o percorredor (artigo indefinido).
  Se o sinalizador não estiver ativo,
    Compile a referência da rotina usando o percorredor (artigo definido).
  Se o segmento inicial deste percorredor não for algum possessivo inglês,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #158. O compilador esperava encontrar um 's. Encontrado: '"
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Adicione uma segunda unidade semântica para a referência da rotina usando "'s " junto com o nome.
  Se o segmento inicial deste percorredor não for "para",
    Apresente a mensagem de erro contendo 
      "Código de Erro #159. O compilador esperava encontrar a palavra 'para'. Encontrado: '"
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma terceira unidade semântica para a referência da rotina usando "para".
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum artigo indefinido,
    Apresente a mensagem de erro contendo 
      "Código de Erro #160. O compilador esperava encontrar um artigo indefinido. Encontrado: '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Compile a referência da rotina usando o percorredor (artigo indefinido).

Rotina para que se compile uma referência da rotina usando um percorredor (artigo indefinido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Encontre um tipo e um apelido usando o nome.
  Se o tipo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #161. O comando '" junto com o nome seguido de 
      "' não é um comando de reutilização válido." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma unidade semântica para a referência da rotina usando o tipo.

Rotina para que se compile uma referência da rotina usando um percorredor (artigo definido):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Examine um nome usando o percorredor.
  Anteponha "O " para o nome.
  Adicione uma unidade semântica para a referência da rotina usando o nome.
  
Rotina para que se compile uma referência da rotina usando um percorredor (decide):
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for algum comando condicional,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #162. Esperava encontrar: 'Para que se determine SE xxxx'. Encontrado: 'Para que se determine '"
      junto com o segmento inicial deste percorredor seguido de "' '." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile uma referência da rotina usando um percorredor (string de unidade semântica):
  Se existir algum problema de compilação, retorne.
  Adicione uma unidade semântica para a referência da rotina usando o segmento inicial deste percorredor.
  Mova o percorredor (usando diretrizes de compilação).

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de inicio de laço):
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando a etiqueta de laço.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #163. Necessário incluir um '.' após comandos em blocos de repetição." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Função para que se determine se uma string é algum comando de proteção:
  Se a string for "isole", diga sim.
  Se a string for "conserve", diga sim.
  Se a string for "preserve", diga sim.
  \Se a string for "derive", diga sim.
  Diga não.

Rotina para que se compile a próxima instrução usando um percorredor (cláusula de isolamento):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile um termo usando o percorredor.
  Se existir algum problema de compilação, retorne.
  Se a variável deste termo for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #164. Comando 'Isole', Inválido. A variável '" 
      junto com a frase deste termo 
      [seguido de "do termo '" junto com o termo]
      seguido de "' está vazia. " junto com o texto CRLF e o percorredor;
    Retorne.
  Se a categoria deste termo não for "parâmetro",
    Apresente a mensagem de erro contendo 
      "Código de Erro #165. Apenas parâmetros podem ser isolados." junto com o texto CRLF e o percorredor;
    Retorne.
  Adicione uma variável local para as variáveis locais desta rotina utilizada atualmente usando "variável local" e o caractere inicial deste segmento inicial deste percorredor.
  Atribua o nome deste termo ao nome desta variável local.
  Atribua o apelido deste termo ao apelido desta variável local.
  Atribua o nome do tipo deste termo ao nome do tipo desta variável local.
  Destrinche a variável local.
  \Anteponha "original " para o nome deste termo.
  Acrescente " original" para o nome deste termo.
  Se o apelido deste termo não estiver em branco,
    \Anteponha "original " para o apelido deste termo.
    Acrescente " original" para o apelido deste termo.
  Adicione fragmentos diversos usando "Atribua" e a variável deste termo e "para" e a variável local e o caractere inicial deste segmento inicial deste percorredor.
  Se o segmento inicial deste percorredor não for o ponto final,
    Apresente a mensagem de erro contendo "Código de Erro #166. Necessário incluir um '.' ao fim do comando" junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).

Função para que se determine se uma string é algum comando de percorrimento:
  \Se a string for "percorra", diga sim.
  \Se a string for "comece", diga sim.
  Se a string for "itere", diga sim.
  Diga não.

Função para que se determine se uma string é uma palavra-chave de reutilização de rotina:
  \ Funcionalidade obsoleta desde a implantação da sobrecarga de cabeçalhos de rotina
  Se a string for "empregue", diga sim.
  Diga não.

Função para que se determine se uma string é o início de alguma declaração:
  Se a string for o enunciado de alguma rotina ou variável, diga não.
  Se a string for algum valor literal, diga não.
  Se a string for algum sinal de pontuação, diga não.
  Se a string estiver em branco, diga não.
  Diga sim.

Rotina para que se compile o corpo relacionado com uma rotina (etapa conclusiva):
  Se a rotina for inexistente, retorne.
  Se existir algum problema de compilação, retorne.
  Adicione um fragmento usando a etiqueta de finalização.
  Itere.
    Obtenha uma variável desde as variáveis locais desta rotina.
    Se a variável for inexistente, pare.
    Se a categoria desta variável for "variável temporária de compilação", reitere.
    Se o tipo desta variável não deveria ser finalizado, reitere.
    Adicione um segundo fragmento usando a etiqueta de inserção de endereço [na stack] e a variável.
    Encontre uma segunda rotina usando "~Finalize" e o tipo desta variável.
    Se a segunda rotina for inexistente,
      Apresente uma mensagem de erro contendo 
        "Código de Erro #167. A 'rotina para que se finalize um " junto com o tipo desta variável 
        seguido de "' não foi encontrada no catálogo geral de rotinas." junto com o texto CRLF;
      Retorne.
    Adicione um terceiro fragmento usando a etiqueta de demanda interna e a segunda rotina.
  Reitere.
  Adicione um quarto fragmento usando a etiqueta conclusiva.

\-------------------------------------------------------------------------------------- ROTINAS EXTRAS --------------------------------------------------------

Rotina para que se compile o corpo relacionado com uma rotina usando um percorredor (cláusula de reutilização):
  Se existir algum problema de compilação, retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Compile uma referência da rotina usando o percorredor.
  Converta a referência da rotina para o representação de emprego desta rotina.
  Destrua a referência da rotina.
  Se o segmento inicial deste percorredor não for ".",
    Apresente uma mensagem de erro contendo 
      "Código de Erro #168. O comando 'Empregue' deve terminar com um '.' ao invés de '" 
      junto com o segmento inicial deste percorredor seguido de "'." junto com o texto CRLF e o percorredor;
    Retorne.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor não estiver em branco,
    Apresente a mensagem de erro contendo 
      "Código de Erro #169. Permitido apenas uma cláusula de reutilização dentro de cada rotina" junto com o texto CRLF e o percorredor;
    Retorne.
  Encontre uma segunda rotina usando o representação de emprego desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #170. A rotina para que se '" junto com a representação de emprego desta rotina 
      seguido de "' não foi encontrada." e o endereço local desta rotina;
    Retorne.
  Compile o corpo relacionado com a segunda rotina.

\------------------------------------------------------------------------------------------------------------------------------------

Rotina para que se compile um endereço da pasta (adição e compilação da rotina de inicialização): \ #011
  Se existir algum problema de compilação, retorne.
  Escreva "Adicionando e agrupando as tarefas padrão de inicialização.." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de adição de rotinas pré-definidas de inicialização.
  Adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução.
  Suspenda o temporizador de adição de rotinas pré-definidas de inicialização.

Rotina para que se adicione e compile as rotinas de inicialização pré-execução e finalização pós-execução:
  Se existir algum problema de compilação, retorne.
  Adicione uma rotina para as rotinas usando nulo [como endereço local].
  Acrescente "~Inicialize antes da execução e Execute o programa e Finalize após execução" para a string do cabeçalho desta rotina.
  Acrescente "Inicialize antes da execução. " para a string do corpo desta rotina.
  Acrescente os inicializadores de variáveis globais para a string do corpo desta rotina.
  Acrescente "Execute o programa. " para a string do corpo desta rotina.
  Acrescente os finalizadores de variáveis globais para a string do corpo desta rotina.
  Acrescente "Finalize após execução. " para a string do corpo desta rotina.
  Acrescente "Processe ""kernel32.dll"" ""ExitProcess"" com 0. " para a string do corpo desta rotina.
  Lance a cabeçalho de rotina desta rotina sobre a string do cabeçalho desta rotina.
  Lance as instruções desta rotina sobre a string do corpo desta rotina.
  Compile o cabeçalho próprio à rotina.
  Compile o corpo relacionado com a rotina.

Rotina para que se acrescente os inicializadores de variáveis globais para uma string:
  \Itere.
    Obtenha uma variável global desde as variáveis globais.
    Se a variável global for inexistente, retorne.
    Se o valor literal desta variável global for inexistente, reitere.
    Se o sinalizador de compilação desta variável global não estiver ativo, reitere.
    Desative um sinalizador.
    Acrescente o texto inicializador desta variável global para a string.
  Reitere.

Rotina para que se acrescente os finalizadores de variáveis globais para uma string:
  \Itere.
    Obtenha uma variável global desde as variáveis globais.
    Se a variável global for inexistente, retorne.
    Se o sinalizador de compilação desta variável global não estiver ativo, reitere.
    Se o tipo desta variável global não deveria ser finalizado, reitere.
    Acrescente "~Finalize o " junto com o nome desta variável global seguido de ". " para a string.
  Reitere.

\------------------------------------------------------------------------------------------------------------------------------------

Rotina para que se compile um endereço da pasta (deslocamento de parâmetros e variáveis): \ #012
  Se existir algum problema de compilação, retorne.
  Escreva "Deslocando parâmetros e variáveis..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de deslocamentos.
  Alinhe os parâmetros na rotinas.
  Alinhe as variáveis locais na rotinas.
  Suspenda o temporizador de deslocamentos.

Rotina para que se alinhe os parâmetros em umas rotinas:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Alinhe os parâmetros na rotina.
  Reitere.

\ Aqui temos a convenção de chamada de Português Puro
Rotina para que se alinhe os parâmetros em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a sinalizador de compilação desta rotina não estiver ativo, retorne.
  Limpe o tamanho do parâmetro desta rotina.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um parâmetro desde os parâmetros desta rotina.
    Se o parâmetro for inexistente, retorne.
    Se o sinalizador de compatibilidade desta rotina estiver ativo,
      Ative o sinalizador de passagem por-valor deste parâmetro.
    Se o parâmetro anterior deste parâmetro for inexistente,
      Atribua 8 ao deslocamento deste parâmetro. \ Ignora o endereço de retorno e o ebp salvo
    Se o parâmetro anterior deste parâmetro não for inexistente,
      Atribua o deslocamento deste parâmetro anterior deste parâmetro mais 4 ao deslocamento deste parâmetro.
      \ Todos os parâmetros possuem um 4 endereço de bytes ou valor de 4 bytes (callbacks)
    Adicione 4 para a tamanho do parâmetro desta rotina.
  Reitere.

Rotina para que se alinhe as variáveis locais em umas rotinas:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Alinhe as variáveis locais na rotina.
  Reitere.

Rotina para que se alinhe as variáveis locais em uma rotina:
  Se a rotina for inexistente, retorne.
  Se a sinalizador de compilação desta rotina não estiver ativo, retorne.
  Limpe o tamanho local desta rotina.
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma variável local desde as variáveis locais desta rotina.
    Se a variável local for inexistente, retorne.
    Se a variável local anterior desta variável local não for inexistente,
      Atribua o deslocamento deste variável local anterior desta variável local ao deslocamento desta variável local.
    Atribua a quantidade de caracteres deste tipo desta variável local para uma quantidade de caracteres.
    Se a categoria desta variável local for "variável temporária de compilação",
      Atribua a magnitude dum ponteiro à quantidade de caracteres.
    Arredonde a quantidade de caracteres para cima usando o múltiplo imediato de 4.
    Subtraia a quantidade de caracteres desde o deslocamento desta variável local.
    Adicione a quantidade de caracteres para o tamanho local desta rotina.
  Reitere.

\------------------------------------------------------------------------------------------------------------------------------------

Rotina para que se compile um endereço da pasta (endereço): \ #013
  Se existir algum problema de compilação, retorne.
  Escreva "Obtendo endereço dos itens..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de endereçamento.
  Atribua 4096 para um endereço.
  Atribua o endereço ao endereço base desta Seção de DLLs.
  Enderece as DLLs usando o endereço.
  Atribua o endereço menos a endereço base desta Seção de DLLs à quantidade de caracteres desta Seção de DLLs.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta Região de Dados.
  Enderece as variáveis globais usando o endereço.
  Enderece os valores literais usando o endereço.
  Atribua o endereço menos a endereço base desta Região de Dados à quantidade de caracteres desta Região de Dados.
  Arredonde o endereço para cima usando o múltiplo imediato de 4096.
  Atribua o endereço à endereço base desta Região de Código.
  \ Uma zona é uma estrutura com um endereço base, uma quantidade de caracteres e um tamanho.
  Enderece as rotinas usando o endereço.
  Atribua o endereço menos a endereço base desta Região de Código à quantidade de caracteres desta Região de Código.
  Suspenda o temporizador de endereçamento.

Rotina para que se enderece umas DLLs usando um endereço:
  Atribua o endereço ao endereço do cabeçalho usado atualmente.
  Atribua a contagem destas DLLs para uma contagem.
  Adicione 1 para a contagem.
  Multiplique a contagem pela magnitude dum cabeçalho da DLL.
  Atribua o endereço mais a contagem ao endereço pré-calculado atual.
  Obtenha uma segunda contagem usando as DLLs (todas as funções mais os marcadores).
  Multiplique a segunda contagem por 4.
  Atribua o endereço pré-calculado atual mais a segunda contagem ao endereço do nome usado atualmente.
  Itere.
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, pare.
    Enderece a DLL.
  Reitere.
  Atribua o endereço do nome usado atualmente menos o endereço para um número.
  Adicione o número para o endereço.

Rotina para que se obtenha uma contagem usando umas DLLs (todas as funções mais os marcadores):
  Atribua 0 à contagem.
  Itere.
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Adicione a contagem destas funções desta DLL para a contagem.
    Adicione 1 para a contagem.
  Reitere.

Rotina para que se enderece uma DLL:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta DLL.
  Atribua o endereço do cabeçalho usado atualmente ao endereço do cabeçalho desta DLL.
  Atribua o endereço do nome usado atualmente ao endereço do nome deste cabeçalho da DLL desta DLL.
  Atribua a quantidade de caracteres deste nome desta DLL mais 1 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Adicione a magnitude dum cabeçalho da DLL para o endereço do cabeçalho usado atualmente.
  Atribua o endereço pré-calculado atual ao primeiro endereço thunk de memória deste cabeçalho da DLL desta DLL.
  Enderece as funções desta DLL.
  Adicione 4 para o endereço pré-calculado atual.

Rotina para que se enderece umas funções:
  \Itere.
    Obtenha uma função desde as funções.
    Se a função for inexistente, retorne.
    Enderece a função.
  Reitere.

Rotina para que se enderece uma função:
  Atribua o endereço do nome usado atualmente ao endereço do nome desta função.
  Atribua a quantidade de caracteres deste nome deste função mais 3 para um número.
  Arredonde o número para cima usando o múltiplo imediato de 2.
  Adicione o número para o endereço do nome usado atualmente.
  Atribua o endereço pré-calculado atual ao endereço thunk desta função.
  Atribua o image base mais o endereço pré-calculado atual ao endereço desta função.
  Adicione 4 para o endereço pré-calculado atual.

Rotina para que se enderece umas variáveis usando um endereço:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Enderece a variável usando o endereço.
  Reitere.

Rotina para que se enderece uma variável usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se a variável for inexistente, retorne.
  Se o sinalizador de compilação desta variável não estiver ativo, retorne.
  Atribua o image base mais o endereço ao endereço desta variável.
  Adicione a quantidade de caracteres deste tipo desta variável para o endereço.
  Se o tipo desta variável puder ser reduzido para "string",
    Adicione a quantidade de caracteres deste data desta variável mais 1 para o endereço.
    \ Strings adicionam um espaço extra para o caractere nulo, para compatibilidade com o Windows
  Arredonde para cima o endereço usando o múltiplo imediato de 4.

Rotina para que se enderece umas rotinas usando um endereço:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, pare.
    Enderece a rotina usando o endereço.
  Reitere.

Rotina para que se enderece uma rotina usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o representação de emprego desta rotina não estiver em branco, retorne.
  \ Comandos de emprego são trabalhados posteriormente
  Se o sinalizador de compilação desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Atribua o image base mais o endereço ao endereço desta rotina.
  Enderece os fragmentos desta rotina usando o endereço.
  Arredonde o endereço para cima usando o múltiplo imediato de 4.

Rotina para que se enderece uns fragmentos usando um endereço:
  \Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um fragmento desde o fragmentos.
    Se o fragmento for inexistente, retorne.
    Enderece o fragmento usando o endereço.
  Reitere.

Rotina para que se enderece um fragmento usando um endereço:
  Se existir algum problema de compilação, retorne.
  Se o fragmento for inexistente, retorne.
  Atribua o image base mais o endereço ao endereço deste fragmento.
  Se a etiqueta deste fragmento for a etiqueta de inserção de endereço [na stack],
    Adicione 7 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de endereço,
    Adicione 12 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo,
    Adicione 10 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de redirecionamento,
    Adicione 14 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de desvio falso,
    Adicione 9 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica,
    Adicione 3 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de retorno,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de interrupção,
    Adicione 5 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta preliminar,
    Enderece o fragmento usando o endereço (etapa preliminar);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta conclusiva,
    Enderece o fragmento usando o endereço (etapa conclusiva);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de decodificação,
    Adicione a quantidade de caracteres deste código deste fragmento para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de inserção de valor [na stack],
    Enderece o fragmento usando o endereço (empilhamento de valor);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa,
    Adicione 6 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de registrador EAX,
    Adicione 5 para o endereço;
    Retorne. \ O valor era 8 quando "load eax" aceitava strings ("yes" e "no"),
    \ agora a rotina "load eax" só aceita os números 1 e 0
  Se a etiqueta deste fragmento for a etiqueta de obtenção do registrador EAX,
    Enderece o fragmento usando o endereço (registrador EAX);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta,
    Adicione 8 para o endereço;
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina,
    Adicione 12 para o endereço;
    Retorne.

Rotina para que se enderece um fragmento usando um endereço (etapa preliminar):
  Adicione 3 para o endereço.
  Se o tamanho local desta rotina utilizada atualmente não for 0,
    Adicione 10 para o endereço.
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo,
    Adicione 3 para o endereço.

Rotina para que se enderece um fragmento usando um endereço (etapa conclusiva):
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo,
    Adicione 3 para o endereço.
  Adicione 6 para o endereço.

Rotina para que se enderece um fragmento usando um endereço (empilhamento de valor):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #171. A variável '" junto com o nome desta variável deste fragmento 
      seguido de "' não foi devidamente inicializada. Certifique-se de atribuir um valor antes do uso." junto com o texto CRLF;
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #172. O tipo '" junto com o nome deste tipo desta variável deste fragmento 
       seguido de "da variável '" junto com o nome desta variável deste fragmento seguido de 
      "' não foi implementado.  Verifique se ele foi definido corretamente." junto com o texto CRLF;
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4,
    Adicione 2 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 2,
    Adicione 3 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 1,
    Adicione 4 para o endereço;
    Retorne.
  Apresente a mensagem de erro contendo 
    "Código de Erro #173.  O tipo '" junto com o nome deste tipo desta variável deste fragmento 
    seguido de "' possui um tamanho inválido para a pilha. Apenas tipos de 8, 16 ou 32 bits são permitidos." junto com o texto CRLF.

Rotina para que se enderece um fragmento usando um endereço (registrador EAX):
  Adicione 6 para o endereço.
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #174. A variável '" junto com o nome desta variável deste fragmento seguido de 
      "' não foi inicializada corretamente. Certifique-se de atribuir um valor antes do uso." junto com o texto CRLF;
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #175. O tipo '" junto com o nome deste tipo desta variável deste fragmento
      seguido de "da variável '" junto com o nome desta variável deste fragmento 
      seguido de "' não foi implementado.  Verifique se ele foi definido corretamente." junto com o texto CRLF;
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4,
    Adicione 2 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 2,
    Adicione 3 para o endereço;
    Retorne.
  Se a quantidade de caracteres for 1,
    Adicione 2 para o endereço;
    Retorne.
  Apresente a mensagem de erro contendo 
    "Código de Erro #176. O tipo '" 
    junto com o nome deste tipo desta variável deste fragmento seguido de 
    "' possui um tamanho inválido. Apenas tipos de 8, 16 ou 32 bits são permitidos.".

\------------------------------------------------------------------------------------------------------------------------------------

Rotina para que se compile um endereço da pasta (transmutação): \ #014
  Se existir algum problema de compilação, retorne.
  Escreva "Convertendo código em instruções de máquina..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de transmutação.
  Transforme as rotinas em código hexadecimal.
  Suspenda o temporizador de transmutação.

Rotina para que se transforme umas rotinas em código hexadecimal:
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, pare.
    Transforme a rotina em código hexadecimal.
  Reitere.

Rotina para que se transforme uma rotina em código hexadecimal:
  Se existir algum problema de compilação, retorne.
  Se a rotina for inexistente, retorne.
  Se o representação de emprego desta rotina não estiver em branco, retorne.
  Se o sinalizador de compilação desta rotina não estiver ativo, retorne.
  Atribua a rotina à rotina utilizada atualmente.
  Transforme os fragmentos desta rotina em código hexadecimal.

Rotina para que se transforme uns fragmentos em código hexadecimal:
  Itere.
    Se existir algum problema de compilação, retorne.
    Obtenha um fragmento desde o fragmentos.
    Se o fragmento for inexistente, retorne.
    Transforme o fragmento em código hexadecimal.
  Reitere.

Rotina para que se transforme um fragmento em código hexadecimal:
  Se existir algum problema de compilação, retorne.
  Se o fragmento for inexistente, retorne.
  Se a etiqueta deste fragmento for a etiqueta de inserção de endereço [na stack],
    Transforme o fragmento em código hexadecimal (empilhamento de endereço);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda interna,
    Transforme o fragmento em código hexadecimal (Demanda Interna);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de endereço,
    Transforme o fragmento em código hexadecimal (load endereço);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de acréscimo,
    Transforme o fragmento em código hexadecimal (increment);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de redirecionamento,
    Transforme o fragmento em código hexadecimal (cláusula de redirecionamento);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de desvio falso,
    Transforme o fragmento em código hexadecimal (desvio caso resultado negativo);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de negação lógica,
    Transforme o fragmento em código hexadecimal (negação lógica);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de retorno,
    Transforme o fragmento em código hexadecimal (cláusula de retorno);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de repetição,
    Transforme o fragmento em código hexadecimal (cláusula de repetição);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de interrupção,
    Transforme o fragmento em código hexadecimal (cláusula de interrupção);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta preliminar,
    Transforme o fragmento em código hexadecimal (etapa preliminar);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta conclusiva,
    Transforme o fragmento em código hexadecimal (etapa conclusiva);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de inserção de valor [na stack],
    Transforme o fragmento em código hexadecimal (empilhamento de valor);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda externa,
    Transforme o fragmento em código hexadecimal (Demanda Externa);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de carregamento de registrador EAX,
    Transforme o fragmento em código hexadecimal (atribuição de EAX);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de obtenção do registrador EAX,
    Transforme o fragmento em código hexadecimal (registrador EAX);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de demanda indireta,
    Transforme o fragmento em código hexadecimal (Demanda Indireta);
    Retorne.
  Se a etiqueta deste fragmento for a etiqueta de endereço de rotina,
    Transforme o fragmento em código hexadecimal (endereço de rotina);
    Retorne.

Rotina para que se transforme um fragmento em código hexadecimal (empilhamento de endereço):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento.
  \ Atribui o endereço para edx
  Acrescente $52 para o código deste fragmento. \ push edx

Rotina para que se acrescente a instrução de carregamento de endereço para um texto hexadecimal usando uma variável:
  \ carrega o valor em edx
  Se a variável for inexistente,
    Acrescente $C7C200000000 para o texto hexadecimal; \ mov edx, 0x0
    Retorne.
  Se a categoria desta variável for "variável global",
    Acrescente $C7C2 e o endereço desta variável para o texto hexadecimal;
    \ mov edx, o endereço da variável
    Retorne.
  Se a categoria desta variável for "valor literal",
    Acrescente $C7C2 e o endereço desta variável para o texto hexadecimal;
    \ mov edx, o endereço da variável
    Retorne.
  Se a categoria desta variável for "variável local",
    Acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal;
    \ lea edx, [ebp+ o deslocamento da variável]
    Retorne.
  Se a categoria desta variável for "variável temporária de compilação",
    Acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal;
    \ mov edx, [ebp+ o deslocamento da variável]
    Retorne.
  \ Se a variável não se encaixar em nenhuma dessas categorias é porque ela é um parâmetro
  Se a categoria desta variável não for "parâmetro",
    Apresente uma mensagem de erro contendo 
      "Código de Erro #177. A categoria da variável '" junto com o nome desta variável 
      seguido de "' é diferente de 'parâmetro'." junto com o texto CRLF;
    Retorne.
  \ Se a categoria desta variável for "parâmetro",
  Se o sinalizador de passagem por-valor desta variável estiver ativo, \ Só é ativado em callbacks (do Windows)
    Acrescente $8D95 e o deslocamento desta variável para o texto hexadecimal;
    \ lea edx,[ebp+ o deslocamento da variável]
    Retorne.
  \Se o sinalizador de passagem por-valor desta variável não estiver ativo,
    Acrescente $8B95 e o deslocamento desta variável para o texto hexadecimal.
    \ mov edx,[ebp+ o deslocamento da variável]

Rotina para que se transforme um fragmento em código hexadecimal (Demanda Interna):
  Obtenha um endereço usando a rotina deste fragmento.
  Acrescente $E8 e o endereço para o fragmento. \ call o endereço da rotina do fragmento

Rotina para que se obtenha um endereço usando uma rotina:
  Se o endereço desta rotina não for 0,
    Atribua o endereço desta rotina ao endereço;
    Retorne.
  Atribua -1 ao endereço desta rotina.
  Encontre uma segunda rotina usando o representação de emprego desta rotina e o catálogo geral de rotinas.
  Se a segunda rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #178. A 'Rotina para que se " junto com a representação de emprego desta rotina 
      seguido de "' não foi encontrada. (Esta rotina foi invocada utilizando palavra-chave 'Empregue')." 
      junto com o texto CRLF e o endereço local desta rotina;
    Retorne.
  Se o endereço desta segunda rotina for -1,
    Apresente a mensagem de erro contendo 
      "Código de Erro #179. A palavra-chave 'Empregue' está fazendo uma referência recursiva. " 
       junto com o texto CRLF e o endereço local desta rotina;
    Retorne.
  Obtenha o endereço usando a segunda rotina.
  Atribua o endereço ao endereço desta rotina.

Rotina para que se transforme um fragmento em código hexadecimal (load endereço):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento.
  Acrescente $8995 e o deslocamento desta segunda variável deste fragmento para o código deste fragmento.
  \ mov [ebp+ o deslocamento da variável do fragmento], edx

Rotina para que se acrescente um texto hexadecimal e um sinalizador para um segundo texto hexadecimal;
Rotina para que se acrescente um texto hexadecimal e um número para um segundo texto hexadecimal:
  Acrescente o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Acrescente o terceiro texto hexadecimal para o segundo texto hexadecimal.

Rotina para que se transforme um fragmento em código hexadecimal (increment):
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #180. A variável '" junto com o nome desta variável deste fragmento \ Erro interno
      seguido de "' deste fragmento não foi encontrada." junto com o texto CRLF;
    Retorne.
  Se a categoria desta variável deste fragmento não for "variável temporária de compilação",
    Apresente a mensagem de erro contendo 
      "Código de Erro #181. A categoria da variável '" junto com o nome desta variável deste fragmento \ Erro interno
      seguido de "' não corresponde 'variável temporária de compilação'. Categoria detectada: '" 
      junto com a categoria desta variável deste fragmento seguido de "'." junto com o texto CRLF;
    Retorne.
  Acrescente 
      $8185 e 
      o deslocamento desta variável deste fragmento e 
      o número deste fragmento 
    para 
      o código deste fragmento.
  \ add [ebp+ o deslocamento da variável do fragmento], o número do fragmento

Rotina para que se acrescente um texto hexadecimal e um número e um segundo número para um segundo texto hexadecimal:
  Acrescente o texto hexadecimal para o segundo texto hexadecimal.
  Converta o número para um terceiro texto hexadecimal.
  Acrescente o terceiro texto hexadecimal para o segundo texto hexadecimal.
  Converta o segundo número para um quarto texto hexadecimal.
  Acrescente o quarto texto hexadecimal para o segundo texto hexadecimal.

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de redirecionamento):
  Acrescente $8B95 e o deslocamento desta variável deste fragmento para o código deste fragmento.
  \ mov edx, [ebp+ o deslocamento da variável do fragmento]
  Acrescente $8B12 para o código deste fragmento. \ mov edx,[edx]
  Acrescente $8995 e o deslocamento desta variável deste fragmento para o código deste fragmento.
  \ mov [ebp+ o deslocamento da variável do fragmento]

Rotina para que se transforme um fragmento em código hexadecimal (desvio caso resultado negativo):
  Encontre um segundo fragmento usando o fragmento e a etiqueta delimitadora de bloco condicional.
  Se o segundo fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #182. A variável '"  junto com o nome desta variável deste segundo fragmento 
      junto com "' deste fragmento não foi localizada" junto com o texto CRLF; \ Erro interno
    Retorne.
  Acrescente $83F800 para o código deste fragmento. \ cmp eax,0
  Acrescente $0F84 e o endereço deste segundo fragmento para o fragmento. \ je + o endereço do fragmento

Rotina para que se encontre um fragmento usando um segundo fragmento e uma etiqueta:
  Atribua o segundo fragmento ao fragmento.
  Itere.
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o próximo fragmento deste fragmento ao fragmento.
  Reitere.

Rotina para que se acrescente um texto hexadecimal e um endereço para um fragmento:
  \ Call / Jump
  Atribua o endereço para um número.
  Subtraia o endereço deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste código deste fragmento desde o número.
  Subtraia a quantidade de caracteres deste texto hexadecimal desde o número.
  Subtraia 4 desde o número.
  Acrescente o texto hexadecimal e o número para o código deste fragmento.

Rotina para que se transforme um fragmento em código hexadecimal (negação lógica):
  \ deveria ser conjunção lógica?
  Acrescente $83F001 para o código deste fragmento. \ xor eax,1

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de retorno):
  Encontre um segundo fragmento usando o fragmento e a etiqueta de finalização.
  Se o segundo fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #183. A variável '"  junto com o nome desta variável deste segundo fragmento 
      junto com "' deste fragmento não foi localizada" junto com o texto CRLF; \ Erro interno
    Retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento.
  \ jmp + o endereço do fragmento

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de repetição):
  Encontre um segundo fragmento usando o fragmento e a etiqueta de laço (regressivamente).
  Se o segundo fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #184. A variável '"  junto com o nome desta variável deste segundo fragmento 
      junto com "' deste fragmento não foi localizada" junto com o texto CRLF; \ Erro interno
    Retorne.
  Acrescente $E9 e o endereço deste segundo fragmento para o fragmento.
  \ jmp o endereço do fragmento

Rotina para que se encontre um fragmento usando um segundo fragmento e uma etiqueta (regressivamente):
  Atribua o segundo fragmento ao fragmento.
  Itere.
    Se o fragmento for inexistente, retorne.
    Se a etiqueta deste fragmento for a etiqueta, retorne.
    Atribua o fragmento anterior deste fragmento ao fragmento.
  Reitere.

Rotina para que se transforme um fragmento em código hexadecimal (cláusula de interrupção):
  Atribua a etiqueta de repetição para uma etiqueta.
  Encontre um segundo fragmento usando o fragmento e a etiqueta.
  Se o segundo fragmento for inexistente,
    Atribua a etiqueta de finalização para a etiqueta. \ para interromper um loop
  Encontre um terceiro fragmento usando 
    o último fragmento destes fragmentos desta rotina utilizada atualmente e 
    a etiqueta (regressivamente).
  Se o terceiro fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #185. A variável '"  junto com o nome desta variável deste terceiro fragmento 
      junto com "' deste fragmento não foi localizada" junto com o texto CRLF; \ Erro interno
    Retorne.
  Se o próximo fragmento deste terceiro fragmento for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #186. A variável '"  junto com o nome desta variável deste terceiro fragmento 
      junto com "' deste fragmento não foi localizada" junto com o texto CRLF; \ Erro interno
    Retorne.
  Acrescente $E9 [JMP rel32] e o endereço deste próximo fragmento deste terceiro fragmento para o fragmento.
  \ JMP o endereço de destino.
  \Salto próximo, relativo, deslocamento relativo à próxima instrução.

\ O PRÓLOGO DE TODA ROTINA DE INGLÊS SIMPLES COMEÇA SALVANDO O EBP DO CHAMADOR NA PILHA, LOGO ACIMA DO ENDEREÇO DE RETORNO.
Rotina para que se transforme um fragmento em código hexadecimal (etapa preliminar):
  Acrescente $55 para o código deste fragmento. \ push ebp
  Acrescente $8BEC para o código deste fragmento. \ mov ebp,esp
  Atribua o tamanho local desta rotina utilizada atualmente dividido por 4 para um número.
  Se o número não for 0,
    Acrescente $B9 e o número \ mov ecx,number;  
    \ -> configura o loop que irá liberar espaço suficiente na pilha para as variáveis locais da rotina
    e $6A004975FB 
    \ loop: 
        \push 0;
        \dec ecx;
        \jnz loop 
    \ é um loop que coloca zeros suficientes na pilha para inicializar as variáveis locais.
    para o código deste fragmento.
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo,
    Acrescente $535657 para o código deste fragmento. \ push ebx, esi, edi

\ O EPÍLOGO DE CADA ROTINA REMOVE AS VARIÁVEIS LOCAIS,
\ RESTAURA O EBP E RETORNA AO CHAMADOR,
\ POPPING OS PARÂMETROS ASSIM QUE ISSO OCORRE
Rotina para que se transforme um fragmento em código hexadecimal (etapa conclusiva):
  Se o sinalizador de compatibilidade desta rotina utilizada atualmente estiver ativo,
    Acrescente $5F5E5B para o código deste fragmento. \ pop edi; pop esi; pop ebx;
  Acrescente $8BE5 para o código deste fragmento. \ mov esp,ebp -> não seria 89EC?
  Acrescente $5D para o código deste fragmento. \ pop ebp
  Acrescente $C2 e o tamanho do parâmetro desta rotina utilizada atualmente para o código deste fragmento.
  \ ret + o tamanho do parâmetro da rotina utilizada atualmente

Rotina para que se transforme um fragmento em código hexadecimal (empilhamento de valor):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento.
  \ Salva o endereço em edx
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #187. A variável '"  junto com o nome desta variável deste fragmento 
      junto com "' deste fragmento não foi localizada" junto com o texto CRLF; \ Erro interno
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #188. O tipo '" junto com o nome deste tipo desta variável deste fragmento 
      seguido de "' da variável '" junto com o nome desta variável deste fragmento 
      seguido de "' deste fragmento não foi encontrado." junto com o texto CRLF;
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  Se a quantidade de caracteres for 4,
    Acrescente $FF32 para o código deste fragmento; \65330
    Retorne. \ push DWORD PTR [edx]
  Se a quantidade de caracteres for 2,
    Acrescente $66FF32 para o código deste fragmento; \ 6.750.002
    Retorne. \ push WORD PTR [edx]
  Se a quantidade de caracteres for 1,
    Acrescente $0FB61252 para o código deste fragmento;
    Retorne.
    \ movzxb edx, BYTE PTR [edx];
    \ push edx
  \Se a quantidade de caracteres for outra, então...
    Apresente a mensagem de erro contendo 
    "Código de Erro #189. Tamanho do fragmento inválido" junto com o texto CRLF. \ Erro interno

Rotina para que se transforme um fragmento em código hexadecimal (Demanda Externa):
  Acrescente $FF15 [call] e o endereço desta função deste fragmento para o código deste fragmento.
  \ Call [o endereço desta função deste fragmento ]
  \ O código acima gera o código de máquina para uma chamada ao sistema operacional Windows.
  \ O código op é especificado em hexadecimal ($FF15) 
  \ O restante da instrução é o endereço da função da rotina de destino, que é anexado ao código da operação

Rotina para que se transforme um fragmento em código hexadecimal (atribuição de EAX):
  Acrescente $B8 e o sinalizador deste fragmento para o código deste fragmento. \ mov eax,sinalizador
  \ atribuI endereço para edx
\Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável do fragmento.
\Se a variável deste fragmento for inexistente,
  \apresente uma mensagem de erro contendo "Internal erro - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Se o tipo desta variável deste fragmento for inexistente,
  \apresente uma mensagem de erro contendo "Internal erro 2 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4,
  \apresente uma mensagem de erro contendo "Internal erro 3 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

\VERSÃO ANTIGA
\Rotina para que se transforme um fragmento em código hexadecimal (atribuição de EAX):
\Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento.
\Se a variável deste fragmento for inexistente,
  \Apresente uma mensagem de erro contendo 
    \"Internal erro - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
\Se o tipo desta variável deste fragmento for inexistente,
  \Apresente uma mensagem de erro contendo 
    \"Internal erro 2 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
  \Retorne.
 \Se a quantidade de caracteres deste tipo desta variável deste fragmento não for 4,
   \Apresente uma mensagem de erro contendo 
    \"Internal erro 3 - transforme um fragmento em código hexadecimal (atribuição de EAX)";
   \Retorne.
\Acrescente $8B02 para o código deste fragmento. \ mov eax,[edx]

Rotina para que se transforme um fragmento em código hexadecimal (registrador EAX):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento.
  \ atribui o endereço para o registrador edx
  Se a variável deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #190. A variável '" junto com o nome desta variável deste fragmento  \ Erro interno
      seguido de "' não foi encontrada." junto com o texto CRLF;
    Retorne.
  Se o tipo desta variável deste fragmento for inexistente,
    Apresente a mensagem de erro contendo 
      "Código de Erro #191. O tipo '" junto com o nome deste tipo desta variável deste fragmento  \ Erro interno
      seguido de "' da variável '" junto com o nome desta variável deste fragmento 
      seguido de "' não foi encontrado." junto com o texto CRLF;
    Retorne.
  Atribua a quantidade de caracteres deste tipo desta variável deste fragmento para uma quantidade de caracteres.
  \Se a quantidade de caracteres for 8, \ para 64 bits
    \Acrescente $67488902  para o código deste fragmento; \ mov [edx],rax
    \Retorne.   
  Se a quantidade de caracteres for 4,
    Acrescente $8902 para o código deste fragmento; \ mov [edx],eax
    Retorne.
  Se a quantidade de caracteres for 2,
    Acrescente $668902 para o código deste fragmento; \ mov [edx],ax
    Retorne.
  Se a quantidade de caracteres for 1,
    Acrescente $8802 para o código deste fragmento; \ mov [edx],al
    Retorne.
  [Se a quantidade de caracteres não for 1, 2 ou 4] 
    Apresente a mensagem de erro contendo 
      "Código de Erro #192. O tipo '" junto com o tipo desta variável deste fragmento \ Erro interno
      seguido de "deste fragmento possui um tamanho inválido".

Rotina para que se transforme um fragmento em código hexadecimal (Demanda Indireta):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento.
  Acrescente $FF12 para o código deste fragmento. \ call [edx]

Rotina para que se transforme um fragmento em código hexadecimal (endereço de rotina):
  Acrescente a instrução de carregamento de endereço para o código deste fragmento usando a variável deste fragmento.
  \ atribui o endereço para o registrador edx
  Se a rotina deste fragmento for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #193. Rotina não encontrada."
      junto com o texto CRLF; \ Erro interno
    Retorne.
  Obtenha um endereço usando a rotina deste fragmento.
  Acrescente $C702 e o endereço para o código deste fragmento. \ mov [edx],the endereço

\---------------------------------------------------------------------- ROTINAS EXTRAS ---------------------------------------------------------------------

Rotina para que se acrescente um texto hexadecimal e um número e um segundo texto hexadecimal para um terceiro texto hexadecimal:
  Acrescente o texto hexadecimal para o terceiro texto hexadecimal.
  Converta o número para um quarto texto hexadecimal.
  Acrescente o quarto texto hexadecimal para o terceiro texto hexadecimal.
  Acrescente o segundo texto hexadecimal para o terceiro texto hexadecimal.

\------------------------------------------------------------------------------------------------------------------------------------

Rotina para que se compile um endereço da pasta (vinculação): \ #015
  Se existir algum problema de compilação, retorne.
  Escreva "Elencando arquivos.." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de vinculação.
  Vincule.
  Suspenda o temporizador de vinculação.

Rotina para que se vincule:
  Arredonde para cima tamanhos de zona.
  Inicialize um cabeçalho DOS.
  Inicialize um Cabeçalho PE.
  \ Atribua o tamanho do executável deste compilador para um número denominado quantidade de repetições.
  Preencha o trecho EXE deste compilador com o caractere null usando o tamanho do executável deste compilador.
  Disponibilize o cabeçalho DOS ao trecho EXE deste compilador.
  Disponibilize o Cabeçalho PE ao trecho EXE deste compilador.
  Disponibilize as DLLs ao trecho EXE deste compilador.
  Disponibilize as variáveis globais ao trecho EXE deste compilador.
  Disponibilize os valores literais ao trecho EXE deste compilador.
  Disponibilize as rotinas ao trecho EXE deste compilador.

Rotina para que se arredonde tamanhos de zona para cima;
Rotina para que se arredonde para cima tamanhos de zona:
  Atribua a quantidade de caracteres desta seção de DLLs ao tamanho desta seção de DLLs.
  Arredonde para cima o tamanho desta seção de DLLs usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de dados ao tamanho desta região de dados.
  Arredonde para cima o tamanho desta região de dados  usando o múltiplo imediato de 4096.
  Atribua a quantidade de caracteres desta região de código ao tamanho desta região de código.
  Arredonde para cima o tamanho desta região de código  usando o múltiplo imediato de 4096.

Rotina para que se inicialize um cabeçalho DOS: \ vou alterar depois
  Atribua 23117 [$5A4D] ao Signature deste cabeçalho DOS.
  Atribua 64 [$0040] ao AddressOfRelocationTableInFile deste cabeçalho DOS. \ pointer to the table of DLLs needed for this program.
  Atribua 256 [$00000100] ao AddressOfPEHeaderInFile deste cabeçalho DOS. \ pointer to the PE Header,
  \Os 16 camposrestantes  do cabeçalho DOS não são utilizados

Rotina para que se inicialize um Cabeçalho PE:
  Inicialize o Cabeçalho PE (cabeçalho padrão).
  Inicialize o Cabeçalho PE (cabeçalho opcional).
  Inicialize o Cabeçalho PE (informação da versão).
  Inicialize o Cabeçalho PE (diretórios).
  Inicialize o Cabeçalho PE (Seção de DLLs).
  Inicialize o Cabeçalho PE (seção de dados).
  Inicialize o Cabeçalho PE (seção de código).

Rotina para que se inicialize um Cabeçalho PE (cabeçalho padrão):
  Atribua 17744 [$00004550] ao Signature deste Cabeçalho PE. \ -> 50 45 00 00
  Atribua 332 [$014C] ao MachineType deste Cabeçalho PE. \ IMAGE_FILE_MACHINE_I386 
  Atribua 3 [$0003] ao NumberOfSections deste Cabeçalho PE. \ IMAGE_SCN_ALIGN_4BYTES
  Atribua 0 ao TimeStamp deste Cabeçalho PE.
  Atribua 0 ao PointerToSymbolTable deste Cabeçalho PE.
  Atribua 0 ao NumberOfSymbols deste Cabeçalho PE.
  Atribua 224 [$00E0] ao SizeOfOptionalHeaderInBytes deste Cabeçalho PE. \ IMAGE_SCN_ALIGN_8192BYTES
  Atribua 33166 [$818E] às Characteristics deste Cabeçalho PE.

Rotina para que se inicialize um Cabeçalho PE (cabeçalho opcional):
  Atribua 267 [$010B] ao MagicNumber deste Cabeçalho PE.
  \The magic number for PE32+ executables is $020B [523]
  Atribua a quantidade de caracteres desta Região de Código ao SizeOfCodeInFile deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Dados ao SizeOfInitializedDataInFile deste Cabeçalho PE.
  Atribua 0 ao SizeOfUninitializedDataInFile deste Cabeçalho PE.
  Encontre uma rotina usando 
    "~Inicialize antes da execução e Execute o programa e Finalize após execução" e 
    o catálogo geral de rotinas. \ AddressOfEntryPointInMemory
  Se a rotina for inexistente,
    Apresente uma mensagem de erro contendo 
      "Código de Erro #194. A rotina de inicialização do cabeçalho PE não foi encontrada no catálogo geral de rotinas."
      junto com o texto CRLF;   \ Erro interno
    Retorne.
  Atribua o endereço desta rotina menos o image base ao AddressOfEntryPointInMemory deste Cabeçalho PE.
  Atribua o Endereço Base desta Região de Código ao AddressOfCodeInMemory deste Cabeçalho PE. \BaseOfCode
  Atribua o Endereço Base desta Região de Dados ao AddressOfInitializedDataInMemory deste Cabeçalho PE. \BaseOfData
  Atribua o Image Base à ImageBase deste Cabeçalho PE.
  Atribua 4096 [$00001000] ao MemoryAlignment deste Cabeçalho PE. \ 4 KB
  Atribua 4096 [$00001000] ao FileAlignment deste Cabeçalho PE. \ 4 KB.
  \ usado para alinhar os dados brutos das seções no arquivo de imagem.
  \ O valor deve ser uma potência de 2
  Atribua 0 ao Reserved deste Cabeçalho PE.
  Atribua o Tamanho Do Executável deste Compilador ao SizeOfImageInMemory deste Cabeçalho PE.
  Atribua 4096 [section base] ao SizeOfAllHeadersInFile deste Cabeçalho PE. \ 4 KB
  Atribua 0 ao CheckSum deste Cabeçalho PE.
  Atribua 0 para as DLLCharacteristics deste Cabeçalho PE.
  Atribua 1048576 [$00100000] ao MaxStack deste Cabeçalho PE. \ SizeOfStackReserve
  Atribua 16384 [$00004000] ao MinStack deste Cabeçalho PE. \ SizeOfStackCommit
  Atribua 1048576 [$00100000] ao MaxHeap deste Cabeçalho PE. \ SizeOfHeapReserve.
  \ O número de bytes para reservar no heap local
  Atribua 16384 [$00004000] ao MinHeap deste Cabeçalho PE. \ SizeOfHeapCommit.
  \O número de bytes a serem vinculados no heap local.
  Atribua 0 ao LoaderFlags deste Cabeçalho PE. \ Esse membro é obsoleto.

Rotina para que se atribua o tamanho do executável deste compilador para um tamanho:
  Atribua 4096 [section base] ao tamanho.
  Adicione o tamanho desta seção de DLLs para o tamanho.
  Adicione o tamanho desta região de dados para o tamanho.
  Adicione o tamanho desta região de código para o tamanho.

Rotina para que se inicialize um Cabeçalho PE (informação da versão):
  Atribua 0 ao MajorLinkerVersion deste Cabeçalho PE.
  Atribua 0 ao MinorLinkerVersion deste Cabeçalho PE.
  Atribua 4 [$0004] ao OS_MajorVersion deste Cabeçalho PE.
  Atribua 0 [$0000] ao OS_MinorVersion deste Cabeçalho PE.
  Atribua 0 ao UserMajorVersion deste Cabeçalho PE.
  Atribua 0 ao UserMinorVersion deste Cabeçalho PE.
  Atribua 4 [$0004] ao SubsystemMajorVersion deste Cabeçalho PE.
  Atribua 0 [$0000] ao SubsystemMinorVersion deste Cabeçalho PE.
  Atribua 2 [$0002] ao Subsystem deste Cabeçalho PE.

Rotina para que se inicialize um Cabeçalho PE (diretórios):
  Atribua 16 [$00000010] ao NumberOfDirectories deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao ImageDirectoryEntryImportAddress deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao ImageDirectoryEntryImportSize deste Cabeçalho PE.

Rotina para que se inicialize um Cabeçalho PE (Seção de DLLs):
  Atribua "idata " para uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Idata Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInBytes desta Idata Section deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInMemory desta Idata Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta seção de DLLs ao SizeInFile desta Idata Section deste Cabeçalho PE.
  Atribua o endereço base desta seção de DLLs ao AddressInFile desta Idata Section deste Cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta Idata Section deste Cabeçalho PE.
  \ inicializado, legível, gravável

Rotina para que se inicialize um Cabeçalho PE (seção de dados):
  Atribua "data " para uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Data Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta região de dados ao SizeInBytes desta Data Section deste Cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInMemory desta Data Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta região de dados ao SizeInFile desta Data Section deste Cabeçalho PE.
  Atribua o endereço base desta região de dados ao AddressInFile desta Data Section deste Cabeçalho PE.
  Atribua -1073741760 [$C0000040] para as Characteristics desta Data Section deste Cabeçalho PE.
  \ inicializado, legível, gravável

Rotina para que se inicialize um Cabeçalho PE (seção de código):
  Atribua "code  " para uma string.
  Copie bytes desde o caractere inicial desta string para o endereçamento deste nome desta Code Section deste Cabeçalho PE por 6.
  Atribua a quantidade de caracteres desta Região de Código ao SizeInBytes desta Code Section deste Cabeçalho PE.
  Atribua o endereço base desta Região de Código ao AddressInMemory desta Code Section deste Cabeçalho PE.
  Atribua a quantidade de caracteres desta Região de Código  ao SizeInFile desta Code Section deste Cabeçalho PE.
  Atribua o endereço base desta Região de Código ao AddressInFile desta Code Section deste Cabeçalho PE.
  Atribua -536870880 [$E0000020 ] para as Characteristics desta Code Section deste Cabeçalho PE.
  \ executável, legível, gravável, objeto de código
  \IMAGE_FILE_LARGE_ADDRESS_ AWARE 0x0020 - A aplicação pode manipular endereços > que 2 GB.

Rotina para que se disponibilize um cabeçalho DOS para um trecho:
  Disponibilize bytes usando o endereçamento deste cabeçalho DOS e a magnitude deste cabeçalho DOS e o trecho e 0.

Rotina para que se disponibilize bytes usando um ponteiro e uma quantidade de caracteres e um trecho e um deslocamento:
  Atribua o caractere inicial deste trecho mais o deslocamento para um segundo ponteiro.
  Copie bytes desde o ponteiro para o segundo ponteiro pelo quantidade de caracteres.

Rotina para que se disponibilize um Cabeçalho PE para um trecho:
  Disponibilize bytes usando o endereçamento deste Cabeçalho PE e a magnitude deste Cabeçalho PE e o trecho e 256.

Rotina para que se disponibilize umas DLLs para um trecho:
  \Itere.
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Disponibilize a DLL ao trecho.
  Reitere.

Rotina para que se disponibilize uma DLL para um trecho:
  Disponibilize bytes usando 
    o endereçamento deste cabeçalho da DLL desta DLL e 
    a magnitude deste cabeçalho da DLL desta DLL e 
    o trecho e 
    o endereço do cabeçalho desta DLL.
  Disponibilize o nome desta DLL para o trecho sob o endereço do nome desta DLL.
  Disponibilize as funções desta DLL ao trecho.

Rotina para que se disponibilize uma string para um trecho sob um endereço:
  Disponibilize bytes usando o caractere inicial desta string e a quantidade de caracteres desta string e o trecho e o endereço.

Rotina para que se disponibilize umas variáveis para um trecho:
  \Itere.
    Obtenha uma variável desde as variáveis.
    Se a variável for inexistente, retorne.
    Disponibilize a variável ao trecho.
  Reitere.

Rotina para que se disponibilize uma variável para um trecho:
  Se o sinalizador de compilação desta variável não estiver ativo, retorne.
  Se o tipo desta variável puder ser reduzido para "string",
    Disponibilize a variável ao trecho (como um texto);
    Retorne.
  Atribua o endereço desta variável menos o image base para um endereço.
  \ SUGESTÃO Atribua a diferença entre o endereço da variável e a base da imagem para um endereço.
  Disponibilize o data desta variável ao trecho sob o endereço.

Rotina para que se disponibilize uma variável para um trecho (como um texto):
  Atribua o endereço desta variável menos o image base para um endereço.
  Atribua a quantidade de caracteres deste data desta variável para uma quantidade de caracteres.
  Atribua o endereço para um segundo endereço.
  Adicione a magnitude dum protótipo de string para o segundo endereço.
  Adicione a image base para o segundo endereço.
  Atribua 0 ao caractere inicial deste protótipo de string.
  Atribua -1 ao caractere final deste protótipo de string.
  Se a quantidade de caracteres não for 0,
    Atribua o segundo endereço ao caractere inicial deste protótipo de string.
  Se a quantidade de caracteres não for 0,
    Atribua o caractere inicial deste protótipo de string mais a quantidade de caracteres menos 1 ao caractere final deste protótipo de string.
  Disponibilize bytes usando o endereçamento deste protótipo de string e a magnitude deste protótipo de string e o trecho e o endereço.
  Adicione a magnitude [tamanho em bytes] deste protótipo de string para o endereço.
  Disponibilize os data desta variável ao trecho sob o endereço.

Rotina para que se disponibilize umas funções para um trecho:
  \Itere.
    Obtenha uma função desde as funções.
    Se a função for inexistente, retorne.
    Disponibilize a função ao trecho.
  Reitere.

Rotina para que se disponibilize uma função para um trecho:
  Disponibilize bytes usando o endereçamento deste endereço do nome desta função e 4 e o trecho e o endereço thunk desta função.
  Atribua o endereço do nome desta função mais 2 para um endereço.
  Disponibilize o nome desta função ao trecho sob o endereço.

Rotina para que se disponibilize umas rotinas para um trecho:
  \Itere.
    Obtenha uma rotina desde as rotinas.
    Se a rotina for inexistente, retorne.
    Disponibilize a rotina ao trecho.
  Reitere.

Rotina para que se disponibilize uma rotina para um trecho:
  Se o sinalizador de compilação desta rotina não estiver ativo, retorne.
  Disponibilize os fragmentos desta rotina ao trecho.

Rotina para que se disponibilize uns fragmentos para um trecho:
  \Itere.
    Obtenha um fragmento desde o fragmentos.
    Se o fragmento for inexistente, retorne.
    Disponibilize o fragmento ao trecho.
  Reitere.

Rotina para que se disponibilize um fragmento para um trecho:
  Se o código deste fragmento estiver em branco, retorne.
  Atribua o endereço deste fragmento menos o image base para um endereço.
  Disponibilize o código deste fragmento ao trecho sob o endereço.

\------------------------------------------------------------------------------------------------------------------------------------

Rotina para que se compile um endereço da pasta (etapa final): \ #016
  Se existir algum problema de compilação, retorne.
  Escreva "Gerando arquivo executável..." junto com o texto CRLF para o painel de informações.
  Comece o temporizador de escrita.
  Escreva o trecho EXE deste compilador para o endereço EXE completo deste compilador.
  \Se o erro do fluxo de entrada/saída não estiver em branco,
    \Apresente uma mensagem de erro contendo o erro do fluxo de entrada/saída.
  Se o erro do fluxo de entrada/saída não estiver em branco,
    Escreva o erro do fluxo de entrada/saída para o painel de informações.
  Suspenda o temporizador de escrita.

Rotina para que se atribua o endereço EXE completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remova alguma barra invertida final desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".exe" ao endereço completo.
  

Rotina para que se compile um endereço da pasta (interrupção): \ #017
  Suspenda o temporizador deste compilador.
  Escreva "---------------------------------------" junto com o texto CRLF para o painel de informações.


\ ------------------------------------------------------------- ROTINAS EXTRAS ---------------------------------------------------------------------------------------------

Rotina para que se acrescente uma função para um trecho (com separador):
  Se a função for inexistente,
    Acrescente "(entrada não inicializada)" para o trecho (com separador);
    Retorne.
  Acrescente o nome desta função para o trecho (com separador).

Rotina para que se acrescente um sinalizador para um trecho (com separador):
  Converta o sinalizador para uma string.
  Acrescente a string para o trecho (com separador).

Rotina para que se acrescente um número para um trecho (cifra hexadecimal com separador):
  Converta o número para uma cifra hexadecimal.
  Acrescente a cifra hexadecimal para o trecho (com separador).

Rotina para que se acrescente um número para um trecho (com separador):
  Converta o número para uma string.
  Acrescente a string para o trecho (com separador).

Rotina para que se acrescente uma proporção para um trecho (com separador):
  Converta a proporção para uma string.
  \ Se a string for "0", acrescente "---" para o trecho; Retorne.
  Acrescente a string para o trecho (com separador).

Rotina para que se acrescente uma rotina para um trecho (com separador):
  Se a rotina for inexistente,
    Acrescente "(rotina inexistente)" para o trecho (com separador);
    Retorne.
  Acrescente a representação interna da rotina deste rotina para o trecho (com separador).

Rotina para que se acrescente uma string para um trecho (com separador):
  Acrescente a string para o trecho.
  Acrescente " | " para o trecho.

Rotina para que se acrescente uma etiqueta para um trecho (geral):
  Se a etiqueta for a etiqueta de interrupção,
    Acrescente "Interrupção do Laço" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de demanda externa,
    Acrescente "Demanda Externa" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de demanda indireta,
    Acrescente "Demanda Indireta" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de demanda interna,
    Acrescente "Demanda Interna" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de redirecionamento,
    Acrescente "Redirecionamento" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta delimitadora de bloco condicional,
    Acrescente "Fim de bloco condicional" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta conclusiva,
    Acrescente "Epílogo" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de retorno,
    Acrescente "Retorno de Rotina" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de finalização,
    Acrescente "Finalização" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de acréscimo,
    Acrescente "Incremento" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de decodificação,
    Acrescente "Decodificação" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de desvio falso,
    Acrescente "Desvio de condição insatisfeita" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de carregamento de endereço,
    Acrescente "Carregamento de endereço" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de carregamento de registrador EAX,
    Acrescente "Atribuição EAX" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de laço,
    Acrescente "Loop" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de negação lógica,
    Acrescente "Negação Lógica" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta preliminar,
    Acrescente "Prólogo" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de inserção de endereço [na stack],
    Acrescente "Empilhamento de endereço" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de inserção de valor [na stack],
    Acrescente "Empilhamento de valor" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de obtenção do registrador EAX,
    Acrescente "Requisição EAX" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de repetição,
    Acrescente "Repetição" para o trecho (com separador);
    Retorne.
  Se a etiqueta for a etiqueta de endereço de rotina,
    Acrescente "Endereço de Rotina" para o trecho (com separador);
    Retorne.
  \ Se a etiquete for outra etiqueta,
  Acrescente "?" para o trecho (com separador).

Rotina para que se acrescente um tipo para um trecho (com separador):
  Se o tipo for inexistente,
    Acrescente "(tipo não inicializado)" para o trecho (com separador);
    Retorne.
  Acrescente o nome deste tipo para o trecho (com separador).

Rotina para que se acrescente uma variável para um trecho (com separador):
  Se a variável for inexistente,
    Acrescente "(variável não inicializada)" para o trecho (com separador);
    Retorne.
  Acrescente o nome desta variável para o trecho (com separador).

\Rotina para que se inicialize o compilador:
\Rotina em branco. Serve apenas para fazer com que o código fique "simétrico"

Rotina para que se liste tudo:
  Limpe o trecho de listagem deste compilador.
  Liste a mensagem de erro deste compilador na trecho de listagem deste compilador.
  Liste os tipos depois de "TIPOS:" na trecho de listagem deste compilador.
  Liste as variáveis globais depois de "VARIÁVEIS GLOBAIS:" na trecho de listagem deste compilador.
  Liste os valores literais depois de "VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste as rotinas depois de "ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de tipos depois de "ÍNDICE DE TIPOS:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis globais depois de "ÍNDICE GLOBAL:" na trecho de listagem deste compilador.
  Liste o catálogo de variáveis hexadecimais depois de "ÍNDICE DE VALORES LITERAIS:" na trecho de listagem deste compilador.
  Liste o catálogo geral de rotinas depois de "ÍNDICE DE ROTINAS:" na trecho de listagem deste compilador.
  Liste o catálogo de rotinas úteis depois de "Catálogo de Rotinas Úteis:" na trecho de listagem deste compilador.
  Liste as DLLs depois de "DLL's:" na trecho de listagem deste compilador.
  Liste os arquivos fontes depois de "ARQUIVOS FONTE:" na trecho de listagem deste compilador.
  Liste os temporizadores depois de "TEMPORIZADORES:" na trecho de listagem deste compilador.
  Escreva o trecho de listagem deste compilador para o listagem endereço completo deste compilador.

Rotina para que se atribua o listagem endereço completo deste compilador para um endereço completo:
  Extraia um designador desde o endereço da pasta deste compilador.
  Remova alguma barra invertida final desde o designador.
  Atribua o endereço da pasta deste compilador junto com o designador seguido de ".lst" ao endereço completo.

Rotina para que se liste um mensagem de erro em um trecho:
  Se o mensagem de erro estiver em branco, retorne.
  Acrescente "COMPILAÇÃO INTERROMPIDA - LISTAGEM INCOMPLETA" para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Acrescente o mensagem de erro para o trecho.
  Insira quebra de linha no trecho (duas vezes).

Rotina para que se liste um recipiente em um trecho:
  Se as referências deste recipiente estiverem vazios, retorne.
  Acrescente "| RECIPIENTE" para o trecho (com separador).
  Insira quebra de linha no trecho.
  Liste as referências deste recipiente no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas funções em um trecho:
  Obtenha uma função desde as funções.
  Se a função for inexistente, retorne.
  Liste a função no trecho.
  Reitere.

Rotina para que se liste uma função em um trecho:
  Se a função for inexistente, retorne.
  Acrescente "| FUNÇÃO" para o trecho (com separador).
  Acrescente o nome desta função para o trecho (com separador).
  Acrescente o endereço desta função para o trecho (cifra hexadecimal com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste um fragmento em um trecho:
  Acrescente "| FRAGMENTO" para o trecho (com separador).
  Acrescente a etiqueta deste fragmento para o trecho (geral).
  Acrescente "Variável principal: " para o trecho.
  Acrescente a variável deste fragmento para o trecho (com separador).
  Acrescente "Variável secundária: " para o trecho.
  Acrescente a segunda variável deste fragmento para o trecho (com separador).
  Acrescente "Rotina: " para o trecho.
  Acrescente a rotina deste fragmento para o trecho (com separador).
  Acrescente "Entrada: " para o trecho.
  Acrescente a função desta fragmento para o trecho (com separador).
  Acrescente "Número hexadecimal: " para o trecho.
  Acrescente o número deste fragmento para o trecho (cifra hexadecimal com separador).
  Acrescente "Endereço: " para o trecho.
  Acrescente o endereço deste fragmento para o trecho (cifra hexadecimal com separador).
  Converta o código deste fragmento para uma cifra hexadecimal.
  Acrescente "Código compilado: " para o trecho.
  Acrescente a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste uns fragmentos em um trecho:
  Obtenha um fragmento desde o fragmentos.
  Se o fragmento for inexistente, retorne.
  Liste o fragmento no trecho.
  Reitere.

Rotina para que se liste uma DLL em um trecho:
  Se a DLL for inexistente, retorne.
  Acrescente "| DLL" para o trecho (com separador).
  Acrescente o nome desta DLL para o trecho (com separador).
  Insira quebra de linha no trecho.
  Liste as funções desta DLL no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas DLLs em um trecho:
    Obtenha uma DLL desde as DLLs.
    Se a DLL for inexistente, retorne.
    Liste a DLL no trecho.
  Reitere.

Rotina para que se liste umas DLLs depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se as DLLs estiverem vazios, retorne.
  Liste as DLLs no trecho.

Rotina para que se liste um catálogo em um trecho:
  Acrescente "| " junto com o used contagem de recipientes deste catálogo seguido de " recipientes" para o trecho (com separador).
  Acrescente a contagem deste catálogo seguido de " referências" para o trecho (com separador).
  Insira quebra de linha no trecho (duas vezes).
  Itere.
    Obtenha um recipiente usando o catálogo.
    Se o recipiente for inexistente, retorne.
    Liste o recipiente no trecho.
  Reitere.

Rotina para que se liste um catálogo depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se o catálogo estiver vazio, retorne.
  Liste o catálogo no trecho.

Rotina para que se liste uma referência em um trecho:
  Se a referência for inexistente, retorne.
  Acrescente "| REFERÊNCIA" para o trecho (com separador).
  Acrescente a string deste referência para o trecho.
  Se o ponteiro deste referência for inexistente,
    Acrescente " (ponteiro inexistente) " para o trecho.
  Acrescente "| " para o trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas referências em um trecho:
  Obtenha uma referência desde as referências.
  Se a referência for inexistente, retorne.
  Liste a referência no trecho.
  Reitere.

Rotina para que se liste uma rotina em um trecho:
  Se a rotina for inexistente, retorne.
  Acrescente "| ROTINA: " para o trecho.
  Acrescente a representação interna da rotina desta rotina para o trecho (com separador). \ por exemplo: atribua [matiz] e [saturação] e [luminosidade] para [cor]
  Acrescente o texto CRLF para o trecho.
  Acrescente "| compilada: " para o trecho .
  Acrescente o sinalizador de compilação desta rotina para o trecho (com separador). \ A rotina foi compilada? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| callback: " para o trecho.
  Acrescente o sinalizador de compatibilidade desta rotina para o trecho (com separador). \ A rotina é um callback? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| decisora: " para o trecho.
  Acrescente o sinalizador de deliberação desta rotina para o trecho (com separador). \ A rotina é uma rotina decisora? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| função: " para o trecho.
  Acrescente o sinalizador de função desta rotina para o trecho (com separador). \ A rotina é uma função ? SIM / NÃO
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Employs utilizados: |    " para o trecho.
  Acrescente o representação de emprego desta rotina para o trecho (com separador).
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Tamanho dos parâmetros: " para o trecho.
  Acrescente o tamanho do parâmetro desta rotina para o trecho (com separador). \ Tamanho dos parâmetros. Exemplo: 16 ( 4 parâmetros)
  Acrescente " Tamanho das variáveis: " para o trecho.
  Acrescente o tamanho local desta rotina para o trecho (com separador). \Tamanho da variável local. Exemplo: 28
  Acrescente o texto CRLF para o trecho.
  Acrescente "| Endereço da Rotina: " para o trecho.
  Acrescente o endereço desta rotina para o trecho (cifra hexadecimal com separador). \ Endereço da rotina, Exemplo: 0041D000
  Insira quebra de linha no trecho.
  Liste os parâmetros desta rotina no trecho.
  Liste as variáveis locais desta rotina no trecho.
  Liste os fragmentos desta rotina no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste umas rotinas em um trecho:
  Obtenha uma rotina desde as rotinas.
  Se a rotina for inexistente, retorne.
  Liste a rotina no trecho.
  Reitere.

Rotina para que se liste umas rotinas depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se as rotinas estiverem vazias, retorne.
  Liste as rotinas no trecho.

Rotina para que se liste um arquivo fonte em um trecho:
  Se o arquivo fonte for inexistente, retorne.
  Acrescente "| ARQUIVO FONTE" para o trecho (com separador).
  Acrescente o endereço completo deste arquivo fonte para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste uns arquivos fontes em um trecho:
  Obtenha um arquivo fonte desde os arquivos fontes.
  Se o arquivo fonte for inexistente, retorne.
  Liste o arquivo fonte no trecho.
  Reitere.

Rotina para que se liste uns arquivos fontes depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se os arquivos fontes estiverem vazios, retorne.
  Liste os arquivos fontes no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste um temporizador usando uma string em um trecho:
  Acrescente "| TEMPORIZADOR" para o trecho (com separador).
  Acrescente a string para o trecho (com separador).
  Acrescente a string deste temporizador para o trecho.
  Acrescente " milissegundos" para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste os temporizadores depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Liste o temporizador de operacionalização usando "Tempo de carregamento: " no trecho.
  Liste o temporizador de análise/verificação usando "Tempo de verificação: " no trecho.
  Liste o temporizador de resolução de tipos usando "Resolução de tipos: " no trecho.
  Liste o temporizador de resolução de variáveis globais usando "Resolução de variáveis globais: " no trecho.
  Liste o temporizador de compilação de cabeçalhos de rotina usando "Compilação de cabeçalhos de rotinas: " no trecho.
  Liste o temporizador de etapas de cálculo usando "Cálculos matemáticos: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de mémoria  usando "Inclusão de rotinas pré-definidas: " no trecho.
  Liste o temporizador de ferramentas de catalogação usando "Catalogação de ferramentas: " no trecho.
  Liste o temporizador de compilação do conteúdo das rotinas usando "Compilação de rotinas: " no trecho.
  Liste o temporizador de adição de rotinas pré-definidas de inicialização usando "Inserção rotina de inicialização:" no trecho.
  Liste o temporizador de deslocamentos usando "Alinhamento de bytes na memória: " no trecho.
  Liste o temporizador de endereçamento usando "Endereçamento: " no trecho.
  Liste o temporizador de transmutação usando "Conversão em binário" no trecho.
  Liste o temporizador de vinculação usando "Vinculação: " no trecho.
  Liste o temporizador de escrita usando "Escrita e gravação no SO: " no trecho.
  Liste o temporizador deste compilador usando "Tempo total: " no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste um tipo em um trecho:
  Se o tipo for inexistente, retorne.
  Acrescente "| TIPO" para o trecho (com separador).
  Acrescente o nome deste tipo para o trecho (com separador).
  Acrescente " Plural: " para o trecho.
  Acrescente o nome plural deste tipo para o trecho (com separador).
  Acrescente " Comprimento: " para o trecho.
  Acrescente a quantidade de caracteres deste tipo para o trecho (cifra hexadecimal com separador).
  Acrescente " Tipo: " para o trecho.
  Acrescente o nome do tipo primitivo deste tipo para o trecho (com separador).
  Acrescente " Tipo base: " para o trecho.
  Acrescente o tipo base deste tipo para o trecho (com separador).
  Acrescente o nome do conteúdo deste tipo para o trecho (com separador).
  Acrescente o tipo do conteúdo deste tipo para o trecho (com separador).
  Acrescente " Razão de escala: " para o trecho.
  Acrescente a razão de escala deste tipo para o trecho (com separador).
  Insira quebra de linha no trecho.
  Liste os campos deste tipo no trecho.
  Insira quebra de linha no trecho.

Rotina para que se liste uns tipos em um trecho:
  Obtenha um tipo desde o tipos.
  Se o tipo for inexistente, retorne.
  Liste o tipo no trecho.
  Reitere.

Rotina para que se liste uns tipos depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se os tipos estiverem vazios, retorne.
  Liste os tipos no trecho.

Rotina para que se liste uma variável em um trecho:
  Se a variável for inexistente, retorne.
  Acrescente "| VARIÁVEL" para o trecho (com separador).
  Acrescente "Categoria: " para o trecho.
  Acrescente a categoria desta variável para o trecho (com separador).
  Acrescente "Compilada: " para o trecho.
  Acrescente o sinalizador de compilação desta variável para o trecho (com separador).
  Acrescente "Nome completo: " para o trecho.
  Acrescente o nome desta variável para o trecho (com separador).
  Acrescente "Nome resumido: " para o trecho.
  Acrescente o apelido desta variável para o trecho (com separador).
  Acrescente "Nome do tipo: " para o trecho.
  Acrescente o nome do tipo desta variável para o trecho (com separador).
  Acrescente "Tipo: " para o trecho.
  Acrescente o tipo desta variável para o trecho (com separador).
  Acrescente "Endereço (deslocamento): " para o trecho.
  Acrescente o endereço desta variável [or deslocamento] para o trecho (cifra hexadecimal com separador).
  Acrescente "Passagem por valor? " para o trecho.
  Acrescente o sinalizador de passagem por-valor desta variável para o trecho (com separador).
  Acrescente "Contagem: " para o trecho.
  Acrescente a contagem desta variável para o trecho (com separador).
  Acrescente "Referência: " para o trecho.
  Acrescente o sinalizador de referência desta variável para o trecho (com separador).
  Acrescente "Redefinição: " para o trecho.
  Acrescente o novo nome desta variável para o trecho (com separador).
  Acrescente "Conteúdo: " para o trecho.
  Acrescente o valor literal desta variável para o trecho (com separador).
  Converta o data desta variável para uma cifra hexadecimal.
  Acrescente "Conteúdo (valores hexadecimais): " para o trecho.
  Acrescente a cifra hexadecimal para o trecho (com separador).
  Insira quebra de linha no trecho.

Rotina para que se liste umas variáveis em um trecho:
  Obtenha uma variável desde as variáveis.
  Se a variável for inexistente, retorne.
  Liste a variável no trecho.
  Reitere.

Rotina para que se liste umas variáveis depois de uma string em um trecho:
  Acrescente a string para o trecho.
  Insira quebra de linha no trecho (duas vezes).
  Se as variáveis estiverem vazias, retorne.
  Liste as variáveis no trecho.
  Insira quebra de linha no trecho.

Função para que se determine se uma string é algum decisor literal negativo:
  Se a string for "não", diga sim.
  Se a string for "negativo", diga sim.
  Se a string for "negativamente", diga sim.
  Diga não.

Função para que se determine se uma string é algum número ordinal:
  Se a string estiver em branco, diga não.
  Se o conteúdo deste caractere final desta string for o indicador ordinal masculino, diga sim.
  Se o conteúdo deste caractere final desta string for o indicador ordinal feminino, diga sim.
  Diga não.

Função para que se determine se uma string é algum pronome demonstrativo:
  Se a string for algum pronome demonstrativo adjacente, diga sim.
  Se a string for algum pronome demonstrativo abrangente, diga sim.
  Diga não.

Função para que se determine se uma string é alguma preposição:
  Se a string for "partir", diga sim.
  Se a string for "partindo", diga sim.
  Se a string for "aproximadamente", diga sim.
  Se a string for "através", diga sim.
  Se a string for "after", diga sim.
  \Se a string for "all", diga sim.
  Se a string for "alone", diga sim.
  Se a string for "algum", diga sim.
  \Se a string for "as", diga sim.
  Se a string for "sob", diga sim.
  Se a string for "backward", diga sim.
  Se a string for "regressivamente", diga sim.
  Se a string for "backwards", diga sim.
  Se a string for "entre", diga sim.
  Se a string for "aproada", diga sim.
  Se a string for "aproado", diga sim.
  Se a string for "aproando", diga sim.
  Se a string for "orientada", diga sim.
  Se a string for "orientado", diga sim.
  Se a string for "orientando", diga sim.
  Se a string for "orientando-se", diga sim.
  Se a string for "virada", diga sim.
  Se a string for "virado", diga sim.
  Se a string for "virando", diga sim.
  Se a string for "virando-se", diga sim.
  \Se a string for "for", diga sim.
  Se a string for "por", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "tão", diga sim.
  Se a string for "quão", diga sim.
  Se a string for "tanto", diga sim.
  Se a string for "quanto", diga sim.
  Se a string for "dentro", diga sim.
  Se a string for "em comprimento", diga sim.
  Se a string for "d'", diga sim.
  Se a string for "d'", diga sim.
  Se a string for "referente", diga sim.
  Se a string for "pertencente", diga sim.
  Se a string for "pertinente", diga sim.
  Se a string for "somente", diga sim.
  Se a string for "apenas", diga sim.
  Se a string for "só", diga sim.
  Se a string for "exclusivamente", diga sim.
  Se a string for "fora", diga sim.
  \Se a string for "sobre", diga sim.
  Se a string for "pointing", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "retornando", diga sim.
  Se a string for "começando", diga sim.
  Se o subtexto for "começando", diga sim.
  Se o subtexto for "iniciando", diga sim.
  Se a string for "usando", diga sim.
  Se a string for "via", diga sim.
  Se a string for "com", diga sim.
  Se a string for "dentre", diga sim.
  Se a string for "depois", diga sim. \ depois de
  Se a string for "desde", diga sim.
  Se a string for "aproximadamente", diga sim.
  Se a string for "cerca", diga sim.
  Diga não.

Função para que se determine se uma string é algum possessivo reverso:
  Se a string for "de", diga sim.
  \Se a string for "do", diga sim. \ short por "de o", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
  Diga não.

Função para que se determine se um percorredor está sobre ("de" como preposição):
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for "de", diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for algum artigo, diga sim.
  Diga não.

Função para que se determine se um percorredor está sobre alguma locução prepositiva:
  Preserve o percorredor.
  Se o segmento inicial deste percorredor não for alguma locução prepositiva diga não.
  Mova o percorredor (usando diretrizes de compilação).
  Se o segmento inicial deste percorredor for "de", diga sim.
  Se o segmento inicial deste percorredor for "do", diga sim.\ Se o segmento inicial deste percorredor for "do", atribua "o" para o segmento inicial deste percorredor original; diga sim.
  Se o segmento inicial deste percorredor for "dos", diga sim.
  Se o segmento inicial deste percorredor for "da", diga sim.
  Se o segmento inicial deste percorredor for "das", diga sim.
  Diga não.

Função para que se determine se uma string é alguma locução prepositiva:
  Se a string for alguma preposição, diga sim.
  Diga não.

Função para que se determine se uma string é alguma palavra ignorável:
  Se a string for "já", diga sim.
  Se a string for "ainda", diga sim.
  \Se a string for "que", diga sim.
  \Se a string for "se", diga sim.
  Diga não.

Função para que se determine se um byte é alguma vogal acentuada:
  Se o byte estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim.
  Diga não.

Rotina para que se encontre uma rotina usando uma string e um tipo:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.

Rotina para que se encontre uma rotina usando uma string e um tipo e uma segunda string e uma terceira string e uma quarta string e uma quinta string:
  Adicione uma unidade semântica para umas unidades semânticas usando a string.
  Adicione uma segunda unidade semântica para as unidades semânticas usando o tipo.
  Adicione uma terceira unidade semântica para as unidades semânticas usando a segunda string.
  Adicione uma quarta unidade semântica para as unidades semânticas usando a terceira string.
  Adicione uma quinta unidade semântica para as unidades semânticas usando a quarta string.
  Adicione uma sexta unidade semântica para as unidades semânticas usando a quinta string.
  Encontre a rotina usando as unidades semânticas.
  Destrua as unidades semânticas.


Rotina para que se mova um percorredor (símbolos):
  Avance o percorredor.

\Função para que se determine se uma string looks like English:
\Carregue o dicionário léxico.
\Se o dicionário léxico for inexistente, Mostre na tela "Não foi possível encontrar o dicionário léxico."; diga não.
\Se a string estiver em branco, diga não.
\Lance um subtexto sobre a string.
\Atribua o caractere final deste subtexto ao caractere inicial deste subtexto.
\Itere.
  \Se o caractere inicial deste subtexto é o caractere inicial desta string, pare.
  \Se o target deste caractere inicial deste subtexto for o caractere de espaço, adicione 1 para o caractere inicial deste subtexto; pare.
  \Subtraia 1 desde o caractere inicial deste subtexto.
\Reitere.
\Se o subtexto estiver no catálogo deste dicionário léxico, diga sim.
\Diga não.

\ Rotina para que se pluralize uma string:
  \ Lance um percorredor sobre a string.
  \Atribua "" para uma string denominada string plural.
  \ Itere.
    \ Mova o percorredor (usando diretrizes de compilação).
    \ Se o segmento inicial deste percorredor estiver em branco, pare.
    \Se a string plural não estiver em branco,
    \ Se uma string plural não estiver em branco,
      \ Acrescente " " para a string plural.
    \ Acrescente o segmento inicial deste percorredor para a string plural.
    \ Se o segmento inicial deste percorredor for "de",
      \ Ative um sinalizador;
      \ Reitere. \\ PLURAL
    \ Se o sinalizador não estiver ativo,
      \ Pluralize a string plural (português - regras comuns).
  \ Reitere.
  \ Atribua a string plural à string.


\finalmente  acabou

\------------------------------------------------------------------------------------------------------------------------------------

