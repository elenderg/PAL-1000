\ o compilador copyright © 2006-2021 a ordem osmosiana

\ firstparam=esp+4/ebp+8, secondparam=esp+8/ebp+12, etc...

Uma mensagem de erro é um string.

O compilador é um conjunto com
Um endereço da pasta,
Um temporizador,
\\Um abort detector,
Um detector de erros, \new line
Um mensagem de erro,
Um endereço completo do arquivo de erro,
Um número da linha de erro,
Um nome contagem,
Um trecho exe,
Um listagem trecho.

Etapas necessárias para que se apresente uma mensagem de erro contendo um string:
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de erros deste compilador.
Atribua o string à mensagem de erro deste compilador.

Etapas necessárias para que se apresente uma mensagem de erro contendo um string e um endereço de memória do pedaço:
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de erros deste compilador.
Atribua o string à mensagem de erro deste compilador.
Encontre o endereço completo do arquivo de erro deste compilador e o número da linha de erro deste compilador usando o endereço de memória do pedaço .
Se o endereço completo do arquivo de erro deste compilador estiver em branco, cancele.
Extract um nome do arquivo from o endereço completo do arquivo de erro deste compilador.
Anteponha "Erro no " seguido de o nome do arquivo seguido de ". " para a mensagem de erro deste compilador.

Etapas necessárias para que se apresente uma mensagem de erro contendo um string e um percorredor:
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo o string e o first deste token deste percorredor; exit.
Apresente a mensagem de erro contendo o string e o last deste source deste percorredor.

Etapas necessárias para que se adicione as rotinas de alocação e desalocação e finalização e destruição:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Adicione a finalize routine pelo type.
Adicione a rotina de alocação para o type.
Adicione a rotina de desalocação para o type.
Adicione a destrua routine pelo type.
Repita.

Etapas necessárias para que se adicione o rotina de alocação para um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine para as routines usando nil.
Posponha "Aloque memória para um " seguido de o nome deste type para o header string desta routine. \ traduzir aqui
Posponha "Assign o " seguido de o nome deste type seguido de " usando " para o body string desta routine. \Nomeie
Posponha o length deste target type deste type seguido de "." para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione e compile o initialize before run e run e finalize after run routine:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma routine para as routines usando nil.
Posponha "~initialize before run e run e finalize after run" para o header string desta routine.
Posponha "initialize before run. " para o body string desta routine.
Posponha o global initializers para o body string desta routine.
Posponha "nosso programa seja executado. " para o body string desta routine. \ traduzir
Posponha o global finalizers para o body string desta routine.
Posponha "finalize after run. " para o body string desta routine.
Posponha "call ""kernel32.dll"" ""ExitProcess"" com 0. " para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.
Compile o body of a routine.

Etapas necessárias para que se adicione o built-in types:
Adicione um built-in type usando "byte" e "bytes" e 1. \ que tal octeto?
Adicione um segundo built-in type usando "record" e "records" e 0.
Adicione um terceiro built-in type usando "pedaço" e "pedaços" e 1.
Adicione um quarto built-in type usando "conjunto" e "conjuntos" e 0.

Etapas necessárias para que se adicione um built-in type usando um nome e um plural nome e um length:
Adicione o built-in type para os types usando o nome e o plural nome e o nome.
Atribua o length ao length deste built-in type.
Atribua o built-in type ao base type deste built-in type.
Catalogue o built-in type.

Etapas necessárias para que se adicione o rotina de desalocação para um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", cancele.
Se o target type deste type for inexistente, cancele.
Adicione uma routine para as routines usando nil.
Posponha "Desaloque um " seguido de o nome deste type para o header string desta routine.
Posponha "Se o " seguido de o nome deste type seguido de " for inexistente, cancele. " para o body string desta routine.
Se o target type deste type deveria ser [estar] finalizado, posponha "~finalize o " seguido de o nome deste type seguido de "'s target. " para o body string desta routine.
Posponha "Unassign o " seguido de o nome deste type seguido de "." para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o destrua routine por um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não deveria ser ignorado, cancele.
Se o type puder ser reduzido para "coisas", adicione o destrua routine pelo type (coisas); exit.
Se o type puder ser reduzido para "endereço de memória", adicione o destrua routine pelo type (endereço de memória); exit.

Etapas necessárias para que se adicione o destrua routine por um type (endereço de memória):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua "Destrua [" seguido de o nome deste type seguido de "]" para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, cancele.
Adicione uma routine para as routines usando nil.
Posponha "Destrua um " seguido de o nome deste type para o header string desta routine.
Posponha "Se o " seguido de o nome deste type seguido de " for inexistente, cancele. " para o body string desta routine.
Se o target type deste type puder ser reduzido para "endereço de memória", posponha "Destrua o " seguido de o nome deste type seguido de "'s target. " para o body string desta routine.
Se o target type deste type puder ser reduzido para "coisas", posponha "Destrua o " seguido de o nome deste type seguido de "'s target. " para o body string desta routine.
Percorra.
Obtenha um campo from os campos deste target type deste type.
Se o campo for inexistente, pare.
Se o reference detector deste campo estiver ativo, repita.
Se o type deste campo não deveria ser ignorado, repita.
Posponha "Destrua o " seguido de o nome deste type seguido de "'s " seguido de o nome deste campo seguido de ". " para o body string desta routine.
Repita.
Posponha "Desaloque o " seguido de o nome deste type seguido de ". " para o body string desta routine. \ traduzir aqui
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione o destrua routine por um type (coisas):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
\Atribua "Erro interno na hora de executar a tarefa de destruição de tipos" à reply.
Se o first destes campos deste type for inexistente, apresente uma mensagem de erro contendo "Erro interno no campo do tipo. Veja rotina 'adicione um forget routine por um type (coisas)'"; [Say o reply;] exit. \Adicionado Say o reply
Se o type deste first destes campos deste type for inexistente, apresente a mensagem de erro contendo "Erro interno no tipo do campo. Consulte a rotina 'adicione o forget routine por um type (coisas)'"; exit.
Atribua "Destrua [" seguido de o nome deste type seguido de "]" para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, cancele.
Adicione uma routine para as routines usando nil.
Posponha "Destrua um " seguido de o nome deste type para o header string desta routine.
Posponha "Se o " seguido de o nome deste type seguido de "'s first for inexistente, cancele. " para o body string desta routine.
Atribua o nome deste type deste first destes campos deste type para um nome.
Posponha "Atribua o " seguido de o nome deste type seguido de "'s first para um " seguido de o nome seguido de ". " para o body string desta routine.
Posponha "Remove o " seguido de o nome seguido de " from o " seguido de o nome deste type seguido de ". " para o body string desta routine.
Posponha "Destrua o " seguido de o nome seguido de ". " para o body string desta routine.
Posponha "Repeat. " para o body string desta routine.
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione um entry para alguns imports usando um import nome e um entry nome:
Encontre um import usando o import nome.
Se o import for inexistente, adicione o import para o imports usando o import nome.
Encontre a entry usando a entry nome e as entries deste import.
Se a entry não for inexistente, cancele.
Crie o entry.
Posponha a entry para as entries deste import.
Atribua a entry nome ao nome desta entry.

Etapas necessárias para que se adicione um campo para alguns campos usando um nome e um nickname e um type nome e um reference detector:
Adicione o campo para o campos usando "campo" e nil.
Atribua o nome ao nome deste campo.
Atribua o nickname ao nickname deste campo.
Atribua o type nome ao type nome deste campo.
Atribua o reference detector ao reference detector deste campo.

Etapas necessárias para que se adicione a finalize routine por um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não deveria ser [estar] finalizado, cancele.
Se o nome deste type for "string", adicione a finalize routine pelo type (string); exit.
Se o type puder ser reduzido para "string", cancele. \ prevents generation of finalizer por derived string types
Adicione a finalize routine pelo type (conjunto).

Etapas necessárias para que se adicione a finalize routine por um type (conjunto):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma routine para as routines usando nil.
Posponha "~finalize um " seguido de o nome deste type para o header string desta routine.
Posponha "Intel $50. " para o body string desta routine. \ push eax
Percorra.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, pare.
Se o type deste campo não deveria ser [estar] finalizado, repita.
Posponha "~finalize o " seguido de o nome deste type seguido de "'s " seguido de o nome deste campo seguido de ". " para o body string desta routine.
Repita.
Posponha "Intel $58." para o body string desta routine. \ pop eax
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione a finalize routine por um type (string):
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma routine para as routines usando nil.
Posponha "~finalize um " seguido de o nome deste type para o header string desta routine.
Posponha "Intel $50. " para o body string desta routine. \ push eax
Posponha "unassign o string's first. " para o body string desta routine. \\ traduzir string aqui
Posponha "Intel $58." para o body string desta routine. \ pop eax
Lance a routine header desta routine sobre o header string desta routine.
Lance as instruções desta routine sobre o body string desta routine.
Compile o header of a routine.

Etapas necessárias para que se adicione um fragment usando uma tag:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.

Etapas necessárias para que se adicione um fragment usando uma tag e um entry:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a entry à entry deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e um detector:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o detector ao detector deste fragment.

Etapas necessárias para que se adicione um fragment usando uma tag e uma routine:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua a routine à routine deste fragment.
Compile o body of a routine.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variável:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o variável ao variável deste fragment.
Ligue o compiled detector no variável.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variável e uma segunda variável:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o variável à variável deste fragment.
Atribua a segunda variável ao segunda variável deste fragment.
Ligue o compiled detector no variável.
Ligue o compiled detector no segunda variável.

Etapas necessárias para que se adicione um fragment usando uma tag e uma variável e um número:
Se a rotina utilizada atualmente for inexistente, esvazie o fragment; exit.
Crie o fragment usando o tag.
Posponha o fragment para os fragments desta rotina utilizada atualmente.
Atribua o variável à variável deste fragment.
Atribua o número ao número deste fragment.
Ligue o compiled detector no variável.

Etapas necessárias para que se adicione um import para alguns imports usando um import nome:
Crie o import.
Posponha o import para o imports.
Atribua o import nome ao nome deste import.

Etapas necessárias para que se adicione um intermediate usando um type nome e um local de aparição:
Se a rotina utilizada atualmente for inexistente, esvazie o intermediate; exit.
Adicione o intermediate para os locals desta rotina utilizada atualmente usando "local" e o local de aparição.
Gere o nome deste intermediate usando "~I".
Atribua o type nome ao type nome deste intermediate.
Resolva o intermediate.

Etapas necessárias para que se adicione um literal para alguns variáveis usando um local de aparição:
Adicione o literal como uma variável para o variáveis usando "literal" e o local de aparição.
Gere o nome deste literal usando "~L".

Etapas necessárias para que se adicione um monikette para alguns monikettes usando um expression:
Crie o monikette.
Posponha o monikette para os monikettes.
Atribua a phrase desta expression ao string deste monikette.
Atribua a variável desta expression à variável deste monikette.
Se a variável desta expression não for inexistente, atribua o type desta expression ao type deste monikette.

\# Unifica o sentido de diferentes termos usados em proposições, verbos e conjunções.
Etapas necessárias para que se adicione um monikette para alguns monikettes usando um string: \ creio que isso aqui ajude nas funções
Crie o monikette.
Posponha o monikette para os monikettes.
\PAL
\\ conjunctions
Se o string for "e", atribua "e" ao string deste monikette; exit. \ and
Se o string for "ou", atribua "or" ao string deste monikette; exit. \ or
\ from/given/with/using
Se o string for "desde", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "a partir de", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "partindo de", atribua "from/given/with/using" ao string deste monikette; exit.
\Se o string for "de", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dada", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dado", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dadas", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "dados", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "com", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "usando", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "contendo", atribua "from/given/with/using" ao string deste monikette; exit.
\\ in/into/to
\Se o string for "em", atribua "in/into/to" ao string deste monikette; exit. \  ver isso aqui com calma
Se o string for "a", atribua "in/into/to" ao string deste monikette; exit.
Se o string for "para", atribua "in/into/to" ao string deste monikette; exit.
\\ is/are
Se o string for "é", atribua "is/are" ao string deste monikette; exit.
Se o string for "está", atribua "is/are" ao string deste monikette; exit.
Se o string for "for", atribua "is/are" ao string deste monikette; exit.
Se o string for "foi", atribua "is/are" ao string deste monikette; exit.
Se o string for "foram", atribua "is/are" ao string deste monikette; exit.
Se o string for "forem", atribua "is/are" ao string deste monikette; exit.
Se o string for "estiver", atribua "is/are" ao string deste monikette; exit.
Se o string for "estiverem", atribua "is/are" ao string deste monikette; exit.
\Se o string for "tem", atribua "is/are" ao string deste monikette; exit.
\Se o string for "tiver", atribua "is/are" ao string deste monikette; exit.
Se o string for "are", atribua "is/are" ao string deste monikette; exit.
Se o string for "são", atribua "is/are" ao string deste monikette; exit.
Se o string for "estão", atribua "is/are" ao string deste monikette; exit.
Se o string for "is", atribua "is/are" ao string deste monikette; exit.
Se o string for "forem", atribua "is/are" ao string deste monikette; exit.
Se o string for "estiverem", atribua "is/are" ao string deste monikette; exit.
Se o string for "puder", atribua "pode" ao string deste monikette; exit.
Se o string for "puderem", atribua "pode" ao string deste monikette; exit.
Se o string for "existir", atribua "existe" ao string deste monikette; exit.
\Se o string for "decide", atribua "decidir" ao string deste monikette; exit.
\Se o string for "decidiu", atribua "decidir" ao string deste monikette; exit.
\Se o string for "decidindo", atribua "decidir" ao string deste monikette; exit. \melhor não por gerúndio ou verbos compostos
\Se o string for "decidiu-se", atribua "decidir" ao string deste monikette; exit.
Se o string for "existir", atribua "existe" ao string deste monikette; exit.
\\ allocates e destroys
\Se o string for "alojar", atribua "allocate" ao string deste monikette; exit.
\Se o string for "aloje", atribua "allocate" ao string deste monikette; exit.
\Se o string for "alocar", atribua "allocate" ao string deste monikette; exit.
\Se o string for "aloque", atribua "allocate" ao string deste monikette; exit.
\Se o string for "reservar", atribua "allocate" ao string deste monikette; exit.
\Se o string for "reserve", atribua "allocate" ao string deste monikette; exit.
\Se o string for "memória", atribua "memória" ao string deste monikette; exit.
\Se o string for "for", atribua "por" ao string deste monikette; exit. \\servia pra converter o "for" para "por"
Se o string for "pelo", atribua "por o" ao string deste monikette; exit.
Se o string for "pela", atribua "por o" ao string deste monikette; exit.
\Se o string for "desalocar", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "desaloque", atribua "deallocate" ao string deste monikette; exit.
\\Se o string for "desalojar", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "desaloje", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "esvaziar", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "esvazie", atribua "deallocate" ao string deste monikette; exit.
\Se o string for "destruir", atribua "destroy" ao string deste monikette; exit.
\CAL
\\ from/given/with/using
Se o string for "from", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "given", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "with", atribua "from/given/with/using" ao string deste monikette; exit.
Se o string for "using", atribua "from/given/with/using" ao string deste monikette; exit.
\ in/into/to
Se o string for "in", atribua "in/into/to" ao string deste monikette; exit.
Se o string for "into", atribua "in/into/to" ao string deste monikette; exit.
Se o string for "to", atribua "in/into/to" ao string deste monikette; exit.
\ is/are
Se o string for "are", atribua "is/are" ao string deste monikette; exit.
Se o string for "is", atribua "is/are" ao string deste monikette; exit.
\ aren't/isn't
Se o string for "isn't", atribua "is/aren't" ao string deste monikette; exit.
Se o string for "aren't", atribua "is/aren't" ao string deste monikette; exit.
\ backward/backwards/counterclockwise/counter-clockwise/anticlockwise/anti-clockwise
Se o string for "backward", atribua "backward" ao string deste monikette; exit.
Se o string for "backwards", atribua "backward" ao string deste monikette; exit.
Se o string for "counterclockwise", atribua "backward" ao string deste monikette; exit.
Se o string for "counter-clockwise", atribua "backward" ao string deste monikette; exit.
Se o string for "anticlockwise", atribua "backward" ao string deste monikette; exit.
Se o string for "anti-clockwise", atribua "backward" ao string deste monikette; exit.
\ at/on
Se o string for "at", atribua "at/on" ao string deste monikette; exit.
Se o string for "on", atribua "at/on" ao string deste monikette; exit.
Se o string for "sobre", atribua "at/on" ao string deste monikette; exit.
\ other
Atribua o string ao string deste monikette.

Etapas necessárias para que se adicione um monikette para alguns monikettes usando um type:
Crie o monikette.
Posponha o monikette para os monikettes.
Atribua o type ao type deste monikette.

Etapas necessárias para que se adicione push fragments usando alguns monikettes:
Se a rotina utilizada atualmente for inexistente, cancele.
Percorra.
Obtenha um monikette from os monikettes (backwards).
Se o monikette for inexistente, cancele.
Se a variável deste monikette for inexistente, repita.
Se o subtexto atual deste monikette não estiver em branco, repita.
Se o type atual deste monikette for inexistente, repita.
Adicione um fragment usando o push address tag e a variável deste monikette.
Repita.

Etapas necessárias para que se adicione o atribua ou converta fragments usando uma variável e uma segunda variável e um local de aparição:
Adicione um fragment usando o push address tag e a segunda variável.
Adicione um segundo fragment usando o push address tag e o variável.
Encontre uma routine usando "atribua" e o type desta variável e "para" e o type desta segunda variável.
Se a routine for inexistente, encontre a routine usando "converta" e o type desta variável e "para" e o type desta segunda variável.
Se a routine não for inexistente, adicione um terceiro fragment usando o call internal tag e a routine; exit.
\ erro message
Adicione um monikette para alguns monikettes usando "atribua/converta".
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Adicione um terceiro monikette para os monikettes usando "para/a".
Adicione um quarto monikette para os monikettes usando o type desta segunda variável.
Converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Apresente uma mensagem de erro contendo "Eu não sei como: " seguido de o cabeçalho expandido seguido de "." e o local de aparição.

Etapas necessárias para que se adicione uma routine para alguns routines usando um local de aparição:
Crie a routine.
Posponha a routine para as routines.
Atribua o local de aparição ao local de aparição desta routine.

Etapas necessárias para que se adicione um scratch usando um type nome e um local de aparição:
Se a rotina utilizada atualmente for inexistente, esvazie o scratch; exit.
Adicione o scratch para os locals desta rotina utilizada atualmente usando "scratch" e o local de aparição.
Gere o nome deste scratch usando "~S".
Atribua o type nome ao type nome deste scratch.
Resolva o scratch.

Etapas necessárias para que se adicione several fragments usando um string e uma variável e uma segunda string e uma segunda variável e um local de aparição:
Adicione um fragment usando o push address tag e a segunda variável.
Adicione um segundo fragment usando o push address tag e o variável.
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o type desta segunda variável.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " seguido de o cabeçalho expandido seguido de "." e o local de aparição; exit.
Adicione um terceiro fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione several fragments usando um string e uma variável e uma segunda string e uma segunda variável e um terceiro string e um terceiro variável e um endereço de memória do pedaço :
Adicione um fragment usando o push address tag e o terceiro variável.
Adicione um segundo fragment usando o push address tag e a segunda variável.
Adicione um terceiro fragment usando o push address tag e o variável.
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o type desta segunda variável.
Adicione um quinto monikette para os monikettes usando o terceiro string.
Adicione um sexto monikette para os monikettes usando o type desta terceiro variável.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " seguido de o cabeçalho expandido seguido de "." e o endereço de memória do pedaço; exit.
Adicione um quarto fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione um source file para alguns source files usando um endereço completo:
Crie o source file.
Posponha o source file para o source files.
Atribua o endereço completo ao endereço completo deste source file.

Etapas necessárias para que se adicione two fragments usando um string e uma variável e um local de aparição:
Adicione um fragment usando o push address tag e o variável.
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando o type desta variável.
Encontre uma routine usando os monikettes.
Se a routine for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu não sei como: " seguido de o cabeçalho expandido seguido de "." e o local de aparição; exit.
Adicione um segundo fragment usando o call internal tag e a routine.

Etapas necessárias para que se adicione um type para alguns types usando um local de aparição:
Crie o type.
Posponha o type para o types.
Atribua o local de aparição ao local de aparição deste type.

Etapas necessárias para que se adicione um type para alguns types usando um nome e um plural nome e um base nome:
Adicione o type para os types usando o nome e o plural nome e o base nome e nil.

Etapas necessárias para que se adicione um type para alguns types usando um nome e um plural nome e um base nome e um local de aparição:
Crie o type.
Posponha o type para o types.
Atribua o local de aparição ao local de aparição deste type.
Atribua o nome ao nome deste type.
Atribua o plural nome ao plural nome deste type.
Atribua o base nome ao base nome deste type.

Etapas necessárias para que se adicione uma variável para alguns variáveis usando um categoria e um local de aparição:
Crie o variável usando o categoria.
Posponha o variável para o variáveis.
Atribua o local de aparição ao local de aparição desta variável.

O adding built-in memory routines temporizador é um temporizador.

O adding built-in startup routine temporizador é um temporizador.

Etapas necessárias para que se address alguns entries:
Obtenha um entry from o entries.
Se a entry for inexistente, cancele.
Address o entry.
Repita.

Etapas necessárias para que se address um entry:
Atribua o endereço do nome usado atualmente ao nome address desta entry.
Atribua o length deste nome deste entry mais 3 para um número.
Round o número up para o nearest multiple of 2.
Adicione o número para o endereço do nome usado atualmente.
Atribua o current thunk address ao thunk address desta entry.
Atribua o image base mais o current thunk address ao address desta entry.
Adicione 4 para o current thunk address.

Etapas necessárias para que se address um fragment usando um address:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Atribua o image base mais o address ao address deste fragment.
Se a tag deste fragment for a push address tag, adicione 7 para o address; exit.
Se a tag deste fragment for a call internal tag, adicione 5 para o address; exit.
Se a tag deste fragment for a load address tag, adicione 12 para o address; exit.
Se a tag deste fragment for a increment tag, adicione 10 para o address; exit.
Se a tag deste fragment for a dereference tag, adicione 14 para o address; exit.
Se a tag deste fragment for a jump false tag, adicione 9 para o address; exit.
Se a tag deste fragment for a not tag, adicione 3 para o address; exit.
Se a tag deste fragment for a exit tag, adicione 5 para o address; exit.
Se a tag deste fragment for a repeat tag, adicione 5 para o address; exit.
Se a tag deste fragment for a break tag, adicione 5 para o address; exit.
Se a tag deste fragment for a prolog tag, address o fragment usando o address (prolog); exit.
Se a tag deste fragment for a epilog tag, address o fragment usando o address (epilog); exit.
Se a tag deste fragment for a Intel tag, adicione o length deste code deste fragment para o address; exit.
Se a tag deste fragment for a push value tag, address o fragment usando o address (push value); exit.
Se a tag deste fragment for a call external tag, adicione 6 para o address; exit.
Se a tag deste fragment for a load eax tag, adicione 5 para o address; exit. \ was 8 when "load eax" took em variáveis; now "load eax" only does um immediate value
Se a tag deste fragment for a save eax tag, address o fragment usando o address (save eax); exit.
Se a tag deste fragment for a call indirect tag, adicione 8 para o address; exit.
Se a tag deste fragment for a routine address tag, adicione 12 para o address; exit.

Etapas necessárias para que se address um fragment usando um address (epilog):
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o address.
Adicione 6 para o address.

Etapas necessárias para que se address um fragment usando um address (prolog):
Adicione 3 para o address.
Se o local size desta rotina utilizada atualmente não for 0, adicione 10 para o address.
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, adicione 3 para o address.

Etapas necessárias para que se address um fragment usando um address (push value):
Adicione 6 para o address.
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Atribua o length deste type desta variável deste fragment para um length.
Se o length for 4, adicione 2 para o address; exit.
Se o length for 2, adicione 3 para o address; exit.
Se o length for 1, adicione 4 para o address; exit.
Apresente a mensagem de erro contendo "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address um fragment usando um address (save eax):
Adicione 6 para o address.
Se o variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - address um fragment usando um address (push value)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - address um fragment usando um address (push value)"; exit.
Atribua o length deste type desta variável deste fragment para um length.
Se o length for 4, adicione 2 para o address; exit.
Se o length for 2, adicione 3 para o address; exit.
Se o length for 1, adicione 2 para o address; exit.
Apresente a mensagem de erro contendo "Erro interno 3 - address um fragment usando um address (push value)".

Etapas necessárias para que se address alguns fragments usando um address:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Address o fragment usando o address.
Repita.

Etapas necessárias para que se address um import:
Atribua o endereço do nome usado atualmente ao nome address deste import.
Atribua o endereço do cabeçalho usado atualmente ao header address deste import.
Atribua o endereço do nome usado atualmente ao nome memory address deste import header deste import.
Atribua o length deste nome deste import mais 1 para um número.
Round o número up para o nearest multiple of 2.
Adicione o número para o endereço do nome usado atualmente.
Adicione a magnitude desse import header para o endereço do cabeçalho usado atualmente. \ tenho que traduzir com calma isso depois
Atribua o current thunk address ao first thunk memory address deste import header deste import.
Address as entries deste import.
Adicione 4 para o current thunk address.

Etapas necessárias para que se address alguns imports usando um address:
Atribua o address ao endereço do cabeçalho usado atualmente.
Atribua as contagem destes imports para uma contagem.
Adicione 1 para a contagem.
Multiplique a contagem por a magnitude desse import header.
Atribua o address mais o contagem ao current thunk address.
Obtenha uma segunda contagem usando o imports (all entries mais markers).
Multiplique a segunda contagem por 4.
Atribua o current thunk address mais a segunda contagem ao endereço do nome usado atualmente.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, pare.
Address o import.
Repita.
Atribua o endereço do nome usado atualmente menos o address para um número.
Adicione o número para o address.

Um address é um número.

Etapas necessárias para que se address uma routine usando um address:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o employs cabeçalho expandido desta routine não estiver em branco, cancele. \ employs são addressed later
Se o compiled detector desta routine não estiver ativo, cancele.
Atribua a routine à rotina utilizada atualmente.
Atribua o image base mais o address ao address desta routine.
Address os fragments desta routine usando o address.
Round o address up para o nearest multiple of 4.

Etapas necessárias para que se address alguns routines usando um address:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma routine from as routines.
Se a routine for inexistente, pare.
Address a routine usando o address.
Repita.

Etapas necessárias para que se address uma variável usando um address:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o variável for inexistente, cancele.
Se o compiled detector desta variável não estiver ativo, cancele.
Atribua o image base mais o address ao address desta variável.
Adicione o length deste type desta variável para o address.
Se o type desta variável puder ser reduzido para "string", adicione o length deste data desta variável mais 1 para o address.
Round o address up para o nearest multiple of 4.

Etapas necessárias para que se address alguns variáveis usando um address:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma variável from o variáveis.
Se o variável for inexistente, cancele.
Address o variável usando o address.
Repita.

O addressing temporizador é um temporizador.

Etapas necessárias para que se advance um trecho:
Posponha o return pedaço para o trecho.
Posponha o linefeed pedaço para o trecho.

Etapas necessárias para que se advance um trecho (twice):
Advance o trecho.
Advance o trecho.

Etapas necessárias para que se posponha um entry para um trecho (with separator):
Se a entry for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o nome desta entry para o trecho (with separator).

Etapas necessárias para que se posponha um detector para um trecho (with separator):
Converta o detector para um string.
Posponha o string para o trecho (with separator).

Etapas necessárias para que se posponha o global finalizers para um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o compiled detector deste global não estiver ativo, repita.
Se o type deste global não deveria ser [estar] finalizado, repita.
Posponha "~finalize o " seguido de o nome deste global seguido de ". " para o string.
Repita.

Etapas necessárias para que se posponha o global initializers para um string:
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Se o literal deste global for inexistente, repita.
Se o compiled detector deste global não estiver ativo, repita.
Desative um detector.
Posponha o initializer string deste global para o string.
Repita.

Etapas necessárias para que se posponha um monikette para um cabeçalho expandido:
Se o monikette for inexistente, cancele.
Se o cabeçalho expandido não estiver em branco, posponha o caractere de espaço para o cabeçalho expandido.
Se o type deste monikette não for inexistente, posponha "[" e o nome deste type deste monikette e "]" para o cabeçalho expandido (fast); exit.
Se o string deste monikette não estiver em branco, posponha o string deste monikette para o cabeçalho expandido; exit.

Etapas necessárias para que se posponha um monikette para um cabeçalho expandido (while bubbling):
Se o monikette for inexistente, cancele.
Se o cabeçalho expandido não estiver em branco, posponha o caractere de espaço para o cabeçalho expandido.
Se o subtexto atual deste monikette não estiver em branco, posponha o subtexto atual deste monikette para o cabeçalho expandido; exit.
Se o type atual deste monikette não for inexistente, posponha "[" e o nome deste type atual deste monikette e "]" para o cabeçalho expandido (fast); exit.

Etapas necessárias para que se posponha um número para um trecho (as hex com separator):
Converta o número para um cifra hexadecimal.
Posponha o cifra hexadecimal para o trecho (with separator).

Etapas necessárias para que se posponha um número para um trecho (with separator):
Converta o número para um string.
Posponha o string para o trecho (with separator).

Etapas necessárias para que se posponha um ratio para um trecho (with separator):
Converta o ratio para um string.
Posponha o string para o trecho (with separator).

Etapas necessárias para que se posponha uma routine para um trecho (with separator):
Se a routine for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o cabeçalho expandido deste routine para o trecho (with separator).

Etapas necessárias para que se posponha um string e uma segunda string e um terceiro string para um quarto string (fast):
Atribua o length deste quarto string para um length.
Adicione o length deste string para o length.
Adicione o length deste segunda string para o length.
Adicione o length deste terceiro string para o length.
Reassign um endereço de memória usando o length.
Atribua o endereço de memória para um endereço de memória do pedaço .
Copy pedaços from o first deste quarto string para o endereço de memória do pedaço pelo length deste quarto string.
Adicione o length deste quarto string para o endereço de memória do pedaço .
Copy pedaços from o first deste string para o endereço de memória do pedaço pelo length deste string.
Adicione o length deste string para o endereço de memória do pedaço .
Copy pedaços from o first deste segunda string para o endereço de memória do pedaço pelo length deste segunda string.
Adicione o length deste segunda string para o endereço de memória do pedaço .
Copy pedaços from o first deste terceiro string para o endereço de memória do pedaço pelo length deste terceiro string.
Unassign o first deste quarto string.
Atribua o endereço de memória ao first deste quarto string.
Atribua o endereço de memória mais o length menos 1 ao last deste quarto string.

Etapas necessárias para que se posponha um string para um trecho (with separator):
Posponha o string para o trecho.
Posponha "/" para o trecho.

Etapas necessárias para que se posponha uma tag para um trecho (as um fragment tag string com separator):
Se a tag for a break tag, posponha "break" para o trecho (with separator); exit.
Se a tag for a call external tag, posponha "call external" para o trecho (with separator); exit.
Se a tag for a call indirect tag, posponha "call indirect" para o trecho (with separator); exit.
Se a tag for a call internal tag, posponha "call internal" para o trecho (with separator); exit.
Se a tag for a dereference tag, posponha "dereference" para o trecho (with separator); exit.
Se a tag for a end if tag, posponha "end if" para o trecho (with separator); exit.
Se a tag for a epilog tag, posponha "epilog" para o trecho (with separator); exit.
Se a tag for a exit tag, posponha "exit" para o trecho (with separator); exit.
Se a tag for a finalize tag, posponha "finalize" para o trecho (with separator); exit.
Se a tag for a increment tag, posponha "increment" para o trecho (with separator); exit.
Se a tag for a Intel tag, posponha "Intel" para o trecho (with separator); exit.
Se a tag for a jump false tag, posponha "jump false" para o trecho (with separator); exit.
Se a tag for a load address tag, posponha "load address" para o trecho (with separator); exit.
Se a tag for a load eax tag, posponha "load eax" para o trecho (with separator); exit.
Se a tag for a loop tag, posponha "loop" para o trecho (with separator); exit.
Se a tag for a not tag, posponha "not" para o trecho (with separator); exit.
Se a tag for a prolog tag, posponha "prolog" para o trecho (with separator); exit.
Se a tag for a push address tag, posponha "push address" para o trecho (with separator); exit.
Se a tag for a push value tag, posponha "push value" para o trecho (with separator); exit.
Se a tag for a save eax tag, posponha "save eax" para o trecho (with separator); exit.
Se a tag for a repeat tag, posponha "repeat" para o trecho (with separator); exit.
Se a tag for a routine address tag, posponha "routine address" para o trecho (with separator); exit.
Posponha "?" para o trecho (with separator).

Etapas necessárias para que se posponha um type para um trecho (with separator):
Se o type for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o nome deste type para o trecho (with separator).

Etapas necessárias para que se posponha uma variável para um trecho (with separator):
Se o variável for inexistente, posponha "" para o trecho (with separator); exit.
Posponha o nome desta variável para o trecho (with separator).

Etapas necessárias para que se posponha um string para uma segunda string usando um terceiro string (portuguese contractions e synonyms rules):
\# contrações
Se o string for "ao", posponha "a o" para a segunda string; exit.
Se o string for "à", posponha "a a" para a segunda string; exit.
Se o string for "aos", posponha "a os" para a segunda string; exit.
Se o string for "às", posponha "a as" para a segunda string; exit.
\Se o string for "seguido do", posponha "seguido de o" para a segunda string; exit.
\Se o string for "seguido da", posponha "seguido de a" para a segunda string; exit.
\Se o string for "seguido dos", posponha "seguido de os" para a segunda string; exit.
\Se o string for "seguido das", posponha "seguido de as" para a segunda string; exit.
\Se o string for "seguido dum", posponha "seguido de um" para a segunda string; exit.
\Se o string for "seguido duma", posponha "seguido de uma" para a segunda string; exit.
\Se o string for "seguido duns", posponha "seguido de uns" para a segunda string; exit.
\Se o string for "seguido dumas", posponha "seguido de umas" para a segunda string; exit.
\Se o string for "junto do", posponha "seguido de o" para a segunda string; exit.
\Se o string for "junto da", posponha "seguido de a" para a segunda string; exit.
\Se o string for "junto dos", posponha "seguido de os" para a segunda string; exit.
\Se o string for "junto das", posponha "seguido de as" para a segunda string; exit.
\Se o string for "junto dum", posponha "seguido de um" para a segunda string; exit.
\Se o string for "junto duma", posponha "seguido de uma" para a segunda string; exit.
\Se o string for "junto duns", posponha "seguido de uns" para a segunda string; exit.
\Se o string for "junto dumas", posponha "seguido de umas" para a segunda string; exit.
\Se o string for "acompanhado do", posponha "seguido de o" para a segunda string; exit.
\Se o string for "acompanhado da", posponha "seguido de a" para a segunda string; exit.
\Se o string for "acompanhado dos", posponha "seguido de os" para a segunda string; exit.
\Se o string for "acompanhado das", posponha "seguido de as" para a segunda string; exit.
\Se o string for "acompanhado dum", posponha "seguido de um" para a segunda string; exit.
\Se o string for "acompanhado duma", posponha "seguido de uma" para a segunda string; exit.
\Se o string for "acompanhado duns", posponha "seguido de uns" para a segunda string; exit.
\Se o string for "acompanhado dumas", posponha "seguido de umas" para a segunda string; exit.
\Se o string for "do", posponha "de o" para a segunda string; exit.
\Se o string for "da", posponha "de a" para a segunda string; exit.
\Se o string for "dos", posponha "de os" para a segunda string; exit.
\Se o string for "das", posponha "de as" para a segunda string; exit.
\Se o string for "dum", posponha "de um" para a segunda string; exit.
\Se o string for "duma", posponha "de uma" para a segunda string; exit.
\Se o string for "dumas", posponha "de umas" para a segunda string; exit.
\Se o string for "duns", posponha "de uns" para a segunda string; exit.
Se o string for "daqui", posponha "de aqui" para a segunda string; exit.
Se o string for "dali", posponha "de ali" para a segunda string; exit.
Se o string for "dele", posponha "de ele" para a segunda string; exit.
Se o string for "dela", posponha "de ela" para a segunda string; exit.
Se o string for "desse", posponha "de esse" para a segunda string; exit.
Se o string for "dessa", posponha "de essa" para a segunda string; exit.
Se o string for "desses", posponha "de esses" para a segunda string; exit.
Se o string for "dessas", posponha "de essas" para a segunda string; exit.
Se o string for "deste", posponha "de este" para a segunda string; exit.
Se o string for "desta", posponha "de esta" para a segunda string; exit.
Se o string for "destes", posponha "de estes" para a segunda string; exit.
Se o string for "destas", posponha "de estas" para a segunda string; exit.
Se o string for "disso", posponha "de isso" para a segunda string; exit.
Se o string for "disto", posponha "de isto" para a segunda string; exit.
Se o string for "nesse", posponha "em esse" para a segunda string; exit.
Se o string for "nesses", posponha "em esses" para a segunda string; exit.
Se o string for "neste", posponha "em este" para a segunda string; exit.
Se o string for "nestes", posponha "em estes" para a segunda string; exit.
Se o string for "nisso", posponha "em isso" para a segunda string; exit.
Se o string for "nisto", posponha "em isto" para a segunda string; exit.
Se o string for "nessa", posponha "em essa" para a segunda string; exit.
Se o string for "nessas", posponha "em essas" para a segunda string; exit.
Se o string for "nesta", posponha "em esta" para a segunda string; exit.
Se o string for "nestas", posponha "em estas" para a segunda string; exit.
Se o string for "donde", posponha "de onde" para a segunda string; exit.
Se o string for "dentre", posponha "de entre" para a segunda string; exit.
Se o string for "dantes", posponha "de antes" para a segunda string; exit.
Se o string for "dalguém", posponha "de alguém" para a segunda string; exit.
Se o string for "dalgum", posponha "de algum" para a segunda string; exit.
Se o string for "dalguma", posponha "de alguma" para a segunda string; exit.
Se o string for "dalguns", posponha "de alguns" para a segunda string; exit.
Se o string for "dalgumas", posponha "de algumas" para a segunda string; exit.
Se o string for "nalgum", posponha "em algum" para a segunda string; exit.
Se o string for "nalguma", posponha "em alguma" para a segunda string; exit.
Se o string for "nalguns", posponha "em alguns" para a segunda string; exit.
Se o string for "nalgumas", posponha "em algumas" para a segunda string; exit.
Se o string for "doutro", posponha "de outro" para a segunda string; exit.
Se o string for "doutra", posponha "de outra" para a segunda string; exit.
Se o string for "doutros", posponha "de outros" para a segunda string; exit.
Se o string for "doutras", posponha "de outras" para a segunda string; exit.
Se o string for "noutro", posponha "em outro" para a segunda string; exit.
Se o string for "noutra", posponha "em outra" para a segunda string; exit.
Se o string for "noutros", posponha "em outros" para a segunda string; exit.
Se o string for "noutras", posponha "em outras" para a segunda string; exit.
\# "no" pode ser uma negação em inglês.
Se o string for any contraction usando o terceiro string (portuguese rules - "no"), posponha "em o" para a segunda string; exit.
Se o string for "na", posponha "em a" para a segunda string; exit.
Se o string for "nos", posponha "em os" para a segunda string; exit.
Se o string for "nas", posponha "em as" para a segunda string; exit.
\Se o string for "noutro", posponha "em outro" para a segunda string; exit.
\Se o string for "noutra", posponha "em outra" para a segunda string; exit.
\Se o string for "noutros", posponha "em outros" para a segunda string; exit.
\Se o string for "noutras", posponha "em outras" para a segunda string; exit.
Se o string for "num", posponha "em um" para a segunda string; exit.
Se o string for "numa", posponha "em uma" para a segunda string; exit.
Se o string for "nuns", posponha "em uns" para a segunda string; exit.
Se o string for "numas", posponha "em umas" para a segunda string; exit.
Se o string for "pelo", posponha "por o" para a segunda string; exit.
Se o string for "pela", posponha "por a" para a segunda string; exit.
Se o string for "pelos", posponha "por os" para a segunda string; exit.
Se o string for "pelas", posponha "por as" para a segunda string; exit.
\# sinônimos
\Se o string for "adir", posponha "adicionar" para a segunda string; exit.
Se o string for "agregar", posponha "adicionar" para a segunda string; exit.
Se o string for "acrescentar", posponha "adicionar" para a segunda string; exit.
Se o string for "somar", posponha "adicionar" para a segunda string; exit.
Se o string for "começar", posponha "iniciar" para a segunda string; exit.
Se o string for "terminar", posponha "finalizar" para a segunda string; exit.
Se o string for "acabar", posponha "finalizar" para a segunda string; exit.
Se o string for "completar", posponha "finalizar" para a segunda string; exit.
Se o string for "colocar", posponha "pôr" para a segunda string; exit.
Se o string for "mudar", posponha "alterar" para a segunda string; exit.
Se o string for "limpar", posponha "apagar" para a segunda string; exit.
Se o string for "ampliar", posponha "aumentar" para a segunda string; exit.
Se o string for "expandir", posponha "aumentar" para a segunda string; exit.
Se o string for "alargar", posponha "aumentar" para a segunda string; exit.
Se o string for "dilatar", posponha "aumentar" para a segunda string; exit.
Se o string for "estender", posponha "aumentar" para a segunda string; exit.
Se o string for "prolongar", posponha "aumentar" para a segunda string; exit.
Se o string for "ampliar", posponha "aumentar" para a segunda string; exit.
Se o string for "achar", posponha "encontrar" para a segunda string; exit.
Se o string for "descobrir", posponha "encontrar" para a segunda string; exit.
Se o string for "buscar", posponha "encontrar" para a segunda string; exit.
Se o string for "manusear", posponha "manejar" para a segunda string; exit.
Se o string for "manipular", posponha "manejar" para a segunda string; exit.
Se o string for "enumerar", posponha "listar" para a segunda string; exit.
Se o string for "elencar", posponha "listar" para a segunda string; exit.
Se o string for "selecionar", posponha "escolher" para a segunda string; exit.
Se o string for "eliminar", posponha "remover" para a segunda string; exit.
Se o string for "excluir", posponha "remover" para a segunda string; exit.
Se o string for "retirar", posponha "remover" para a segunda string; exit.
Se o string for "rodar", posponha "girar" para a segunda string; exit.
Se o string for "começar", posponha "iniciar" para a segunda string; exit.
Se o string for "permutar", posponha "trocar" para a segunda string; exit.
Se o string for "esperar", posponha "aguardar" para a segunda string; exit.
Se o string for "rascunhar", posponha "esboçar" para a segunda string; exit.
Se o string for "antepor", posponha "prepor" para a segunda string; exit.
Posponha o string para a segunda string.

Etapas necessárias para que se attach address loading code para um texto hexadecimal usando uma variável:
\ loads para edx
Se o variável for inexistente, attach $C7C200000000 para o texto hexadecimal; exit. \ mov edx,0
Se a categoria desta variável for "global", attach $C7C2 e o address desta variável para o texto hexadecimal; exit. \ mov edx,the address da variável
Se a categoria desta variável for "literal", attach $C7C2 e o address desta variável para o texto hexadecimal; exit. \ mov edx,the address da variável
Se a categoria desta variável for "local", attach $8D95 e o offset desta variável para o texto hexadecimal; exit. \ lea edx,[ebp+ the offset da variável]
Se a categoria desta variável for "scratch", attach $8B95 e o offset desta variável para o texto hexadecimal; exit. \ mov edx,[ebp+ the offset da variável]
Se a categoria desta variável não for "parâmetro", apresente uma mensagem de erro contendo "Erro interno - attach address loading code para um texto hexadecimal usando uma variável"; exit.
Se o by-value detector desta variável estiver ativo, attach $8D95 e o offset desta variável para o texto hexadecimal; exit. \ lea edx,[ebp+the offset da variável]
Attach $8B95 e o offset desta variável para o texto hexadecimal. \ mov edx,[ebp+ the offset da variável]

Etapas necessárias para que se attach um texto hexadecimal e um address para um fragment:
\ call ou jump
Atribua o address para um número.
Subtraia o address deste fragment from o número.
Subtraia o length deste code deste fragment from o número.
Subtraia o length deste texto hexadecimal from o número.
Subtraia 4 from o número.
Attach o texto hexadecimal e o número para o code deste fragment.

Etapas necessárias para que se attach um texto hexadecimal e um número e uma segunda texto hexadecimal para um terceiro texto hexadecimal:
Posponha o texto hexadecimal para o terceiro texto hexadecimal.
Converta o número para um quarto texto hexadecimal.
Posponha o quarto texto hexadecimal para o terceiro texto hexadecimal.
Posponha a segunda texto hexadecimal para o terceiro texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um número e uma segunda número para uma segunda texto hexadecimal:
Posponha o texto hexadecimal para a segunda texto hexadecimal.
Converta o número para um terceiro texto hexadecimal.
Posponha o terceiro texto hexadecimal para a segunda texto hexadecimal.
Converta a segunda número para um quarto texto hexadecimal.
Posponha o quarto texto hexadecimal para a segunda texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal e um detector para uma segunda texto hexadecimal;
Etapas necessárias para que se attach um texto hexadecimal e um número para uma segunda texto hexadecimal:
Posponha o texto hexadecimal para a segunda texto hexadecimal.
Converta o número para um terceiro texto hexadecimal.
Posponha o terceiro texto hexadecimal para a segunda texto hexadecimal.

Etapas necessárias para que se attach um texto hexadecimal para uma segunda texto hexadecimal:
Employ posponha um string para uma segunda string.

Etapas necessárias para que se blurt pedaços usando um endereço de memória e um length e um trecho e um offset:
Atribua o first deste trecho mais o offset para uma segunda endereço de memória.
Copy pedaços from o endereço de memória para a segunda endereço de memória pelo length.

Etapas necessárias para que se blurt um DOS header para um trecho:
Blurt pedaços usando o whereabouts deste DOS header e o magnitude deste DOS header e o trecho e 0.

Etapas necessárias para que se blurt alguns entries para um trecho:
Obtenha um entry from o entries.
Se a entry for inexistente, cancele.
Blurt a entry ao trecho.
Repita.

Etapas necessárias para que se blurt um entry para um trecho:
Blurt pedaços usando o whereabouts deste nome address desta entry e 4 e o trecho e o thunk address desta entry.
Atribua o nome address desta entry mais 2 para um address.
Blurt o nome desta entry ao trecho at o address.

Etapas necessárias para que se blurt um fragment para um trecho:
Se o code deste fragment estiver em branco, cancele.
Atribua o address deste fragment menos o image base para um address.
Blurt o code deste fragment ao trecho at o address.

Etapas necessárias para que se blurt alguns fragments para um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Blurt o fragment ao trecho.
Repita.

Etapas necessárias para que se blurt um import para um trecho:
Blurt pedaços usando o whereabouts deste import header deste import e o magnitude deste import header deste import e o trecho e o header address deste import.
Blurt o nome deste import ao trecho at o nome address deste import.
Blurt as entries deste import ao trecho.

Etapas necessárias para que se blurt alguns imports para um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Blurt o import ao trecho.
Repita.

Etapas necessárias para que se blurt um PE header para um trecho:
Blurt pedaços usando o whereabouts deste PE header e o magnitude deste PE header e o trecho e 256.

Etapas necessárias para que se blurt uma routine para um trecho:
Se o compiled detector desta routine não estiver ativo, cancele.
Blurt os fragments desta routine ao trecho.

Etapas necessárias para que se blurt alguns routines para um trecho:
Obtenha uma routine from as routines.
Se a routine for inexistente, cancele.
Blurt a routine ao trecho.
Repita.

Etapas necessárias para que se blurt um string para um trecho at um address:
Blurt pedaços usando o first deste string e o length deste string e o trecho e o address.

Etapas necessárias para que se blurt uma variável para um trecho:
Se o compiled detector desta variável não estiver ativo, cancele.
Se o type desta variável puder ser reduzido para "string", blurt o variável ao trecho (as um string); exit.
Atribua o address desta variável menos o image base para um address. \ Atribua a diferença entre o endreço da variável e a base da imagem em um endereço.
Blurt o data desta variável ao trecho at o address.

Etapas necessárias para que se blurt uma variável para um trecho (as um string):
Atribua o address desta variável menos o image base para um address.
Atribua o length deste data desta variável para um length.
Atribua o address para uma segunda address.
Adicione a magnitude desse prototype string para a segunda address.
Adicione o image base para a segunda address.
Atribua 0 ao first deste prototype string.
Atribua -1 ao last deste prototype string.
Se o length não for 0, atribua a segunda address ao first deste prototype string.
Se o length não for 0, atribua o first deste prototype string mais o length menos 1 ao last deste prototype string.
Blurt pedaços usando o whereabouts deste prototype string e a magnitude deste prototype string e o trecho e o address.
Adicione a magnitude deste prototype string para o address.
Blurt os data desta variável ao trecho at o address.

Etapas necessárias para que se blurt alguns variáveis para um trecho:
Obtenha uma variável from o variáveis.
Se o variável for inexistente, cancele.
Blurt o variável ao trecho.
Repita.

Um zona é um conjunto com um base address, um length e um size.

O break tag é uma tag igual a 1.

Etapas necessárias para que se bubble um monikette:
Se o monikette for inexistente, cancele.
Se o subtexto atual deste monikette não estiver em branco, limpe o subtexto atual deste monikette; exit.
Se o type atual deste monikette for inexistente, cancele.
Se o type atual deste monikette for any built-in type, atribua nil ao type atual deste monikette; exit.
Atribua o base type deste type atual deste monikette ao type atual deste monikette.

Um built-in type é um type.

Etapas necessárias para que se calculate o length of um type:
Se o type for inexistente, cancele.
Se o length deste type não for -1, cancele.
Calculate o length of o base type deste type.
Se os campos deste type estiverem vazio, atribua o length deste base type deste type ao length deste type; exit.
Atribua 0 ao length deste type.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo from o campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition target nome deste campo não estiver em branco, repita.
Calculate o length of o type deste campo.
Adicione o length deste type deste campo times a contagem deste campo para o length deste type.
Repita.

Etapas necessárias para que se calculate o lengths of alguns types:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o length of o type.
Repita.

Etapas necessárias para que se calculate o offsets em um type:
Se o type for inexistente, cancele.
Atribua 0 para um offset.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition target nome deste campo não estiver em branco, repita.
Atribua o offset ao offset deste campo.
Adicione o length deste type deste campo times o contagem deste campo para o offset.
Repita.

Etapas necessárias para que se calculate o offsets em alguns types:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o offsets no type.
Repita.

Etapas necessárias para que se calculate o redefinition offsets em um type:
Se o type for inexistente, cancele.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, cancele.
Se o redefinition target nome deste campo estiver em branco, repita.
Encontre uma segundo campo usando o redefinition target nome deste campo e os campos deste type.
Se a segundo campo for inexistente, apresente uma mensagem de erro contendo "Redefine inválido. Eu não consigo encontrar o campo: " seguido de o redefinition target nome deste campo seguido de "' campo." e o local de aparição deste campo; exit.
Atribua o offset deste segundo campo ao offset deste campo.
Repita.

Etapas necessárias para que se calculate o redefinition offsets em alguns types:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Calculate o redefinition offsets no type.
Repita.

O calculating temporizador é um temporizador.

O call external tag é uma tag igual a 2.

O call indirect tag é uma tag igual a 3.

O call internal tag é uma tag igual a 4.

Etapas necessárias para que se check por invalid optional info sobre um type:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o target nome deste type não estiver em branco, check por invalid optional info sobre o type (target).
Se o campos deste type não estiverem vazio, check por invalid optional info sobre o type (campos).
Se o scale deste type não for 0, check por invalid optional info sobre o type (scale).

Etapas necessárias para que se check por invalid optional info sobre um type (campos):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "conjunto", apresente uma mensagem de erro contendo "A palavra 'with' só é permitida em conjunto types." e o local de aparição deste type; exit. \\mudar aqui

Etapas necessárias para que se check por invalid optional info sobre um type (scale):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "número", apresente uma mensagem de erro contendo "Escalas são permitidas apenas em tipos numéricos." e o local de aparição deste type; exit.

Etapas necessárias para que se check por invalid optional info sobre um type (target):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type não puder ser reduzido para "endereço de memória", apresente uma mensagem de erro contendo "A palavra 'to' só é permitida em endereço de memória types." e o local de aparição deste type; exit.

Etapas necessárias para que se limpe um campo termo:
Fill pedaços com o null pedaço starting at o whereabouts deste campo termo pelo magnitude deste campo termo.

Etapas necessárias para que se limpe um termo:
Esvazie o variável deste termo.
Limpe o phrase deste termo.

O code zona é um zona.

Etapas necessárias para que se compile o bodies of as routines:
Compile o body of a routine called "initialize before run".
Compile o body of a routine called "nosso programa seja executado".
Compile o body of a routine called "finalize after run".

Etapas necessárias para que se compile o body of uma routine:
Se a routine for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o compiled detector desta routine estiver ativo, cancele.
Ligue o compiled detector desta routine.
Lance um percorredor sobre o instruções desta routine.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for o ponto&vírgula, compile o body of a routine usando o percorredor (sobrecarga de métodos); exit. \ *** alternate palavraing
Se o token deste percorredor for any employ, compile o body of a routine usando o percorredor (employ); exit.
Atribua a rotina utilizada atualmente para um saved routine.
Atribua a routine à rotina utilizada atualmente.
Crie o nickname catálogo desta routine usando 101.
Eliminate duplicate nicknames from os parâmetros desta routine usando o nickname catálogo desta routine.
Compile o body of a routine (prolog).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, pare.
Compile o próximo satement usando o percorredor.
Repita.
Compile o body of a routine (epilog).
Atribua o saved routine à rotina utilizada atualmente.

Etapas necessárias para que se compile o body of uma routine (epilog):
Se a routine for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um fragment usando o finalize tag.
Percorra.
Obtenha uma variável from os locals desta routine.
Se o variável for inexistente, pare.
Se o categoria desta variável for "scratch", repita.
Se o type desta variável não deveria ser [estar] finalizado, repita.
Adicione um segundo fragment usando o push address tag e o variável.
Encontre uma segunda routine usando "~finalize" e o type desta variável.
Se a segunda routine for inexistente, apresente uma mensagem de erro contendo "Erro interno - compile o body of uma routine (epilog)"; exit.
Adicione um terceiro fragment usando o call internal tag e a segunda routine.
Repita.
Adicione um quarto fragment usando o epilog tag.

Etapas necessárias para que se compile o body of uma routine (prolog):
Se a routine for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um fragment usando o prolog tag.
Adicione um segundo fragment usando o loop tag.

Etapas necessárias para que se compile o body of a routine called um string:
Se o detector de erros deste compilador estiver ativado, cancele.
Encontre uma routine usando o string e o catálogo geral de rotinas.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Eu preciso de uma função para fazer: " seguido de o string seguido de "."; exit.
Compile o body of a routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (sobrecarga de métodos):
\ *** alternate palavraing
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador). \ *** do we need this?
Atribua o next desta routine para um target routine.
Se o target routine for inexistente, apresente uma mensagem de erro contendo "Você definiu uma palavra alternativa aqui, mas eu não tenho certeza pra que ela serve." e o percorredor; exit.
Atribua o cabeçalho expandido deste target routine ao employs cabeçalho expandido desta routine.
Compile o body of o target routine.

Etapas necessárias para que se compile o body of uma routine usando um percorredor (employ):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile uma routine reference usando o percorredor.
Converta a routine reference para o employs cabeçalho expandido desta routine.
Destrua a routine reference.
Se o token deste percorredor não for ".", apresente uma mensagem de erro contendo "Employ statments devem terminar com um ponto, não com: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Somente um employ" e o percorredor; exit.
Encontre uma segunda routine usando o employs cabeçalho expandido desta routine e o catálogo geral de rotinas.
Se a segunda routine for inexistente, apresente a mensagem de erro contendo "Não consigo encontrar um rotina: " seguido de o employs cabeçalho expandido desta routine seguido de "' que você está tentando empregar." e o local de aparição desta routine; exit.
Compile o body of a segunda routine.

Etapas necessárias para que se compile o call'd part usando um percorredor e uma variável:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o variável for inexistente, cancele.
Atribua o nome desta variável ao type nome desta variável.
Mova o percorredor (usando diretrizes do compilador).
Examine o nome desta variável usando o percorredor.

Etapas necessárias para que se compile um endereço da pasta:
Compile o endereço da pasta (start).
Compile o endereço da pasta (load o source files).
Compile o endereço da pasta (análise dos arquivos fornecidos).
Compile o endereço da pasta (decomponha os tipos das variáveis).
Compile o endereço da pasta (resolva o globals).
Compile o endereço da pasta (compile o headers of as routines).
Compile o endereço da pasta (calculate lengths e offsets of types).
Compile o endereço da pasta (Adicione o built-in memory routines).
Compile o endereço da pasta (catalogue as routines por utility use).
Compile o endereço da pasta (compile o bodies of as routines).
Compile o endereço da pasta (Adicione e compile o built-in startup routine).
Compile o endereço da pasta (offset parâmetros e variáveis).
Compile o endereço da pasta (address).
Compile o endereço da pasta (transmogrify).
Compile o endereço da pasta (link).
Compile o endereço da pasta (write o exe).
Compile o endereço da pasta (stop).

Etapas necessárias para que se compile um endereço da pasta (Adicione e compile o built-in startup routine):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando e agrupando as tarefas padrão de inicialização..".
Start o adding built-in startup routine temporizador.
Adicione e compile o initialize before run e run e finalize after run routine.
Suspenda o adding built-in startup routine temporizador.

Etapas necessárias para que se compile um endereço da pasta (Adicione o built-in memory routines):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Adicionando como tarefas predefinidas na memória...".
Start o adding built-in memory routines temporizador.
Adicione as rotinas de alocação e desalocação e finalização e destruição.
Suspenda o adding built-in memory routines temporizador.

Etapas necessárias para que se compile um endereço da pasta (address):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Obtendo endereço dos itens...".
Start o addressing temporizador.
Atribua 4096 para um address.
Atribua o address à base desta import zona.
Address o imports usando o address.
Atribua o address menos a base desta import zona ao length desta import zona.
Round o address up para o nearest multiple of 4096.
Atribua o address à base desta zona de dados.
Address os globals usando o address.
Address os literals usando o address.
Atribua o address menos a base desta zona de dados ao length desta zona de dados.
Round o address up para o nearest multiple of 4096.
Atribua o address à base desta code zona.
Address as routines usando o address.
Atribua o address menos a base desta code zona ao length desta code zona.
Suspenda o addressing temporizador.

Etapas necessárias para que se compile um endereço da pasta (calculate lengths e offsets of types):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Calculando tamanhos e deslocamentos...".
Start o calculating temporizador.
Calculate o lengths of o types.
Calculate o offsets no types.
Calculate o redefinition offsets no types.
Suspenda o calculating temporizador.

Etapas necessárias para que se compile um endereço da pasta (compile o bodies of as routines):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando o conteúdo das tarefas...".
Start o compiling routine bodies temporizador.
Compile o bodies of as routines.
Suspenda o compiling routine bodies temporizador.

Etapas necessárias para que se compile um endereço da pasta (compile o headers of as routines):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Agrupando os nomes das tarefas...".
Start o temporizador de compilação de cabeçalhos de rotina.
Compile o headers of as routines.
Suspenda o temporizador de compilação de cabeçalhos de rotina.

Etapas necessárias para que se compile um endereço da pasta (catalogue as routines por utility use):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Catalogando tarefas...".
Start o indexing utilities temporizador.
Catalogue as routines por utility use.
Scrub o catálogo de rotinas úteis.
Catalogue novamente o catálogo de rotinas úteis.
Suspenda o indexing utilities temporizador.

Etapas necessárias para que se compile um endereço da pasta (link):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Elencando arquivos..".
Start o linking temporizador.
Link.
Suspenda o linking temporizador.

Etapas necessárias para que se compile um endereço da pasta (offset parâmetros e variáveis):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Deslocando parâmetros e variáveis...".
Start o offsetting temporizador.
Offset o parâmetros na routines.
Offset o locals na routines.
Suspenda o offsetting temporizador.

Etapas necessárias para que se compile um endereço da pasta (load o source files):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Carregando arquivos...".
Start o temporizador de operacionalização.
Load o source files.
Suspenda o temporizador de operacionalização.

Etapas necessárias para que se compile um endereço da pasta (resolva o globals):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo itens de escopo abrangente...".
Start o resolving globals temporizador.
Resolva o globals.
Suspenda o resolving globals temporizador.

Etapas necessárias para que se compile um endereço da pasta (decomponha os tipos das variáveis):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Resolvendo tipos...".
Start o resolving types temporizador.
Resolva os types (expand coisas).
Resolva os types (registro de plurais).
Resolva os types (base types).
Resolva os types (optional info).
Suspenda o resolving types temporizador.

Etapas necessárias para que se compile um endereço da pasta (análise dos arquivos fornecidos):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Analisando arquivos...".
Start o temporizador de análise/verificação.
Examine o source files.
Suspenda o temporizador de análise/verificação.

Etapas necessárias para que se compile um endereço da pasta (start):
Mostre painel de informações "Iniciando...".
Finalize o compilador.
Start o temporizador deste compilador.
Initialize o compilador usando o endereço da pasta.
Adicione o built-in types.

Etapas necessárias para que se compile um endereço da pasta (stop):
Suspenda o temporizador deste compilador.
Mostre painel de informações "Interrompendo".

Etapas necessárias para que se compile um endereço da pasta (transmogrify):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Modificando...".
Start o transmogrifying temporizador.
Transmogrify as routines.
Suspenda o transmogrifying temporizador.

Etapas necessárias para que se compile um endereço da pasta (write o exe):
Se o detector de erros deste compilador estiver ativado, cancele.
Mostre painel de informações "Gerando arquivo executável...".
Start o writing temporizador.
Escreva o exe deste compilador para o endereço exe completo deste compilador.
Se o i/o erro não estiver em branco, apresente uma mensagem de erro contendo o i/o erro.
Suspenda o writing temporizador.

Etapas necessárias para que se compile um expression usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Compile um termo usando o percorredor.
Atribua o termo ao expression.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any operator, cancele.
Se o token deste percorredor for any divided, compile o expression usando o percorredor (operador de divisão); repita.
Se o token deste percorredor for any minus, compile o expression usando o percorredor (operador de subtração); repita.
Se o token deste percorredor for any plus, compile o expression usando o percorredor (operador de adição); repita.
Se o token deste percorredor for any operador de concatenação, compile o expression usando o percorredor (operador de concatenação); repita.
Se o token deste percorredor for any times, compile o expression usando o percorredor (operador de multiplicação); repita.
Se o token deste percorredor for "junto", compile o expression usando o percorredor (operador de concatenação); repita.
Se o token deste percorredor for "juntamente", compile o expression usando o percorredor (operador de concatenação); repita.
Se o token deste percorredor for "seguido", compile o expression usando o percorredor (operador de concatenação); repita.
Se o token deste percorredor for "acompanhado", compile o expression usando o percorredor (operador de concatenação); repita.

Etapas necessárias para que se compile um expression usando um percorredor (operador de divisão):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any by, apresente uma mensagem de erro contendo "Você deve usar o termo 'divided BY'." e o percorredor; exit.
Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "Termo 'divided by' inválido, há um erro na variável: " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'divided by', está errado. Não dá pra dividir por: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "divida" e o intermediate e "por" e a variável deste termo e o first deste token deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de subtração):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'minus', está errado. Não consigo subtrair o(a): " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'minus', está errado. Não consigo diminuir do(a): " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "subtraia" e a variável deste termo e "from" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de adição):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar o: " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador). \talvez fosse o caso de repetir aqui
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'plus', está errado. Não consigo somar um: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste token deste percorredor.\aqui muda o atribua
Adicione several fragments usando "adicione" e a variável deste termo e "para" e o intermediate e o first deste token deste percorredor. \ aqui muda o add
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de concatenação):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any palavra de concatenação, apresente uma mensagem de erro contendo "Você deve usar o termo 'junto DE/junto COM/etc'." e o percorredor; exit.
Se a variável desta expression for inexistente, apresente a mensagem de erro contendo "O seu 'then', está errado. Eu não entendi a variável da expressão: " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor. \\ aqui que deve compilar o termo
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'then', está errado. Eu não achei a variável do termo: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando "string" e o first deste token deste percorredor.
Adicione o atribua ou converta fragments usando a variável desta expression e o intermediate e o first deste token deste percorredor.
Converta o termo por concatenation usando o percorredor. \\ aqui faz a concatenação
Adicione several fragments usando "posponha" e a variável deste termo e "para" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile um expression usando um percorredor (operador de multiplicação):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar o: " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "O seu 'times', está errado. Eu não sei como multiplicar um: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando o type nome desta expression e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variável desta expression e "para" e o intermediate e o first deste token deste percorredor.
Adicione several fragments usando "multiplique" e o intermediate e "por" e a variável deste termo e o first deste token deste percorredor.
Atribua o intermediate à variável desta expression.
Limpe a phrase desta expression.

Etapas necessárias para que se compile o header of uma routine:
Se a routine for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Lance um percorredor sobre a routine header desta routine.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any decide, compile o header of a routine usando o percorredor (rotina deliberativa); exit.
Se o percorredor for o start of any reverse-possessive function, compile o header of a routine usando o percorredor (função do possessivo reverso); exit.
Se o percorredor for o start of any function, compile o header of a routine usando o percorredor (função); exit.
Se o token deste percorredor for "compativelmente", compile o header of a routine usando o percorredor (modo de compatibilidade); exit.
Compile o header of a routine usando o percorredor (procedimento).

Etapas necessárias para que se compile o header of uma routine usando um percorredor (modo de compatibilidade):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Ligue o detector de compatibilidade desta routine.
Compile os monikettes desta routine e os parâmetros desta routine usando o percorredor.
Converta os monikettes desta routine para o cabeçalho expandido desta routine.
Se o cabeçalho expandido desta routine estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já tinha escrito um função: " seguido de o cabeçalho expandido desta routine seguido de "." e o local de aparição desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (rotina deliberativa):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any conditional, apresente uma mensagem de erro contendo "Erro na sintaxe do comando 'Para que se determine se'" e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Ligue o detector de deliberação desta routine.
Compile os monikettes desta routine e os parâmetros desta routine usando o percorredor.
Se any of os monikettes desta routine forem negative palavras, apresente a mensagem de erro contendo "Não consigo me dar bem com palavras negativas em nomes de funções decisoras." e o percorredor; exit.
Converta os monikettes desta routine para o cabeçalho expandido desta routine.
Se o cabeçalho expandido desta routine estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Você já me contou como'" seguido de o cabeçalho expandido desta routine seguido de "." e o local de aparição desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o header of uma routine usando um percorredor (função):
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de função desta routine.
Adicione um monikette para os monikettes desta routine usando "atribua".
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any artigo indefinido, acione um detector.
Se o detector estiver ativo, compile os monikettes desta routine e os parâmetros desta routine usando o percorredor (artigo indefinido).
Se o detector não estiver ativo, compile os monikettes desta routine e os parâmetros desta routine usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, apresente uma mensagem de erro contendo "Tá faltando um 's por aqui (ou está no lugar errado)." e o percorredor; exit. \ not translated - no possessives em Spanish
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Adicione uma segunda monikette para os monikettes desta routine usando "'s " seguido de o nome.
Se o token deste percorredor não for "para", apresente a mensagem de erro contendo "Eu estava esperando um palavra 'into/para', mas encontrei a palavra: " seguido de o token deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Adicione um terceiro monikette para os monikettes desta routine usando "para".
Converta os monikettes desta routine para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Eu já sei como: " seguido de o cabeçalho expandido seguido de "." e o local de aparição desta routine; exit. \ not translated - no possessives em Spanish
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Estava esperando um artigo indefinido, mas achei isso aqui: " seguido de o token deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Compile os monikettes desta routine e os parâmetros desta routine usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Tem comandos extras no fim dessa função." e o percorredor; exit. \ not translated - no possessives em Spanish
Converta os monikettes desta routine para o cabeçalho expandido desta routine.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas. \ por employs

Etapas necessárias para que se compile o header of uma routine usando um percorredor (procedimento):
Se o detector de erros deste compilador estiver ativado, cancele.
Compile os monikettes desta routine e os parâmetros desta routine usando o percorredor.
Converta os monikettes desta routine para o cabeçalho expandido desta routine.
Se o cabeçalho expandido desta routine estiver no catálogo geral de rotinas, apresente uma mensagem de erro contendo "Você já escreveu como fazer: " seguido de o cabeçalho expandido desta routine seguido de "." e o local de aparição desta routines; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.

Etapas necessárias para que se compile o headers of alguns routines:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma routine from as routines.
Se a routine for inexistente, cancele.
Compile o header of a routine.
Repita.

Etapas necessárias para que se compile um literal usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione o literal para os literals usando o first deste token deste percorredor .
\Se o token deste percorredor for any detector literal, compile o literal usando o percorredor (detector); exit.
Se o token deste percorredor for any hex literal, compile o literal usando o percorredor (hex); exit.
Se o token deste percorredor for any numeric literal, compile o literal usando o percorredor (numeric); exit.
Se o token deste percorredor for any endereço de memória literal, compile o literal usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any string literal, compile o literal usando o percorredor (string); exit.
Apresente uma mensagem de erro contendo "Erro interno - compile um termo usando um percorredor (literal)" e o percorredor.

Etapas necessárias para que se compile um literal usando um percorredor (detector):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o token deste percorredor para um detector.
Converta o detector para os data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "detector" ao type nome deste literal.
Resolva o literal. \\ Que tal utilizar os termos "decifre", "traduza", "destrinche", "decodifique"?

Etapas necessárias para que se compile um literal usando um percorredor (hex):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o token deste percorredor para um parte da cifra binária.
Adicione 1 para o first desta parte da cifra binária.
Converta o parte da cifra binária para o data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "texto hexadecimal" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - integer):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o token deste percorredor para um número.
Converta o número para os data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "número" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - ratio):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o token deste percorredor para um ratio.
Converta o ratio para o data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "ratio" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric - com unit of measure):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o token deste percorredor para um ratio.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Encontre um type usando o nome e o catálogo de tipos.
Se o type for inexistente, apresente uma mensagem de erro contendo "'" seguido de o nome seguido de "' é uma unidade de medida inexistente." e o local de aparição deste literal; exit.
Se o type não puder ser reduzido para "número", apresente a mensagem de erro contendo "'" seguido de o nome seguido de "' é uma unidade de medida inválida." e o local de aparição deste literal; exit.
Atribua a scale deste type para um final ratio.
Se a scale deste type for 0, atribua 1/1 ao final ratio.
Multiplique o final ratio pelo ratio.
Reduce o final ratio.
Se o denominador deste final ratio for 0, apresente a mensagem de erro contendo "Parece que essa é uma unidade de medida inválida." e o local de aparição deste literal.
Atribua o numerador deste final ratio dividido pelo denominador deste final ratio para um número.
Atribua o nome deste type ao type nome deste literal.
Converta o número para o data deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (numeric):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver followed por any unit of measure, compile o literal usando o percorredor (numeric - com unit of measure); exit.
Se o token deste percorredor for any integer literal, compile o literal usando o percorredor (numeric - integer); exit.
Se o token deste percorredor for any ratio literal, compile o literal usando o percorredor (numeric - ratio); exit.
Se o token deste percorredor for any mixed literal, compile o literal usando o percorredor (numeric - ratio); exit.

Etapas necessárias para que se compile um literal usando um percorredor (endereço de memória):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta 0 para os data deste literal. \ was nil
Mova o percorredor (usando diretrizes do compilador).
Atribua "endereço de memória" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile um literal usando um percorredor (string):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o token deste percorredor a os data deste literal.
Unquote os data deste literal.
Mova o percorredor (usando diretrizes do compilador).
Atribua "string" ao type nome deste literal.
Resolva o literal.

Etapas necessárias para que se compile alguns monikettes e alguns parâmetros usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any artigo definido, compile os monikettes e o parâmetros usando o percorredor (artigo definido); repita.
Se o percorredor estiver sobre any artigo indefinido, compile os monikettes e o parâmetros usando o percorredor (artigo indefinido); repita.
Se o percorredor estiver sobre any monikette string, compile os monikettes e o parâmetros usando o percorredor (monikette string); repita.
Apresente uma mensagem de erro contendo "'" seguido de o token deste percorredor seguido de "' não é um nome de função que eu conheça." e o percorredor.

Etapas necessárias para que se compile alguns monikettes e alguns parâmetros usando um percorredor (artigo definido):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Anteponha "the " para o nome.
Adicione um monikette para os monikettes usando o nome.

Etapas necessárias para que se compile alguns monikettes e alguns parâmetros usando um percorredor (artigo indefinido):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um parâmetro para o parâmetros usando "parâmetro" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", atribua "outra" ao nome deste parâmetro.
Se o token deste percorredor for "outro", atribua "outro" ao nome deste parâmetro.
Se o token deste percorredor for "segundo", atribua "segundo" ao nome deste parâmetro.
Se o token deste percorredor for "segunda", atribua "segunda" ao nome deste parâmetro.
\CAL
Se o token deste percorredor for "another", atribua "segunda" ao nome deste parâmetro.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Extend o nome destes parâmetro com o nome.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o parâmetro.
Resolva o parâmetro.
Se o parâmetro estiver duplicada no parâmetros, apresente uma mensagem de erro contendo "Cara, você repetiu o parâmetro: " seguido de o nome deste parâmetro seguido de "." e o local de aparição deste parâmetro; exit.
Adicione um monikette para os monikettes usando o type deste parâmetro.

Etapas necessárias para que se compile alguns monikettes e alguns parâmetros usando um percorredor (monikette string):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um monikette para os monikettes usando o token deste percorredor.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile alguns monikettes usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre any monikette string, adicione um monikette para os monikettes usando o token deste percorredor; mova o percorredor (usando diretrizes do compilador); repita.
Se o token deste percorredor não for o start of any expression, cancele.
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione uma segunda monikette para os monikettes usando o expression.
Repita.

\Etapas necessárias para que se compile alguns monikettes usando um percorredor:
\Se o detector de erros deste compilador estiver ativado, cancele.
\Se o token deste percorredor for any monikette string, adicione um monikette para os monikettes usando o token deste percorredor; mova o percorredor (usando diretrizes do compilador); repita.
\Se o token deste percorredor não for o start of any expression, cancele.
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, cancele.
\Adicione uma segunda monikette para os monikettes usando o expression.
\Repita.

Etapas necessárias para que se compile o próximo satement usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor for any conditional, compile o próximo satement usando o percorredor (if); exit.
Se o token deste percorredor for any loop, compile o próximo satement usando o percorredor (loop); exit.
Se o token deste percorredor for any privatize, compile o próximo satement usando o percorredor (privatize); exit.
Se o token deste percorredor não for o start of any statement, apresente uma mensagem de erro contendo "Eu esperava uma declaração aqui, mas encontrei: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Compile o próximo satement usando o percorredor (other).
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Tem algum problema nesse comando aqui." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile o próximo satement usando um percorredor (break):
Adicione um fragment usando o break tag.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile o próximo satement usando um percorredor (call - external):
Atribua o token deste percorredor para um string.
Unquote o string.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any string literal, apresente uma mensagem de erro contendo "Cara, você precisa colocar os nomes entre aspas, mas você colocou: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Atribua o token deste percorredor para uma segunda string.
Unquote a segunda string.
Mova o percorredor (usando diretrizes do compilador).
Adicione um entry para o imports usando o string e a segunda string.
Se o token deste percorredor for "with", compile o próximo satement usando o percorredor (call - cláusula com).
Se o token deste percorredor for "com", compile o próximo satement usando o percorredor (call - cláusula com).
Se o token deste percorredor for "contendo", compile o próximo satement usando o percorredor (call - cláusula com).
Se o token deste percorredor for "usando", compile o próximo satement usando o percorredor (call - cláusula com).
Se o token deste percorredor for "devolvendo", compile o próximo satement usando o percorredor devolvendo um termo (call - cláusula devolvendo).
\\Se o token deste percorredor for "entregando", compile o próximo satement usando o percorredor devolvendo um terceiro termo (call - cláusula devolvendo).
\\Se o token deste percorredor for "apimorando", compile o próximo satement usando o percorredor devolvendo um quarto termo (call - cláusula devolvendo).
\\Se o token deste percorredor for "aperfeiçoando", compile o próximo satement usando o percorredor devolvendo um quinto termo (call - cláusula devolvendo).
\\Se o token deste percorredor for "melhorando", compile o próximo satement usando o percorredor devolvendo um sexto termo (call - cláusula devolvendo).
Adicione um fragment usando o call external tag e o entry.
Se o termo estiver vazio, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Não entendi bem o que é: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um segundo fragment usando o save eax tag e a variável deste termo.

Etapas necessárias para que se compile o próximo satement usando um percorredor (call - indirect):
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não sei o que é: " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
Se o type desta expression não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Eu preciso de um endereço de memória type nesse CALL statement." e o percorredor; exit.
Se o token deste percorredor for "with", compile o próximo satement usando o percorredor (call - cláusula com).
Se o token deste percorredor for "com", compile o próximo satement usando o percorredor (call - cláusula com).
Se o token deste percorredor for "contendo", compile o próximo satement usando o percorredor (call - cláusula com).
Se o token deste percorredor for "devolvendo", compile o próximo satement usando o percorredor devolvendo um termo (call - cláusula devolvendo).
Adicione um fragment usando o call indirect tag e a variável desta expression.
Se o termo estiver vazio, cancele.
Se a variável deste termo for inexistente, apresente a mensagem de erro contendo "Acho que essa varíavel é inválida: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um segundo fragment usando o save eax tag e a variável deste termo.

Etapas necessárias para que se compile o próximo satement usando um percorredor (call - internal):
Compile alguns monikettes usando o percorredor.
Encontre uma routine usando os monikettes.
Se a routine não for inexistente, adicione push fragments usando os monikettes.
Se a routine não for inexistente, destrua os monikettes; adicione um fragment usando o call internal tag e a routine; exit.
Converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
\Atribua "Eu ainda não aprendi como" à reply.
\Say o reply.
Atribua o cabeçalho expandido à reply.
\Say o reply.
Apresente uma mensagem de erro contendo "Eu ainda não aprendi como: " seguido de o cabeçalho expandido seguido de "." e o percorredor.

Etapas necessárias para que se compile o próximo satement usando um percorredor (call - cláusula com):
\ this guy é recursise so parâmetros obtenha passed right para left
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Eu não entendi a variável: " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "'" seguido de o nome deste type desta expression seguido de "' não pode ser processado corretamente." e o percorredor; exit.
Se o token deste percorredor for any and, compile o próximo satement usando o percorredor (call - cláusula com).
Adicione um fragment usando o push value tag e a variável desta expression.

Etapas necessárias para que se compile o próximo satement usando um percorredor (call):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any string literal, compile o próximo satement usando o percorredor (call - external); exit.
Compile o próximo satement usando o percorredor (call - indirect).

Etapas necessárias para que se compile o próximo satement usando um percorredor (exit):
Se o detector de deliberação desta rotina utilizada atualmente estiver ativo, apresente uma mensagem de erro contendo "O que a palvra 'exit' significa aqui? Sim? Não? Talvez?" e o percorredor; exit.
Adicione um fragment usando o exit tag.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile o próximo satement usando um percorredor (if):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile alguns monikettes usando o percorredor.
Remove any negatives from os monikettes devolvendo um detector.
Encontre uma routine usando os monikettes.
Se a routine não for inexistente, adicione push fragments usando os monikettes.
Se a routine for inexistente, converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Preciso de um decider que tenha as palavras: " seguido de o cabeçalho expandido seguido de "." e o percorredor; exit.
Se o detector de deliberação desta routine não estiver ativo, apresente a mensagem de erro contendo "Cara eu vou precisar de um decider aqui, blz?" e o percorredor; exit.
Se o token deste percorredor não for a vírgula, apresente a mensagem de erro contendo "Acho que você esqueceu de uma vírgula, eu achei isso aqui: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Adicione um fragment usando o call internal tag e a routine.
Se o detector estiver ativo, adicione um segundo fragment usando o not tag.
Adicione um terceiro fragment usando o jump false tag.
Mova o percorredor (usando diretrizes do compilador).
Percorra.
Compile o próximo satement usando o percorredor (other).
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor for o ponto&vírgula, mova o percorredor (usando diretrizes do compilador); repita.
Se o token deste percorredor for "Senão", mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for "Caso", mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for "contrário", mova o percorredor (usando diretrizes do compilador).
\Se o token deste percorredor for a vírgula, mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você precisa usar um ponto ao invés de usar o termo: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Adicione um quarto fragment usando o end if tag.

Etapas necessárias para que se compile o próximo satement usando um percorredor (Intel):
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any hex literal, apresente uma mensagem de erro contendo "Eu preciso de um pouco de machine code, mas o que eu achei foi: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Adicione um fragment usando o Intel tag.
Atribua o token deste percorredor para um parte da cifra binária.
Adicione 1 para o first desta parte da cifra binária.
Converta o parte da cifra binária para o code deste fragment.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile o próximo satement usando um percorredor (loop):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um fragment usando o loop tag.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Parece que alguém esqueceu de colocar um ponto por aí." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile o próximo satement usando um percorredor (other):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for any exit, compile o próximo satement usando o percorredor (exit); exit.
Se o token deste percorredor for any repeat, compile o próximo satement usando o percorredor (repeat); exit.
Se o token deste percorredor for any break, compile o próximo satement usando o percorredor (break); exit.
Se o token deste percorredor for any say, compile o próximo satement usando o percorredor (say); exit.
Se o token deste percorredor for "Intel", compile o próximo satement usando o percorredor (Intel); exit.
Se o token deste percorredor for "push", compile o próximo satement usando o percorredor (push); exit.
Se o token deste percorredor for any call, compile o próximo satement usando o percorredor (call); exit.
Se o token deste percorredor for any point, compile o próximo satement usando o percorredor (point); exit.
Se o token deste percorredor for any conditional, apresente uma mensagem de erro contendo "Colocar vários SE dentros um do outro nunca dá muito certo. Melhor fazer tudo de novo." e o percorredor; exit.
Se o token deste percorredor for any privatize, apresente a mensagem de erro contendo "A sentença 'privatizar' não pode ser usada aqui." e o percorredor; exit.
Se o token deste percorredor for any loop, apresente a mensagem de erro contendo "Usar um percorra dentro de um SE for uma ótima forma de arranjar problemas." e o percorredor; exit.
Se o token deste percorredor for any employ, apresente a mensagem de erro contendo "'Empregue' deve ser o único imperativo em uma rotina." e o percorredor; exit.
Compile o próximo satement usando o percorredor (call - internal).

Etapas necessárias para que se compile o próximo satement usando um percorredor (point):
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Acho que o termo: " seguido de a phrase deste termo seguido de "' está vazio." e o percorredor; exit.
Se o categoria deste termo for "literal", apresente a mensagem de erro contendo "Você usou o tipo errado de variável aqui (literal)." e o percorredor.
Se o length deste type deste termo não for 4, apresente a mensagem de erro contendo "Você usou uma variável de comprimento errado (<>4)." e o percorredor.
Se o token deste percorredor não for "para", apresente a mensagem de erro contendo "Acho que faltou um 'para/to', mas você usou: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for "routine", apresente a mensagem de erro contendo "Acho que faltou a palavra 'routine'. Você usou o termo: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile uma routine reference usando o percorredor.
Converta a routine reference para um cabeçalho expandido.
Destrua a routine reference.
Encontre uma routine usando o cabeçalho expandido e o catálogo geral de rotinas.
Se a routine for inexistente, apresente a mensagem de erro contendo "Não achei a tarefa: " seguido de o cabeçalho expandido seguido de "' que você falou." e o percorredor; exit.
Adicione um fragment usando a routine address tag e a routine.
Atribua a variável deste termo à variável deste fragment.

Etapas necessárias para que se compile o próximo satement usando um percorredor (privatize):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile um termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Comando 'privatize', Inválido. Eu acho que o termo da variável: " seguido de a phrase deste termo seguido de "' está vazio." e o percorredor; exit.
Se o categoria deste termo não for "parâmetro", apresente a mensagem de erro contendo "Você só pode privatizar parâmetros." e o percorredor; exit.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
Atribua o nome deste termo ao nome deste local.
Atribua o nickname deste termo ao nickname deste local.
Atribua o type nome deste termo ao type nome deste local.
Resolva o local.
Anteponha "original " para o nome deste termo.
Se o nickname deste termo não estiver em branco, Anteponha "original " para o nickname deste termo.
Adicione several fragments usando "atribua" e a variável deste termo e "para" e o local e o first deste token deste percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você vive esquecendo dos pontos né?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile o próximo satement usando um percorredor (push):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile um expression usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "Comando 'push' inválido, um expressão: " seguido de a phrase desta expression seguido de "' parece estar vazia." e o percorredor; exit.
Se o type desta expression não for value pushable, apresente a mensagem de erro contendo "Valores do tipo: " seguido de o nome deste type desta expression seguido de "' não podem ser pushed." e o percorredor; exit.
Adicione um fragment usando o push value tag e a variável desta expression.

Etapas necessárias para que se compile o próximo satement usando um percorredor (repeat):
Adicione um fragment usando o repeat tag.
Mova o percorredor (usando diretrizes do compilador).

\Etapas necessárias para que se compile o próximo satement usando um percorredor (say):
\Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile o próximo satement usando o percorredor (call - internal); exit.
\Mova o percorredor (usando diretrizes do compilador).
\Compile um expression usando o percorredor.
\Se o detector de erros deste compilador estiver ativado, cancele.
\Se a variável desta expression for inexistente, apresente uma mensagem de erro contendo "No es válido este 'diga', no entiendo la variável: " seguido de a phrase desta expression seguido de "." e o percorredor; exit.
\Se o type desta expression não puder ser reduzido para "detector", apresente uma mensagem de erro contendo "Necesito un rotundo 'si' o 'no' aquí." e o percorredor; exit.
\Adicione um fragment usando o load eax tag e a variável desta expression.
\Adicione um segundo fragment usando o exit tag.

Etapas necessárias para que se compile o próximo satement usando um percorredor (say):
Se o detector de deliberação desta rotina utilizada atualmente não estiver ativo, compile o próximo satement usando o percorredor (call - internal); exit.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any decider literal, apresente uma mensagem de erro contendo "Você precisa terminar com um yes ou no." e o percorredor; exit.
Desative um detector. Se o token deste percorredor for any positive decider literal, acione o detector.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Faltou um ponto. Você usou o termo: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Adicione um fragment usando o load eax tag e o detector.
Adicione um segundo fragment usando o exit tag.

Etapas necessárias para que se compile o próximo satement usando um percorredor devolvendo um termo (call - cláusula devolvendo):
Mova o percorredor (usando diretrizes do compilador).
Compile o termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Eu não compreendi o termo da variável: " seguido de a phrase deste termo seguido de "'. Ela parece estar vazia." e o percorredor; exit.
Se o type deste termo não for value pushable, apresente a mensagem de erro contendo "Uma varíavel de 1, 2, ou 4-pedaços é necessária na 'devolvendo' clause." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor:
Se o token deste percorredor for "para", mova o percorredor (usando diretrizes do compilador).
Se o percorredor for o start of any function, compile a routine reference usando o percorredor (função); exit.
Se o token deste percorredor for any decide, compile a routine reference usando o percorredor (decide).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for ".", cancele.
Se o token deste percorredor for any artigo definido, compile a routine reference usando o percorredor (artigo definido); repita.
Se o token deste percorredor for any artigo indefinido, compile a routine reference usando o percorredor (artigo indefinido); repita.
Se o percorredor está sobre any monikette string, compile a routine reference usando o percorredor (monikette string); repita.
Apresente uma mensagem de erro contendo "'" seguido de o token deste percorredor seguido de "' não é válido em um employ statement." e o percorredor.

Etapas necessárias para que se compile uma routine reference usando um percorredor (decide):
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any conditional, apresente uma mensagem de erro contendo "Sempre use DECIDE IF, ao invés de apenas DECIDE com: " seguido de o token deste percorredor seguido de "' logo em seguida." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo definido):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Anteponha "the " para o nome.
Adicione um monikette para a routine reference usando o nome.

Etapas necessárias para que se compile uma routine reference usando um percorredor (função):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um monikette para a routine reference usando "atribua".
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any artigo indefinido, acione um detector.
Se o detector estiver ativo, compile a routine reference usando o percorredor (artigo indefinido).
Se o detector não estiver ativo, compile a routine reference usando o percorredor (artigo definido).
Se o token deste percorredor não for any possessive, apresente uma mensagem de erro contendo "Eu estava esperando un 's, mas apareceu: " seguido de o token deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Adicione uma segunda monikette para a routine reference usando "'s " seguido de o nome.
Se o token deste percorredor não for "para", apresente a mensagem de erro contendo "E estava esperando a palavra 'para/into', mas encontrei: " seguido de o token deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Adicione um terceiro monikette para a routine reference usando "para".
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Eu estava esperando um artigo indefinido mas encontrei isso: " seguido de o token deste percorredor seguido de "." e o percorredor; exit. \ not translated - no possessives em Spanish
Compile a routine reference usando o percorredor (artigo indefinido).

Etapas necessárias para que se compile uma routine reference usando um percorredor (artigo indefinido):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Encontre um type e um nickname usando o nome.
Se o type for inexistente, apresente uma mensagem de erro contendo "Employ statement inválido, Eu não sei o que é: " seguido de o nome seguido de "." e o percorredor; exit.
Adicione um monikette para a routine reference usando o type.

Etapas necessárias para que se compile uma routine reference usando um percorredor (monikette string):
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um monikette para a routine reference usando o token deste percorredor.
Mova o percorredor (usando diretrizes do compilador).

Etapas necessárias para que se compile um termo usando um percorredor:
Limpe o termo.
Se o detector de erros deste compilador estiver ativado, cancele.
Compile o termo usando o percorredor (common part).
Se o percorredor está sobre any simile, cancele. \ added for invisible turtle project ***
\Se o token deste percorredor for "as", compile o termo usando o percorredor (as part). \preposição
\Se o token deste percorredor for "tão", compile o termo usando o percorredor (as part). \ me parece desnecessário por ser usado apenas em funções.
Se o token deste percorredor for "quão", compile o termo usando o percorredor (as part).
Se o token deste percorredor for "quanto", compile o termo usando o percorredor (as part).
Se o token deste percorredor for "como", compile o termo usando o percorredor (as part).
\Se o token deste percorredor for "que nem", compile o termo usando o percorredor (as part).
Se o token deste percorredor for "/", compile o termo usando o percorredor (runtime ratio).

Etapas necessárias para que se compile um termo usando um percorredor (as part):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Comando 'as' inválido. Eu acho que um variável: " seguido de a phrase deste termo seguido de "' está vaiza." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Tá faltando um artigo indefinido depois do 'como', mas você escreveu: " seguido de o token deste percorredor seguido de "' no lugar disso." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine um type nome usando o percorredor.
Encontre um type usando o type nome e o catálogo de tipos.
Se o type for inexistente, apresente a mensagem de erro contendo "Eu não sei em qual tipo o: " seguido de o type nome seguido de "' se encaixa." e o percorredor; exit.
Adicione um scratch usando o nome deste type e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variável deste termo e o scratch.
Atribua o scratch à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (common part):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor for o hífem, compile o termo usando o percorredor (negated termo); exit.
Se o token deste percorredor for o sinal de adição, compile o termo usando o percorredor (posigated termo); exit.
Se o token deste percorredor for o start of any variável, compile o termo usando o percorredor (variável); exit.
Se o token deste percorredor for o start of any new local, compile o termo usando o percorredor (new local); exit.
Se o token deste percorredor for any literal, compile o termo usando o percorredor (literal); exit.
Apresente uma mensagem de erro contendo "Faltou um termo por aqui. Só achei isso aqui: " seguido de o token deste percorredor seguido de "." e o percorredor.

Etapas necessárias para que se compile um termo usando um percorredor (dereference - em place):
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro interno na função - compile um termo usando um percorredor (dereference - em place). Termo vazio" e o percorredor; exit.
Atribua o nome deste target type deste type deste termo ao type nome deste termo.
Atribua o target type deste type deste termo ao type deste termo.
Adicione um fragment usando o dereference tag e a variável deste termo.
Limpe o phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (dereference):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Dereference inválido, um variável: " seguido de a phrase deste termo seguido de "' parece estar vazia." e o percorredor; exit.
Se o target type deste type deste termo for inexistente, apresente a mensagem de erro contendo "Não consegui identificar o tipo desse target." e o percorredor; exit.
Se a categoria deste termo for "scratch", compile o termo usando o percorredor (dereference - em place); exit.
Adicione um scratch usando o nome deste target type deste type deste termo e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variável deste termo e o scratch.
Adicione um segundo fragment usando o dereference tag e o scratch.
Atribua o scratch ao variável deste termo.
Limpe o phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (literal):
Se o detector de erros deste compilador estiver ativado, cancele.
Compile um literal usando o percorredor.
Atribua o literal ao variável deste termo.
Limpe o phrase deste termo.
Compile o termo usando o percorredor (possessives).

Etapas necessárias para que se compile um termo usando um percorredor (negated termo):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile uma segunda termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste segunda termo for inexistente, apresente uma mensagem de erro contendo "Negate inválido, um variável: " seguido de o phrase deste segunda termo seguido de "' parece estar vazia." e o percorredor; exit.
Adicione um intermediate usando o type nome deste segunda termo e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e o variável deste segunda termo e "para" e o intermediate e o local de aparição deste segunda termo.
Adicione two fragments usando "negate" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate ao variável deste termo.
Limpe o phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (new local):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Parece que essa tarefa não existe. Não achei nada pra pull da pilha por aqui." e o percorredor; exit.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", atribua "outra" ao nome deste local.
Se o token deste percorredor for "outro", atribua "outro" ao nome deste local.
Se o token deste percorredor for "segundo", atribua "segundo" ao nome deste local.
Se o token deste percorredor for "segunda", atribua "segunda" ao nome deste local.
\CAL
Se o token deste percorredor for "another", atribua "segunda" ao nome deste local.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Extend o nome deste local com o nome.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente a mensagem de erro contendo "o parâmetro: " seguido de o nome deste local seguido de "' já está sendo usado como parâmetro." e o local de aparição deste local; exit.
Se o local estiver duplicada em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "Já existe uma variável local chamada'" seguido de o nome deste local seguido de "'. Você tem que dar um nome diferente." e o local de aparição deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname catálogo desta rotina utilizada atualmente.
Atribua o local à variável deste termo.
Limpe a phrase deste termo.
Compile o termo usando o percorredor (possessives).

Etapas necessárias para que se compile um termo usando um percorredor (posigated termo):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Compile o termo usando o percorredor.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Posigate inválido, o termo da variável'" seguido de a phrase deste termo seguido de "' parece estar vazio." e o percorredor; exit.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (possessive - magnitude):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Use da magnitude inválido. A variável: " seguido de a phrase deste termo seguido de "' parece estar vazia." e o percorredor; exit.
Adicione um literal para os literals usando o first deste token deste percorredor.
Converta o length deste type deste termo para os data deste literal.
Atribua "número" ao type nome deste literal.
Resolva o literal.
Atribua o literal à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (possessive - target):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou o target de forma errada. O termo da variável: " seguido de a phrase deste termo seguido de "' parece estar vazio." e o percorredor; exit.
Se o type deste termo não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Você só pode usar target com tipos endereço de memória." e o percorredor; exit.
Compile o termo usando o percorredor (dereference).

Etapas necessárias para que se compile um termo usando um percorredor (possessive - whereabouts):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou whereabouts da forma errada, erro no termo da variável: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando "endereço de memória" e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variável deste termo e o intermediate.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (possessive):
\ similar para "compile um termo usando um percorredor (possessivo reverso)
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o nome for any magnitude, compile o termo usando o percorredor (possessive - magnitude); exit.
Se o nome for any target, compile o termo usando o percorredor (possessive - target); exit.
Se o nome for any whereabouts, compile o termo usando o percorredor (possessive - whereabouts); exit.
Compile o termo usando o percorredor e o nome (possessive - campo).

Etapas necessárias para que se compile um termo usando um percorredor (possessives):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any possessive, cancele.
Compile o termo usando o percorredor (possessive).
Repita.

Etapas necessárias para que se compile um termo usando um percorredor (runtime ratio):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Você usou o / (proporção da execução) da forma errada, erro de termo vazio na variável: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Compile uma segunda termo usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o variável deste segunda termo for inexistente, apresente a mensagem de erro contendo "Uso inválido da /, termo vazio da variável: " seguido de o phrase deste segunda termo seguido de "." e o percorredor; exit.
Adicione um intermediate usando "ratio" e o first deste token deste percorredor.
Adicione several fragments usando "atribua" e a variável deste termo e "e" e a variável deste segunda termo e "para" e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor (variável):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a rotina utilizada atualmente for inexistente, apresente uma mensagem de erro contendo "Erro de tarefa vazia, nada pra pull da pilha aqui." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o percorredor está sobre any reverse-possessive, compile o termo usando o percorredor e o nome (possessivo reverso); exit.
Encontre uma variável usando o nome.
Atribua o variável à variável deste termo.
Atribua "the " à phrase deste termo.
Posponha o nome para a phrase deste termo.
Compile o termo usando o percorredor (possessives).

Etapas necessárias para que se compile um termo usando um percorredor e um campo nome (possessivo reverso):
\ this é recursive \ dahn version 2
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador). \ past o reverse-possessive starter
\Se o token deste percorredor não for "del", Mova o percorredor (usando diretrizes do compilador). \ past o reverse-possessive starter \ gerry added "if" part
\Se o token deste percorredor for "del", adicione 1 para o first deste token deste percorredor. \ makes "del" look like "de el"
Se o token deste percorredor não for any article, apresente uma mensagem de erro contendo "Esperaba un artículo, pero encontré: " seguido de o token deste percorredor seguido de "."; exit.
Atribua o token deste percorredor para um article token.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o percorredor está sobre any reverse-possessive, acione um reverse-possessive detector.
Se o reverse-possessive detector estiver ativo, compile o termo usando o percorredor e o nome (possessivo reverso).
Se o reverse-possessive detector não estiver ativo, compile o termo usando o percorredor e o nome e o article (reversão de contrações do possessivo).
Compile o termo usando o campo nome e o percorredor (possessivo reverso).

Etapas necessárias para que se compile um termo usando um percorredor e uma variável nome e um article token (reversão de contrações do possessivo):
\ dahn version 2
Se o article for o start of any variável, compile o termo usando o percorredor e o variável nome e o article (reversão de contrações de variáveis do possessivo); exit.
Compile o termo usando o percorredor e o variável nome (reverse-possessive prepare para unwind new local).

Etapas necessárias para que se compile um termo usando um percorredor e uma variável nome e um article token (reversão de contrações de variáveis do possessivo):
\ dahn version 2
Encontre uma variável usando o variável nome.
Se o variável for inexistente, apresente uma mensagem de erro contendo "Não foi possível encontrar uma variável com o nome: " seguido de o variável nome seguido de ".".
Atribua o variável à variável deste termo.
Atribua "the " à phrase deste termo.
Posponha o variável nome para a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e uma variável nome (reverse-possessive prepare para unwind new local):
\ dahn version 2
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um local para os locals desta rotina utilizada atualmente usando "local" e o first deste token deste percorredor.
\PAL
Se o token deste percorredor for "outra", atribua "outra" ao nome deste local.
Se o token deste percorredor for "outro", atribua "outro" ao nome deste local.
Se o token deste percorredor for "segundo", atribua "segundo" ao nome deste local.
Se o token deste percorredor for "segunda", atribua "segunda" ao nome deste local.
\CAL
\Se o token deste percorredor for "another", atribua "segunda" ao nome deste local.
Extend o nome deste local com o variável nome.
Se o token deste percorredor for any called, compile o call'd part usando o percorredor e o local.
Resolva o local.
Se o local estiver duplicada em os parâmetros desta rotina utilizada atualmente, apresente uma mensagem de erro contendo "O termo: " seguido de o nome deste local seguido de "' já está sendo usado como parâmetro." e o local de aparição deste local; exit.
Se o local estiver duplicada em os locals desta rotina utilizada atualmente, apresente a mensagem de erro contendo "O termo: " seguido de o nome deste local seguido de "' já está sendo usado como variável local." e o local de aparição deste local; exit.
Eliminate duplicate nicknames usando o local e o nickname catálogo desta rotina utilizada atualmente.
Atribua o local à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um campo nome e um percorredor (possessivo reverso):
\ similar para "compile um termo usando um percorredor (possessive)" \ dahn
Se o detector de erros deste compilador estiver ativado, cancele.
Se o campo nome for any magnitude, compile o termo usando o percorredor (possessive - magnitude); exit.
Se o campo nome for any target, compile o termo usando o percorredor (possessive - target); exit.
Se o campo nome for any whereabouts, compile o termo usando o percorredor (possessive - whereabouts); exit.
Compile o termo usando o percorredor e o campo nome (possessive - campo).

Etapas necessárias para que se compile um termo usando um percorredor e um campo termo:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o dereference detector deste campo termo estiver ativo, compile o termo usando o percorredor (dereference).
Se o function deste campo termo não for inexistente, compile o termo usando o percorredor e o campo termo (função); exit.
Se o categoria deste termo for "scratch", compile o termo usando o percorredor e o campo termo (in place); exit.
Atribua o campo deste campo termo para um campo.
Adicione um scratch usando o nome deste type deste campo e o first deste token deste percorredor.
Adicione um fragment usando o load address tag e a variável deste termo e o scratch.
Se o offset deste campo não for 0, adicione um terceiro fragment usando o increment tag e o scratch e o offset deste campo.
Atribua o scratch à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e um campo termo (função):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o function deste campo termo para uma routine.
Atribua o last destes parâmetros desta routine para um parâmetro.
Se o parâmetro for inexistente, apresente uma mensagem de erro contendo "Erro interno na função compile um termo usando um percorredor e um campo termo (função) - parâmetro vazio." e o percorredor; exit.
Se o type deste parâmetro for inexistente, apresente a mensagem de erro contendo "Erro interno 2 na função compile um termo usando um percorredor e um campo termo (função) - tipo do parâmetro inexistente." e o percorredor; exit.
Adicione um intermediate usando o nome deste type deste parâmetro e o first deste token deste percorredor.
Adicione um fragment usando o push address tag e o intermediate.
Se o push detector deste campo termo estiver ativo, adicione um segundo fragment usando o push address tag e a variável deste termo.
Adicione um terceiro fragment usando o call internal tag e a routine.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e um campo termo (in place):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o campo deste campo termo para um campo.
Atribua o nome deste type deste campo ao type nome deste termo.
Atribua o type deste campo ao type deste termo.
Se o offset deste campo não for 0, adicione um terceiro fragment usando o increment tag e a variável deste termo e o offset deste campo.
Limpe a phrase deste termo.

Etapas necessárias para que se compile um termo usando um percorredor e um nome (possessive - campo):
Se o detector de erros deste compilador estiver ativado, cancele.
Se a variável deste termo não for inexistente, atribua o type deste termo para um type.
Encontre um campo termo usando o phrase deste termo e o type e o nome.
Se o campo termo não for vazio, compile o termo usando o percorredor e o campo termo; exit.
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro: variável vazia: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Se o type puder ser reduzido para "endereço de memória", atribua o target type deste type ao type.
Se o type for inexistente, apresente a mensagem de erro contendo "Não existe o campo: " seguido de o nome seguido de "' no tipo: " seguido de o nome deste type deste termo seguido de "." e o percorredor; exit.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type.
Se o campo for inexistente, apresente a mensagem de erro contendo "Não há nenhum campo: " seguido de o nome seguido de "' no tipo: " seguido de o nome deste type deste termo seguido de "." e o percorredor; exit.
Encontre um deep campo termo usando "" e o type deste campo e o nome.
Se o deep campo termo estiver vazio, repita.
Atribua o campo para o campo desse first campo termo.
Se o type deste termo puder ser reduzido para "endereço de memória", acione o dereference detector deste first campo termo.
Compile o termo usando o percorredor e o first campo termo.
Compile o termo usando o percorredor e o deep campo termo.

O compiling routine bodies temporizador é um temporizador.

O temporizador de compilação de cabeçalhos de rotina é um temporizador.

Etapas necessárias para que se converta alguns monikettes para um cabeçalho expandido:
Converta os monikettes para o cabeçalho expandido usando o last destes monikettes.

Etapas necessárias para que se converta alguns monikettes para um cabeçalho expandido usando um monikette:
Limpe o cabeçalho expandido.
Percorra.
Obtenha um current monikette from os monikettes.
Se o current monikette for inexistente, cancele.
Posponha o current monikette para o cabeçalho expandido.
Se o current monikette for o monikette, cancele.
Repita.

Etapas necessárias para que se converta uma parte da cifra binária para um string:
Employ converta um cifra hexadecimal para um texto hexadecimal.

Etapas necessárias para que se converta um termo por concatenation usando um percorredor: \\ concatenação
\ used for right-side seguido de operand
Se a variável deste termo for inexistente, apresente uma mensagem de erro contendo "Erro: a variável do termo está vazia: " seguido de a phrase deste termo seguido de "." e o percorredor; exit.
Se o type deste termo puder ser reduzido para "string", cancele.
Adicione um intermediate usando "string" e o first deste token deste percorredor.
Adicione o atribua ou converta fragments usando a variável deste termo e o intermediate e o first deste token deste percorredor.
Atribua o intermediate à variável deste termo.
Limpe a phrase deste termo.

Etapas necessárias para que se copy um campo para uma segundo campo:
Se o campo for inexistente, esvazie a segundo campo; exit.
Aloque memória para o segundo campo.
Atribua o local de aparição deste campo ao local de aparição deste segundo campo.
Atribua o nome deste campo ao nome deste segundo campo.
Atribua o nickname deste campo ao nickname deste segundo campo.
Atribua o type nome deste campo ao type nome deste segundo campo.
Atribua o type deste campo ao type deste segundo campo.
Atribua a contagem deste campo à contagem deste segundo campo.
Atribua o redefinition target nome deste campo ao redefinition target nome deste segundo campo.
Atribua o reference detector deste campo ao reference detector deste segundo campo.
Atribua o offset deste campo ao offset deste segundo campo.

Etapas necessárias para que se copy alguns campos para alguns segundo campos:
Obtenha um campo from o campos.
Se o campo for inexistente, cancele.
Copy o campo para uma segundo campo.
Posponha a segundo campo para a segundo campos.
Repita.

Etapas necessárias para que se copy alguns campos para alguns segundo campos (data campos only):
Se a contagem destes campos for menor do que 4, cancele. \ for english next e prev e spanish next e prev redefinitions
\Se o first destes campos for inexistente, cancele.
\Se o next deste first destes campos for inexistente, cancele.
\Se o next deste next deste first destes campos for inexistente, cancele.
\\Atribua o next deste next deste first destes campos para um campo. \ skip next e prev
\Se o next deste next deste next deste first destes campos for inexistente, cancele.
\Se o next deste next deste next deste next deste first destes campos for inexistente, cancele.
\Se o next deste next deste next deste next deste next deste first destes campos for inexistente, cancele.
\Atribua o next deste next deste next deste next deste first destes campos para um campo.
Atribua o next deste next deste next deste next deste first destes campos para um campo.\ english next e prev e spanish next e prev redefinitions
Percorra.
Se o campo for inexistente, cancele.
Copy o campo para uma segundo campo.
Posponha a segundo campo para a segundo campos.
Obtenha o campo from o campos.
Repita.

Etapas necessárias para que se copy um monikette para uma segunda monikette:
Se o monikette for inexistente, esvazie a segunda monikette; exit.
Aloque memória para o segunda monikette.
Atribua o string deste monikette ao string deste segunda monikette.
Atribua o type deste monikette ao type deste segunda monikette.
Atribua a variável deste monikette ao variável deste segunda monikette.
\ don't copy subtexto
Atribua o type atual deste monikette ao type atual deste segunda monikette.

Etapas necessárias para que se copy alguns monikettes para alguns segunda monikettes:
Destrua a segunda monikettes.
Percorra.
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Copy o monikette para uma segunda monikette.
Posponha a segunda monikette para a segunda monikettes.
Repita.

Etapas necessárias para que se crie um entry:
Aloque memória para o entry.

Etapas necessárias para que se crie um fragment usando uma tag:
Aloque memória para o fragment.
Atribua o tag à tag deste fragment.

Etapas necessárias para que se crie um import:
Aloque memória para o import.

Etapas necessárias para que se crie um monikette:
Aloque memória para o monikette.

Etapas necessárias para que se crie uma routine:
Aloque memória para a routine.

Etapas necessárias para que se crie um source file:
Aloque memória para o source file.

Etapas necessárias para que se crie um type:
Aloque memória para o type.
Atribua 0/1 ao scale deste type.
Atribua -1 ao length deste type.

Etapas necessárias para que se crie uma variável usando um categoria:
Aloque memória para o variável.
Atribua o categoria à categoria desta variável.
Atribua 1 à contagem desta variável.

O endereço do cabeçalho usado atualmente é um address.

O endereço do nome usado atualmente é um address.

O rotina utilizada atualmente é uma routine.

O current thunk address é um address.

O zona de dados é um zona.

Etapas necessárias para que se determine se any of alguns monikettes são negative palavras:
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, diga não.
Se o string deste monikette for any negative palavra, diga sim.
Repita.

Etapas necessárias para que se determine se um pedaço é any glom pedaço:
Se o pedaço for any letra, diga sim.
Se o pedaço for any digit, diga sim.
Se o pedaço for o acento til, diga sim.
Se o pedaço for o sinal de arroba, diga sim.
Se o pedaço for o número-sign pedaço, diga sim.
Se o pedaço for o sinal de porcentagem, diga sim.
Se o pedaço for o & comercial, diga sim.
Se o pedaço for o underscore pedaço, diga sim.
Se o pedaço for o single-quote pedaço, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any mark:
Se o pedaço for o ponto final, diga sim.
Se o pedaço for o vírgula, diga sim.
Se o pedaço for o ponto&vírgula, diga sim.
Se o pedaço for o sinal de dois pontos, diga sim.
Se o pedaço for o ponto de exclamação, diga sim.
Se o pedaço for o ponto de interrogação, diga sim.
Diga não.

Etapas necessárias para que se determine se um pedaço é any stressed vowel:
Se o pedaço estiver em "áãâàéèêëíîìïóõôöúùüûý", diga sim. \ na verdade a rotina apenas identifica caracteres acentuados
Diga não.

Etapas necessárias para que se determine se um pedaço é any symbol:
Se o pedaço for o caret pedaço, diga sim.
Se o pedaço for o barra vertical, diga sim.
Se o pedaço for o asterisco, diga sim.
Se o pedaço for o sinal de adição, diga sim.
Se o pedaço for o hífem, diga sim.
Se o pedaço for o slash pedaço, diga sim.
Se o pedaço for o left-alligator pedaço, diga sim.
Se o pedaço for o right-alligator pedaço, diga sim.
Se o pedaço for o chave esquerda, diga sim.
Se o pedaço for o right-brace pedaço, diga sim.
Se o pedaço for o sinal de igualdade, diga sim.
Se o pedaço for 128, diga sim.
Se o pedaço for 130, diga sim.
Se o pedaço estiver entre 132 e 137, diga sim.
Se o pedaço for 139, diga sim.
Se o pedaço estiver entre 145 e 153, diga sim.
Se o pedaço for 155, diga sim.
Se o pedaço estiver entre 161 e 180, diga sim.
Se o pedaço estiver entre 183 e 191, diga sim.
Se o pedaço for 215, diga sim.
Se o pedaço for 247, diga sim.
Diga não.

Etapas necessárias para que se determine se um campo termo está vazia;
Etapas necessárias para que se determine se um campo termo estão vazias;
Etapas necessárias para que se determine se um campo termo estão vazios;
Etapas necessárias para que se determine se um campo termo está vazio:
Se o campo deste campo termo não for inexistente, diga não.
Se a function deste campo termo não for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se alguns campos deveriam ser finalizados;
Etapas necessárias para que se determine se alguns campos deveria ser [estar] finalizado:
Obtenha um campo from o campos.
Se o campo for inexistente, diga não.
Se o type deste campo deveria ser [estar] finalizado, diga sim.
Repita.

Etapas necessárias para que se determine se um item looks reamish:
Load o endereço completo deste item para um trecho.
Se o trecho starts com "ream cal", diga sim.
Diga não.

Etapas necessárias para que se determine se um cabeçalho expandido estiver em um catálogo:
Encontre um refer usando o cabeçalho expandido e o catálogo.
Se o refer for inexistente, diga não.
Se o endereço de memória deste refer for inexistente, diga não.
Diga sim.

Etapas necessárias para que se determine se um monikette é bubbled out:
Se o monikette for inexistente, diga sim.
Se o type atual deste monikette não for inexistente, diga não.
Se o subtexto atual deste monikette não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um nome é any magnitude:
\PAL
Se o nome for "magnitude", diga sim.
\CAL
Se o nome for "magnitud", diga sim.
Diga não.

Etapas necessárias para que se determine se um nome é any target:
\PAL
Se o nome for "conteúdo", diga sim.
Se o nome for "alvo", diga sim.
\CAL
Se o nome for "target", diga sim.
Se o nome for "objetivo", diga sim.
Diga não.

Etapas necessárias para que se determine se um nome é any whereabouts:
\PAL
Se o nome for "paradeiro", diga sim.
\CAL
Se o nome for "whereabouts", diga sim.
Diga não.

Etapas necessárias para que se determine se um nome é any valid campo nome:
Se o nome for any magnitude, diga não.
Se o nome for any target, diga não.
Se o nome for any whereabouts, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está followed por any unit of measure:
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o percorredor não for sobre any nome starter, diga não.
Examine um nome usando o percorredor.
Encontre um type usando o nome e o catálogo de tipos.
Se o type for inexistente, diga não.
Se o nome não for "times", diga sim. \ special because times é um infix operator e um unit of measure
\Se o nome não for "vezes", diga sim.
Se o token deste percorredor for o start of any expression, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any nested double-quote:
Se o source deste percorredor starts com """""", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any possessive:
Se o source deste percorredor estiver em branco, diga não.
Se o target deste first deste source deste percorredor não for o single-quote pedaço, diga não.
Se o percorredor estiver sobre any possessive (type 1 - single-quote, s, non-glom-byte), diga sim.
Se o percorredor estiver sobre any possessive (type 2 - preceding s, single-quote, non-glom-byte), diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any possessive (type 1 - single-quote, s, non-glom-byte):
Se o source deste percorredor does not start com "'s", diga não.
Isole o percorredor.
Adicione 2 para o first deste source deste percorredor.
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any possessive (type 2 - preceding s, single-quote, non-glom-byte):
Isole o percorredor.
Se o first deste source deste percorredor for o first deste subtexto original deste percorredor, diga não.
Subtraia 1 from o first deste source deste percorredor.
Se o target deste first deste source deste percorredor não for o little-s pedaço ou o S maiúsculo, diga não.
Adicione 2 para o first deste source deste percorredor.
Se o source deste percorredor estiver em branco, diga sim.
Se o target deste first deste source deste percorredor não for any glom pedaço, diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any simile:
\ added for invisible turtle project ***
Isole o percorredor.
Se o token deste percorredor for "LIKE", diga sim.
Se o token deste percorredor não for "AS", diga não.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor é o start of any function:
Se o detector de erros deste compilador estiver ativado, diga não.
Se o token deste percorredor for "Ponha", diga sim.
\Se o token deste percorredor não for any atribua, diga não.
Se o token deste percorredor não for "atribua", diga não.
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any article, diga não.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o token deste percorredor for any possessive, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any contraction usando uma segunda string (portuguese rules - "no"):
Se o string não for "no", diga não.
Se a segunda string for "say", diga não.
Se a segunda string for "diga", diga não.
\Se a segunda string for "dizer", diga não.
Diga sim.

Etapas necessárias para que se determine se um string termina com any consonant e uma segunda string:
Lance um subtexto sobre o string.
Subtraia o length deste segunda string from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any consonant, diga não.
Se o string does not end com a segunda string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string termina com any vowel e uma segunda string:
Lance um subtexto sobre o string.
Subtraia o length deste segunda string from o last deste subtexto.
Se o subtexto estiver em branco, diga não.
Se o target deste last deste subtexto não for any vowel, diga não.
Se o string does not end com a segunda string, diga não.
Diga sim.

Etapas necessárias para que se determine se um string termina com any consonant:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any consonant, diga não.
Diga sim.

Etapas necessárias para que se determine se um string termina com any vowel:
Se o string estiver em branco, diga não.
Se o target deste last deste string não for any vowel, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any plus:
\PAL
Se o string for "mais", diga sim.
\CAL
Se o string for "plus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any atribua:
\PAL
Se o string for "pôr", diga sim.
\# Não precisa porque está como sinônimo, ver a rotina abaixo: 
\"Etapas necessárias para que se posponha um string para uma segunda string usando um terceiro string (portuguese contractions e synonyms rules)"
\Se o string for "colocar", diga sim.
\CAL
Se o string for "atribua", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any minus:
\PAL
Se o string for "menos", diga sim.
\CAL
Se o string for "minus", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any times:
\PAL
Se o string for "vezes", diga sim.
\CAL
Se o string for "times", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any divided:
\PAL
Se o string for "dividido", diga sim.
\CAL
Se o string for "divided", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any by:
\PAL
Se o string for "via", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se o string for "por", diga sim.
\CAL
Se o string for "by", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any palavra de concatenação:
\PAL
Se o string for "com", diga sim. \ em tese não pode ser "por" pois o por vai ser no lugar do for
Se o string for "de", diga sim.
Se o string for "a", diga sim.
Se o string for "seguida", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operador de concatenação:
\PAL
\# operador de concatenação de strings tipo: "abc" junto com "def" = "abcdef"
\# em português poderia ser: "mais", "depois", "então" ou "em seguida".
Se o string for "junto", diga sim. \ junto do/da, junto com o ...
Se o string for "juntamente", diga sim. \ juntamente com o...
Se o string for "seguido", diga sim. \ seguido do ....
Se o string for "acompanhado", diga sim. \ acompanhado de... 

Se o string for "em", diga sim.
\Se o string for "&", diga sim.
\CAL
Se o string for "then", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any has:
\PAL
Se o string for "que tem", diga sim.
Se o string for "contendo", diga sim.
Se o string for "tem", diga sim.
Se o string for "que têm", diga sim.
Se o string for "que possui", diga sim.
Se o string for "que possuem", diga sim.
\CAL
Se o string for "has", diga sim.
Se o string for "have", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any is:
\PAL
Se o string for "é", diga sim.
Se o string for "está", diga sim.
Se o string for "são", diga sim.
Se o string for "estão", diga sim.
Se o string for "for", diga sim.
Se o string for "forem", diga sim.
Se o string for "estiverem", diga sim.
Se o string for "estarem", diga sim.
\CAL
Se o string for "is", diga sim.
Se o string for "are", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operador de atribuição:
\PAL
Se o string for "igual", diga sim.
\CAL
Se o string for "equal", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any com:
\PAL
Se o string for "com", diga sim.
Se o string for "contendo", diga sim.
\CAL
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any article:
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conjunction:
\PAL
\# verificar depois o uso dos termos: "ambos", "mas" e "nenhum"
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
Se o string for "nem", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "both", diga sim.
Se o string for "but", diga sim.
Se o string for "either", diga sim.
Se o string for "neither", diga sim.
Se o string for "nor", diga sim.
Se o string for "or", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any detector literal:
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any to:
\PAL
Se o string for "a", diga sim. \ this é questionable
\CAL
Se o string for "to", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any and:
\PAL
Se o string for "e", diga sim.
\CAL
Se o string for "and", diga sim.
Diga não. \repetido?

Etapas necessárias para que se determine se um string é any reverse-possessive function into:
\PAL
Se o string for "em", diga sim.
Se o string for "para", diga sim.
\CAL
Se o string for "into", diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any detector literal:
\Se o string for "si", diga sim.
\Se o string for "yes", diga sim.
\Se o string for "no", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
Se o string for "afirmativamente", diga sim.
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any positive decider literal:
\PAL
Se o string for "sim", diga sim.
Se o string for "positivo", diga sim.
Se o string for "positivamente", diga sim.
Se o string for "afirmativamente", diga sim.
\CAL
Se o string for "yes", diga sim.
\Se o string for "yep", diga sim.
\Se o string for "yea", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any negative decider literal:
\PAL
Se o string for "não", diga sim.
Se o string for "negativo", diga sim.
Se o string for "negativamente", diga sim.
\CAL
Se o string for "no", diga sim.
\Se o string for "nay", diga sim.
\Se o string for "nope", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any hex literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o cifrão, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo definido:
\PAL
Se o string for "o", diga sim.
Se o string for "a", diga sim.
Se o string for "os", diga sim.
Se o string for "as", diga sim.
Se o string for any pronome demonstrativo adjacente, diga sim.
\CAL
Se o string for "the", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo:
\CEL
Se o string for any pronome demonstrativo adjacente, diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo adjacente:
\CEL
Se o string for "este", diga sim.
Se o string for "esta", diga sim.
Se o string for "estes", diga sim.
Se o string for "estas", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any pronome demonstrativo abrangente:
\CEL
Se o string for "esse", diga sim.
Se o string for "essa", diga sim.
Se o string for "aquele", diga sim.
Se o string for "aquela", diga sim.
Se o string for "esses", diga sim.
Se o string for "essas", diga sim.
Se o string for "aqueles", diga sim.
Se o string for "aquelas", diga sim.
Se o string for "certo", diga sim.
Se o string for "certa", diga sim.
Se o string for "certos", diga sim.
Se o string for "certas", diga sim.
Se o string for "determinado", diga sim.
Se o string for "determinada", diga sim.
Se o string for "determinados", diga sim.
Se o string for "determinadas", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any artigo definido:
Se o percorredor estiver sobre any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo definido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any artigo indefinido:
Se o percorredor estiver sobre any preposição conectiva, diga não.
Se o token deste percorredor não for any artigo indefinido, diga não.
Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any preposição conectiva:
Se o token deste percorredor não for "a", diga não.
Isole o percorredor. Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any article, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido: \ esse aqui parece que não serve pra muita coisa
\PAL
Se o string for any artigo indefinido português, diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
\CAL
Se o string for any artigo indefinido inglês, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido inglês:
\CAL
Se o string for "an", diga sim.
Se o string for "another", diga sim.
Se o string for "some", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any artigo indefinido português: \ é aqui que se deve colocar o possessivo. descobri.
\PAL
Se o string for "um", diga sim.
Se o string for "uma", diga sim.
Se o string for "uns", diga sim.
Se o string for "umas", diga sim.
\Se o string for "outro", diga sim.
\Se o string for "outra", diga sim.
Se o string for "algum", diga sim.
Se o string for "alguma", diga sim.
Se o string for "alguns", diga sim.
Se o string for "algumas", diga sim.
Se o string for any pronome demonstrativo abrangente, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any literal:
Se o string for any endereço de memória literal, diga sim.
Se o string for any numeric literal, diga sim.
Se o string for any string literal, diga sim.
\Se o string for any detector literal, diga sim. ***
Se o string for any hex literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any mark:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any mark, diga sim.
Diga não.

\Etapas necessárias para que se determine se um string é any monikette string:
\Se o string estiver em branco, diga não.
\Se o string for "the", diga não.
\Se o string é any artigo indefinido, diga não.
\Se o string é any possessive, diga não.
\Se o string é any literal, diga não.
\Se o string é any mark, diga não.
\Se o string é any symbol, diga não.
\Diga sim.

Etapas necessárias para que se determine se um percorredor está sobre any monikette string:
Se o token deste percorredor estiver em branco, diga não.
Se o percorredor estiver sobre any artigo definido, diga não.
Se o percorredor estiver sobre any artigo indefinido, diga não.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any called:
\PAL
Se o string for "chamado", diga sim.
Se o string for "chamada", diga sim.
\CAL
Se o string for "called", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any nome ender:
\ compare com nome starter
Se o string for any mark, diga sim.
Se o string for any symbol, diga sim.
Se o string for any article, diga sim.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga sim.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga sim.
Se o string for any literal, diga sim.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga sim.
Diga não.
Etapas necessárias para que se determine se um string é any reference:
\PAL
Se o string for "(referência)", diga sim.
\CAL
Se o string for "(reference)", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any nome ender:
\ compare com nome starter
Se o token deste percorredor for any mark, diga sim.
Se o token deste percorredor for any symbol, diga sim.
Se o token deste percorredor for any article, diga sim.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga sim.
Se o percorredor estiver sobre any reverse-possessive, diga sim.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver sobre any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga sim.
Se o token deste percorredor for any literal, diga sim.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga sim.
\ Portuguese trouble makers
Se o token deste percorredor for any negative palavra, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any nome starter:
\ compare com nome ender
Se o string for any mark, diga não.
Se o string for any symbol, diga não.
Se o string for any article, diga não.
Se o string for any conjunction, diga sim.
Se o string for any possessive, diga não.
Se o string for any verb, diga sim.
Se o string for any operator, diga sim.
Se o string for any preposition, diga sim.
Se o string for any qualifier, diga não.
Se o string for any literal, diga não.
Se o string for "called", diga sim.
Se o string for "equal", diga sim.
Se o string estiver em branco, diga não.
Diga sim.
Etapas necessárias para que se determine se um percorredor está sobre any nome starter:
\ compare com nome ender
Se o token deste percorredor for any mark, diga não.
Se o token deste percorredor for any symbol, diga não.
Se o token deste percorredor for any article, diga não.
Se o token deste percorredor for any conjunction, diga sim.
Se o token deste percorredor for any possessive, diga não.
Se o token deste percorredor for any verb, diga sim.
Se o token deste percorredor for any operator, diga sim.
Se o percorredor estiver sobre any preposition, diga sim.
Se o token deste percorredor for any qualifier, diga não.
Se o token deste percorredor for any literal, diga não.
Se o token deste percorredor for any called, diga sim.
Se o token deste percorredor for any operador de atribuição, diga sim.
Se o token deste percorredor estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é any negative palavra:
\SAL
Se o string for "não", diga sim.
\Se o string for "nada", diga sim.
\Se o string for "ainda", diga sim.
\CAL
\Se o string for "no", diga sim.
Se o string for "not", diga sim.
Se o string for "cannot", diga sim.
Se o string for "nothing", diga sim.
Se o string termina com "n't", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any operator:
\PAL
Se o string for "mais", diga sim.
Se o string for "menos", diga sim.
Se o string for "vezes", diga sim.
Se o string for "dividido", diga sim.
Se o string for "depois", diga sim.
Se o string for "seguido", diga sim.
Se o string for "juntamente", diga sim.
Se o string for "junto", diga sim.
Se o string for "acompanhado", diga sim.
\CAL
Se o string for "plus", diga sim.
Se o string for "minus", diga sim.
Se o string for "times", diga sim.
Se o string for "divided", diga sim.
Se o string for "then", diga sim.

Diga não.

\Etapas necessárias para que se determine se um string é any artigo indefinido inglês:
\Se o string for "a", diga sim.
\Se o string for "an", diga sim.
\Se o string for "another", diga sim.
\Se o string for "some", diga sim.
\Diga não.

Etapas necessárias para que se determine se um string é any pause:
\PAL
Se o string for "e", diga sim.
Se o string for "ou", diga sim.
\CAL
Se o string for "and", diga sim.
Se o string for "or", diga sim.
\default
Se o string for ",", diga sim.
Se o string for ";", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any endereço de memória literal:
\PAL
Se o string for "nulo", diga sim.
Se o string for "nula", diga sim.
Se o string for "inexistente", diga sim.
\CAL
Se o string for "nil", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any possessive:
Se o string for "'s", diga sim.
Se o string for "'", diga sim.
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any preposition:
Atribua o token deste percorredor para um subtexto.
\PAL
Se o percorredor estiver sobre any preposição conectiva, diga sim. \ "a" followed por um article for "to" em portuguese
Se o subtexto for "abaixo", diga sim. \ down
Se o subtexto for "acima", diga sim. \ up
Se o subtexto for "ante", diga sim. \ antes de
Se o subtexto for "antes", diga sim. \ antes de
Se o subtexto for "perante", diga sim. \ antes de
Se o subtexto for "debaixo", diga sim. \ below
Se o subtexto for "sob", diga sim. \ below
Se o subtexto for "acerca", diga sim. \ near
Se o subtexto for "próximo", diga sim. \ near
Se o subtexto for "perto", diga sim. \ near
Se o subtexto for "com", diga sim. \ with
\Se o subtexto for "contendo", diga sim. \ with
Se o subtexto for "como", diga sim. \ as
Se o subtexto for "contra", diga sim. \ against
\ Se o subtexto for "de", diga sim. \ reverse-possessive indicator 
Se o subtexto for "dada", diga sim. \ given
Se o subtexto for "dado", diga sim. \ given
Se o subtexto for "dando", diga sim. \ given
Se o subtexto for "gerando", diga sim. \ usando
Se o subtexto for "resultando", diga sim. \ usando
Se o subtexto for "retornando", diga sim. \ usando
\Se o subtexto for "direita", diga sim. \ right
Se o subtexto for "desde", diga sim. \ since
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "durante", diga sim. \ during
Se o subtexto for "em", diga sim. \ in
Se o subtexto for "entre", diga sim. \ between
Se o subtexto for "até", diga sim. \ until
\Se o subtexto for "esquerda", diga sim. \ left
Se o subtexto for "mediante", diga sim. \ through
Se o subtexto for "para", diga sim. \ to
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "segundo", diga sim. \ according
Se o subtexto for "sem", diga sim. \ comout
Se o subtexto for "então", diga sim.
Se o subtexto for "sobre", diga sim. \ on
Se o subtexto for "após", diga sim. \ after
Se o subtexto for "depois", diga sim. \ after
Se o subtexto for "usando", diga sim. \ using
\Se o subtexto for "contendo", diga sim. \ using 
Se o subtexto for "versus", diga sim. \ versus
Se o subtexto for "via", diga sim. \ by
Se o subtexto for "enquanto", diga sim. \ while
Se o subtexto for "redefinindo", diga sim. \# 'at' na redefinição de campos 
\CAL
Se o subtexto for "about", diga sim.
Se o subtexto for "above", diga sim.
Se o subtexto for "across", diga sim.
Se o subtexto for "after", diga sim.
Se o subtexto for "against", diga sim.
Se o subtexto for "all", diga sim.
Se o subtexto for "alone", diga sim.
Se o subtexto for "along", diga sim.
Se o subtexto for "among", diga sim.
Se o subtexto for "any", diga sim.
Se o subtexto for "anywhere", diga sim.
Se o subtexto for "around", diga sim.
\Se o subtexto for "as", diga sim.
Se o subtexto for "at", diga sim.
Se o subtexto for "away", diga sim.
Se o subtexto for "back", diga sim.
Se o subtexto for "backward", diga sim.
Se o subtexto for "backwards", diga sim.
Se o subtexto for "antes de", diga sim.
Se o subtexto for "beginning", diga sim.
Se o subtexto for "behind", diga sim.
Se o subtexto for "below", diga sim.
Se o subtexto for "beneath", diga sim.
Se o subtexto for "beside", diga sim.
Se o subtexto for "between", diga sim.
Se o subtexto for "beyond", diga sim.
Se o subtexto for "bigger", diga sim.
Se o subtexto for "by", diga sim.
Se o subtexto for "close", diga sim.
Se o subtexto for "deep", diga sim.
Se o subtexto for "diagonally", diga sim.
Se o subtexto for "down", diga sim.
Se o subtexto for "downward", diga sim.
Se o subtexto for "ending", diga sim.
Se o subtexto for "everywhere", diga sim.
Se o subtexto for "except", diga sim.
Se o subtexto for "finishing", diga sim.
Se o subtexto for "facing", diga sim.
\Se o subtexto for "for", diga sim.
Se o subtexto for "por", diga sim.
Se o subtexto for "forward", diga sim.
Se o subtexto for "from", diga sim.
Se o subtexto for "given", diga sim.
Se o subtexto for "usando", diga sim.
Se o subtexto for "high", diga sim.
Se o subtexto for "in", diga sim.
Se o subtexto for "inside", diga sim.
Se o subtexto for "into", diga sim.
Se o subtexto for "en", diga sim.
Se o subtexto for "larger", diga sim.
Se o subtexto for "leaning", diga sim.
Se o subtexto for "left", diga sim.
Se o subtexto for "leftward", diga sim.
Se o subtexto for "leftways", diga sim.
Se o subtexto for "like", diga sim.
Se o subtexto for "limiting", diga sim.
Se o subtexto for "long", diga sim.
Se o subtexto for "near", diga sim.
Se o subtexto for "of", diga sim.
Se o subtexto for "off", diga sim.
Se o subtexto for "on", diga sim.
Se o subtexto for "only", diga sim.
Se o subtexto for "onto", diga sim.
Se o subtexto for "out", diga sim.
Se o subtexto for "outside", diga sim.
Se o subtexto for "over", diga sim.
Se o subtexto for "past", diga sim.
Se o subtexto for "pointing", diga sim.
Se o subtexto for "devolvendo", diga sim.
Se o subtexto for "right", diga sim.
Se o subtexto for "rightward", diga sim.
Se o subtexto for "rightways", diga sim.
Se o subtexto for "shorter", diga sim.
Se o subtexto for "sideway", diga sim.
Se o subtexto for "sideways", diga sim.
Se o subtexto for "similar", diga sim.
Se o subtexto for "smaller", diga sim.
Se o subtexto for "somewhere", diga sim.
Se o subtexto for "slantwise", diga sim.
Se o subtexto for "slantway", diga sim.
Se o subtexto for "slantways", diga sim.
Se o subtexto for "starting", diga sim.
Se o subtexto for "tall", diga sim.
Se o subtexto for "taller", diga sim.
Se o subtexto for "thru", diga sim.
Se o subtexto for "through", diga sim.
Se o subtexto for "throughout", diga sim.
Se o subtexto for "to", diga sim.
Se o subtexto for "toward", diga sim.
Se o subtexto for "towards", diga sim.
Se o subtexto for "under", diga sim.
Se o subtexto for "underneath", diga sim.
Se o subtexto for "until", diga sim.
Se o subtexto for "unto", diga sim.
Se o subtexto for "up", diga sim.
Se o subtexto for "upward", diga sim.
Se o subtexto for "upon", diga sim.
Se o subtexto for "using", diga sim.
Se o subtexto for "via", diga sim.
Se o subtexto for "while", diga sim.
Se o subtexto for "wide", diga sim.
Se o subtexto for "with", diga sim.
Se o subtexto for "within", diga sim.
Se o subtexto for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any preposition:
Se o string for "about", diga sim.
Se o string for "above", diga sim.
Se o string for "across", diga sim.
Se o string for "after", diga sim.
Se o string for "against", diga sim.
Se o string for "all", diga sim.
Se o string for "alone", diga sim.
Se o string for "along", diga sim.
Se o string for "among", diga sim.
Se o string for "any", diga sim.
Se o string for "anywhere", diga sim.
Se o string for "around", diga sim.
\Se o string for "as", diga sim.
Se o string for "at", diga sim.
Se o string for "away", diga sim.
Se o string for "back", diga sim.
Se o string for "backward", diga sim.
Se o string for "backwards", diga sim.
Se o string for "antes de", diga sim.
Se o string for "beginning", diga sim.
Se o string for "behind", diga sim.
Se o string for "below", diga sim.
Se o string for "beneath", diga sim.
Se o string for "beside", diga sim.
Se o string for "between", diga sim.
Se o string for "beyond", diga sim.
Se o string for "bigger", diga sim.
Se o string for "by", diga sim.
Se o string for "close", diga sim.
Se o string for "deep", diga sim.
Se o string for "diagonally", diga sim.
Se o string for "down", diga sim.
Se o string for "downward", diga sim.
Se o string for "ending", diga sim.
Se o string for "everywhere", diga sim.
Se o string for "except", diga sim.
Se o string for "finishing", diga sim.
Se o string for "facing", diga sim.
\Se o string for "for", diga sim.
Se o string for "por", diga sim.
Se o string for "forward", diga sim.
Se o string for "from", diga sim.
Se o string for "given", diga sim.
Se o string for "usando", diga sim.
Se o string for "high", diga sim.
Se o string for "in", diga sim.
Se o string for "inside", diga sim.
Se o string for "into", diga sim.
Se o string for "larger", diga sim.
Se o string for "leaning", diga sim.
Se o string for "left", diga sim.
Se o string for "leftward", diga sim.
Se o string for "leftways", diga sim.
Se o string for "like", diga sim.
Se o string for "limiting", diga sim.
Se o string for "long", diga sim.
Se o string for "near", diga sim.
Se o string for "of", diga sim.
Se o string for "off", diga sim.
Se o string for "on", diga sim.
Se o string for "only", diga sim.
Se o string for "onto", diga sim.
Se o string for "out", diga sim.
Se o string for "outside", diga sim.
Se o string for "over", diga sim.
Se o string for "past", diga sim.
Se o string for "pointing", diga sim.
Se o string for "devolvendo", diga sim.
Se o string for "right", diga sim.
Se o string for "rightward", diga sim.
Se o string for "rightways", diga sim.
Se o string for "shorter", diga sim.
Se o string for "sideway", diga sim.
Se o string for "sideways", diga sim.
Se o string for "similar", diga sim.
Se o string for "smaller", diga sim.
Se o string for "somewhere", diga sim.
Se o string for "slantwise", diga sim.
Se o string for "slantway", diga sim.
Se o string for "slantways", diga sim.
Se o string for "starting", diga sim.
Se o string for "tall", diga sim.
Se o string for "taller", diga sim.
Se o string for "thru", diga sim.
Se o string for "through", diga sim.
Se o string for "throughout", diga sim.
Se o string for "to", diga sim.
Se o string for "toward", diga sim.
Se o string for "towards", diga sim.
Se o string for "under", diga sim.
Se o string for "underneath", diga sim.
Se o string for "until", diga sim.
Se o string for "unto", diga sim.
Se o string for "up", diga sim.
Se o string for "upward", diga sim.
Se o string for "upon", diga sim.
Se o string for "using", diga sim.
Se o string for "via", diga sim.
Se o string for "while", diga sim.
Se o string for "wide", diga sim.
Se o string for "with", diga sim.
Se o string for "within", diga sim.
Se o string for "without", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any qualifier:
Se o string estiver em branco, diga não.
Se o target deste first deste string for o parênteses esquerdo, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any reverse-possessive:
\Se o string for "uv", diga sim.
Se o string for "de", diga sim.
\Se o string for "pertencente", diga sim.
\Se o string for "que pertence", diga sim.
\Se o string for "del", diga sim. \ short por "de el", expanded em "compile um termo usando um percorredor e um campo nome (possessivo reverso)"
Diga não.

Etapas necessárias para que se determine se um percorredor está sobre any reverse-possessive:
Isole o percorredor.
\CAL
\Se o token deste percorredor for "uv", diga sim.
\PAL
\Se o string for "pertencente a", diga sim.
\Se o string for "pertencente ao", diga sim.
\Se o string for "que pertence a", diga sim.
\Se o string for "que pertence ao", diga sim.
\que consta
\que figura
\incorporada
\inerente
\Se o token deste percorredor não for "integrada de", diga não.
\Se o token deste percorredor não for "interna de", diga não.
\Se o token deste percorredor não for "interno de", diga não.
\Se o token deste percorredor não for "do registro de", diga não.
\Se o token deste percorredor não for "que está dentro de", diga não.
\Se o token deste percorredor não for "de dentro do registro de", diga não.
\Se o token deste percorredor não for "de dentro de", diga não.
\Se o token deste percorredor não for "que faz parte de", diga não.
Se o token deste percorredor não for "de", diga não.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any pronome demonstrativo, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any string literal:
Se o string estiver em branco, diga não.
Se o target deste first deste string for as aspas duplas, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any symbol:
Se o length deste string não for 1, diga não.
Se o target deste first deste string for any symbol, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any verb:
\PAL
Se o string for "deve", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveria", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "deveriam", diga sim. \ it "should" não deveria \ shouldn't: (3ps)
Se o string for "devem", diga sim. \ they "should" não deveria \ shouldn't: (3pp)
Se o string for "estar", diga sim. \ "be": note that Portuguese have both verbs por "to be": infinitive "estar" por temporal state e "ser" para non-tempora state
Se o string for "ser", diga sim. \ "be"
Se o string for "for", diga sim. \ "be"
Se o string for "forem", diga sim. \ "be"
Se o string for "estiver", diga sim. \ "be"
Se o string for "estiverem", diga sim. \ "be"
Se o string for "é", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, perm.
Se o string for "está", diga sim. \ "is" não for \ isn't: "to be" conjugated no singular terceiro person (3ps) present, temp.
Se o string for "são", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, perm.
Se o string for "estão", diga sim. \ "are" são not \ aren't: "to be" conjugated no plural terceiro person (3pp) present, temp.
Se o string for "foi", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, perm.
Se o string for "estava", diga sim. \ "was" was not \ wasn't: only used em Noodle (3ps) past, temp.
Se o string for "foram", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, perm.
Se o string for "estavam", diga sim. \ "were" were not \ weren't?: not used em CAL (3pp) past, temp.
Se o string for "será", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, perm.
Se o string for "estará", diga sim. \ it "will" will not \ won't: not used em CAL (3ps) past, temp.
Se o string for "serão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, perm.
Se o string for "estarão", diga sim. \ they "will" will not \ won't: not used em CAL (3pp) past, temp.
Se o string for "supera", diga sim. \ beats, exceeds
Se o string for "superam", diga sim. \ beats, exceeds
Se o string for "excede", diga sim. \ beats, exceeds
Se o string for "excedem", diga sim. \ beats, exceeds
Se o string for "pode", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se o string for "puder", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se o string for "puderem", diga sim. \ it "can" cannot \ can't: only case em CAL (3ps)
Se o string for "podem", diga sim. \ they "can" cannot \ can't: not used em CAL (3pp) added just em case 
Se o string for "poderia", diga sim. \ it "could" could not \ couldn't: not used em CAL (3ps) added just em case
Se o string for "poderia", diga sim. \ they "could" could not \ couldn't: not used em CAL (3pp) added just em case
Se o string for "podemos", diga sim. \ we "could" could not \ couldn't: only once em Noodle (1pp) "Etapas necessárias para que se determine se we could encontre um endereço de memória:"
Se o string for "tem", diga sim. \ it "has" used em type definitions; (3ps) present
Se o string for "têm", diga sim. \ they "have" used em type definitions; (3pp) present
Se o string for "ter", diga sim. \ used em type definitions
Se o string for "possui", diga sim. \ it "has" used em type definitions; (3ps) present
Se o string for "possuem", diga sim. \ they "have" used em type definitions; (3pp) present
Se o string for "possuir", diga sim. \ used em type definitions
\\ trouble makers
Se o string for "inicia", diga sim. \ "begins" does not begin \ doesn't begin
Se o string for "começa", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "começar", diga sim. \ "starts" does not start \ doesn't start: I hear um yes
Se o string for "termina", diga sim. \ "ends" does not end \ doesn't end
Se o string for "terminar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finaliza", diga sim. \ "ends" does not end \ doesn't end
Se o string for "finalizar", diga sim. \ "ends" does not end \ doesn't end
Se o string for "parece", diga sim. \ "looks" does not look \ doesn't look
Se o string for "necessita", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
Se o string for "necessitar", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
Se o string for "requer", diga sim. \ "needs" does not need \ doesn't need: not used em CAL
\CAL
Se o string for "are", diga sim. \ são not \ aren't
Se o string for "be", diga sim. \
Se o string for "can", diga sim. \ cannot \ can't
Se o string for "cannot", diga sim.
\Se o string for "could", diga sim. \ could not \ couldn't
\Se o string for "do", diga sim. \ does not \ don't
Se o string for "does", diga sim. \ does not \ doesn't
Se o string for "is", diga sim. \ não for \ isn't
Se o string for "may", diga sim. \ may not \ mayn't
Se o string for "should", diga sim. \ não deveria \ shouldn't
Se o string for "was", diga sim. \ was not \ wasn't
Se o string for "will", diga sim. \ will not \ won't
Se o string for "would", diga sim. \ would not \ wouldn't
Se o string for "has", diga sim. \ used em type definitions
Se o string for "have", diga sim. \ used em type definitions
Se o string termina com "n't", diga sim.
\\ trouble makers
Se o string for "begins", diga sim. \ does not begin \ doesn't begin
Se o string for "ends", diga sim. \ does not end \ doesn't end
Se o string for "looks", diga sim. \ does not look \ doesn't look
Se o string for "needs", diga sim. \ does not need \ doesn't need
Se o string for "starts", diga sim. \ does not start \ doesn't start
Diga não.

Etapas necessárias para que se determine se um string é o start of any definition:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
\CAL
Se o string for "to", diga sim.
\default
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any conditional:
\PAL
Se o string for "se", diga sim.
Se o string for "quando", diga sim.
\CAL
Se o string for "if", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any privatize:
\PAL
Se o string for "privatize", diga sim.
\Se o string for "reserve", diga sim.
Se o string for "separe", diga sim.
Se o string for "isole", diga sim.
Se o string for "Isole", diga sim.
Se o string for "conserve", diga sim.
Se o string for "derive", diga sim.
\CAL
\Se o string for "privatize", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any loop:
\PAL
Se o string for "percorra", diga sim.
\Se o string for "ciclo", diga sim.
\Se o string for "laço", diga sim. \# muito usado em pseudo-codigo
\CAL
Se o string for "loop", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any break:
\PAL
Se o string for "pare", diga sim.
Se o string for "pare de percorrer", diga sim.
Se o string for "saia", diga sim.
Se o string for "saia do laço", diga sim.
\CAL
Se o string for "break", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any exit:
\PAL
Se o string for "cancele a operação", diga sim.
Se o string for "interrompa a operação", diga sim.
\Se o string for "advirta", diga sim.
\Se o string for "anuncie", diga sim.
\Se o string for "avise", diga sim.
Se o string for "cancele", diga sim.
Se o string for "desconsidere.", diga sim.
Se o string for "deixa quieto", diga sim.
Se o string for "deixe quieto", diga sim.
Se o string for "e mais nada", diga sim.
Se o string for "e pronto", diga sim.
Se o string for "e só", diga sim.
Se o string for "fim", diga sim.
Se o string for "fimse", diga sim.
Se o string for "ignore", diga sim.
\Se o string for "informe", diga sim.
Se o string for "prossiga", diga sim.
Se o string for "pronto", diga sim.
Se o string for "retorne", diga sim.
Se o string for "siga adiante", diga sim.
Se o string for "terminamos", diga sim.
Se o string for "termine", diga sim.
\CAL
Se o string for "exit", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any repeat:
\PAL
Se o string for "repita", diga sim. 
\CAL
Se o string for "repeat", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any say:
\PAL
Se o string for "diga", diga sim. \# modo imperativo
Se o string for "responda", diga sim. \# modo imperativo
Se o string for "informe", diga sim. \# modo imperativo
\Se o string for "decida", diga sim. \ para usar como "decida afirmativamente e decida negativamente"
\Se o string for "dizer", diga sim. \# modo infinitivo opcional.
\CAL
Se o string for "say", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any decide:
\PAL
\Se o string for "decidir", diga sim.
Se o string for "decida", diga sim. \estou pensando em retirar devido o comentário da rotina anterior
\Se o string for "escolha", diga sim.
Se o string for "determine", diga sim.
Se o string for "conclua", diga sim.
Se o string for "esclareça", diga sim.
Se o string for "descubra", diga sim.
Se o string for "analise", diga sim.
\CAL
Se o string for "decide", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any call:
\PAL
Se o string for "chame", diga sim.
\Se o string for "repasse", diga sim.
\Se o string for "informe", diga sim.
\CAL
Se o string for "call", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any point:
\PAL
Se o string for "aponte", diga sim.
\CAL
Se o string for "point", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any employ:
\PAL
Se o string for "empregue", diga sim.
\CAL
Se o string for "employ", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é any noise palavra:
\Nova rotina 
Se o string for "already", diga sim.
Se o string for "still", diga sim.
Se o string for "yet", diga sim.
Se o string for "já", diga sim.
Se o string for "ainda", diga sim.
\Se o string for "que", diga sim.
\Se o string for "se", diga sim.
[more noise palavras here]
Diga não.

Etapas necessárias para que se determine se um string é o start of any expression:
Se o string for any sign, diga sim.
Se o string for any artigo indefinido, diga sim.
Se o string for any artigo definido, diga sim.
Se o string for any literal, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any global:
Se o string for any artigo definido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any new local:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any optional info:
\PAL
Se o string for "com", diga sim.
Se o string for "contendo", diga sim.
\CAL
Se o string for "to", diga sim.
Se o string for "with", diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any routine:
\PAL
Se o string for "Passos", diga sim.
Se o string for "Etapas", diga sim.
Se o string for "Etapas necessárias para que se", diga sim. \verificar depois
Se o string for "Passos necessários para que se", diga sim.
\CAL
Se o string for "to", diga sim. \verificar se pode ser excluído
Diga não.

Etapas necessárias para que se determine se um string é o start of any statement:
Se o string for o start of any definition, diga não.
Se o string for any literal, diga não.
Se o string for any mark, diga não.
Se o string estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um string é o start of any type:
Se o string for any artigo indefinido, diga sim.
Diga não.

Etapas necessárias para que se determine se um string é o start of any variável:
Se o string for any artigo definido, diga sim.
\Se o string for "do", diga sim. \ this é iffy, here por reverse-possessives
Diga não.

Etapas necessárias para que se determine se um string has any stressed vowel:
Isole o string.
Percorra.
Se o string estiver em branco, diga não.
Se o target deste last deste string for any stressed vowel, diga sim.
Subtraia 1 from o last deste string.
Repita.

Etapas necessárias para que se determine se um termo está vazia;
Etapas necessárias para que se determine se um termo estão vazias;
Etapas necessárias para que se determine se um termo estão vazios;
Etapas necessárias para que se determine se um termo está vazio:
Se a variável deste termo não for inexistente, diga não.
Se a phrase deste termo não estiver em branco, diga não.
Diga sim.

Etapas necessárias para que se determine se um type pode ser reduzido para um string using o base nome:
Se o type for inexistente, diga não.
Se o nome deste type for o string, diga sim.
Se o cooking detector deste type estiver ativo, diga não.
Ligue o cooking detector deste type.
Encontre um base type usando o base nome deste type e o catálogo de tipos.
Se o base type for inexistente, desative o cooking detector deste type; diga não.
Se o base type puder ser reduzido para o string using o base nome, desative o cooking detector deste type; diga sim.
Desative o cooking detector deste type.
Diga não.

Etapas necessárias para que se determine se um type pode ser reduzido para um type nome:
Se o type for inexistente, diga não.
Isole o type.
Percorra.
Se o type for inexistente, diga não.
Se o nome deste type for o type nome, diga sim.
Se o base type deste type for o type, diga não.
Atribua o base type deste type ao type.
Repita.

Etapas necessárias para que se determine se um type é any built-in type:
Se o type for inexistente, diga não.
Se o type for o base type deste type, diga sim.
Diga não.

Etapas necessárias para que se determine se um type é value pushable:
Se o type for inexistente, diga não.
Se o type for inexistente, diga não. \\ repetido?
Se o length deste type for 4, diga sim.
Se o length deste type for 2, diga sim.
Se o length deste type for 1, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser [estar] finalizado:
Se o type for inexistente, diga não.
Se o type puder ser reduzido para "subtexto", diga não.
Se o type puder ser reduzido para "string", diga sim.
Se os campos deste type deveriam ser finalizados, diga sim.
Diga não.

Etapas necessárias para que se determine se um type deveria ser ignorado:
Se o type for inexistente, diga não.
\PAL
\Se o nome deste type for "elemento", diga não.
\Se o nome deste type for "elementos", diga não.
\CAL
Se o nome deste type for "coisa", diga não.
Se o nome deste type for "coisas", diga não.
Se o type puder ser reduzido para "coisas", diga sim.
Se o type não puder ser reduzido para "endereço de memória", diga não.
Se o target type deste type for inexistente, diga não.
Se o target type deste type não puder ser reduzido para "endereço de memória", diga sim.
Se o target type deste type não deveria ser ignorado, diga não.
Diga sim.

Etapas necessárias para que se determine se uma variável está duplicada em algumas variáveis:
Obtenha uma segunda variável from o variáveis.
Se a segunda variável for inexistente, diga não.
Se o nome desta segunda variável estiver em branco, repita.
Se a segunda variável for a variável, repita.
Se o nome desta segunda variável for o nome desta variável, diga sim.
Repita.

O dereference tag é uma tag igual a 5.

Um DOS header é um conjunto com
Um wyrd called signature, \\ O value of this word is 5A4DH (with the 4DH coming first).
\\ Signature Word. This contains a "magic number" which provides a simple check that the file really is a DOS .EXE file;
\\ it follows that the filename extension does not em fact have para be .EXE, as long as programs check this word.
\\O value of this word is 5A4DH (with the 4DH coming first).
\\These two bytes represent the character string "MZ", the initials of Mark Zibowski, a Microsoft employee at the time the file format was designed.
Um wyrd called numberofbytesonlastpage, \\ O last page may contain between 1 and 512 bytes
\\Last Page Size.
\\O file occupies a number of 512 byte pages.
\\O last page may contain between 1 and 512 bytes.
\\This word indicates the number of bytes actually used em the last page, 
\\with the special case of a full page being represented by a value of zero (since the last page is never empty).
Um wyrd called numberofpages,
\\ File Pages.
\\This word contains a count of the number of pages required para hold the file.
\\For example, if the file contains 1024 bytes, this word would contain 0002H; 
\\if the file contains 1025 bytes, this word would contain 0003H.
\\O Last Page Size campo is used para determine the number of valid bytes em the final page.
\\Thus, if the file contains 1024 bytes, the Last Page Size campo contains 0000H, because no bytes overflow à final partly used page.
\\If the file contains 1025 bytes, seguido de the Last Page Size campo contains 0001H, because the final page contains only one valid byte (the 1025th byte).
Um wyrd called relocal de apariçãos,
\\ Relocation Items.
\\ This word gives the number of entries that exist em the relocation pointer table.
\\It is quite em order for this value para be zero, em which case there are no relocation entries.
Um wyrd called sizeofheaderinparágrafos,
\\ Header Paragraphs.
\\This word gives the size of the .EXE header em parágrafos.
\\It indicates the offset of the compiled/assembled and linked image do program (the load module) within the .EXE file.
\\O size of the load module can be deduced by subtracting this value (converted para bytes) from the overall file size 
\\derived from combining the File Pages and Last Page Size values.
\\O header always spans an even number of parágrafos.
Um wyrd called minimumextraparágrafos,
\\ MINALLOC.
\\This word indicates the minimum number of parágrafos the program requires para begin execution.
\\This is em addition para the memory required para hold the load module.
\\This value normally represents the total size of any uninitialised data and/or stack segments that are linked at the end of a program.
\\This space is not directly included em the load module, since there are no particular initialising values and it would simply waste disk space.
Um wyrd called maximumextraparágrafos,
\\ MAXALLOC.
\\This word indicates the maximum number of parágrafos that the program would like allocated para it before it begins execution.
\\This indicates additional memory over and above that required by the load module and the value specified by MINALLOC.
\\If the request cannot be satisfied, the program is allocated as much memory as is available.
Um wyrd called initialrelativess,
\\ Initial SS value.
\\This word contains the parágrafo address of the stack segment relative para the start of the load module.
\\At load time, this value is relocated by adding the address of the start segment of the program para it, 
\\and the resulting value is placed em the SS register before the program is started.
\\In DOS, the start segment of the program is the first segment boundary em memory after the PSP.
Um wyrd called initialsp,
\\ Initial SP value.
\\This word contains the absolute value that must be loaded para the SP register before the program is given control.
\\Since the actual stack segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
Um wyrd called initialchecksum,
\\ Complemented Checksum.
\\This word contains a checksum of the contents of the .EXE file.
\\ Its value is rarely checked, but its purpose is para ensure the integrity of the data within the file.
\\ Full details of how it is calculated appear em the section sobre checksum calculation.
Um wyrd called initialip,
\\ Initial IP value.
\\This word contains the absolute value that should be loaded para the IP register em order para transfer control para the program.
\\Since the actual code segment is determined by the loader, and this is merely a value within that segment, it does not need para be relocated.
Um wyrd called initialirelativecs, 
\\ Pre-relocated initial CS value.
\\ This word contains the initial value, relative para the start of the load module, that should be placed em the CS register em order para transfer control para the program.
\\ At load time, this value is relocated by adding the address of the start segment of the program para it, and the resulting value is placed em the CS register
\\ when control is transferred.
Um wyrd called addressofrelocationtableinfile,
\\ Relocation table offset.
\\ This word gives the offset from the start of the file para the relocation pointer table.
\\ This value must be used para locate the relocation pointer table (rather than assuming a fixed location) 
\\because variável-length information pertaining para program overlays can occur before this table, causing its position para vary.
\\A value of 40H em this campo generally indicates a different kind of executable file, not a DOS "MZ" type.
Um wyrd called overlynumber,
\\ Overlay number.
\\ This word is normally set para 0000H, because few programs actually have overlays.
\\It changes only em files containing programs that use overlays; see the note below.
8 pedaços called resveredbytes, \\ Specifies reserved words for the program (known em winnt.h as e_res[4]), usually set para zero by the linker.
\\In this case, just use a single reserved1 set para zero; if not zero create four reserved1 com the correct value.
Um wyrd called oemidentifier, \\ Specifies the identifier for the OEM for e_oeminfo.
Um wyrd called oeminfo, \\ Specifies the OEM information for a specific value of e_oeminfo.
20 pedaços called reservedwords, \\ Specifies reserved words for the program (known em winnt.h as e_res[10]), usually set para zero by the linker.
\\In this case, just use a single reserved1 set para zero; if not zero create ten reserved1 com the correct value.
Um número called addressofpeheaderinfile.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variáveis:
Crie um catálogo usando 101.
Eliminate duplicate nicknames from o variáveis usando o catálogo.
Destrua o catálogo.

Etapas necessárias para que se eliminate duplicate nicknames from alguns variáveis usando um catálogo:
Se o catálogo for inexistente, cancele.
Percorra.
Obtenha uma variável from o variáveis.
Se o variável for inexistente, cancele.
Eliminate duplicate nicknames usando o variável e o catálogo.
Repita.

Etapas necessárias para que se eliminate duplicate nicknames usando uma variável e um catálogo:
Se o variável for inexistente, cancele.
Se o catálogo for inexistente, cancele.
Encontre uma segunda variável usando o nickname desta variável e o catálogo.
Se a segunda variável for inexistente, encontre a segunda variável usando o nome desta variável e o catálogo.
Se a segunda variável for inexistente, catalogue o variável usando o nickname desta variável e o catálogo; exit.
Limpe o nickname desta segunda variável.
Limpe o nickname desta variável.

O end if tag é uma tag igual a 6.

An entry é uma coisa com
Um nome address,
Um thunk address,
Um nome,
Um address.

O epilog tag é uma tag igual a 7.

O exit tag é uma tag igual a 8.

Um expression é um termo.

Etapas necessárias para que se extend um string com uma segunda string:
Se a segunda string estiver em branco, cancele.
Se o string não estiver em branco, posponha o caractere de espaço para o string.
Posponha a segunda string para o string.

\An campo é uma variável.
Um campo é uma variável.

Um campo termo é um conjunto com
Um dereference detector,
Um campo (reference),
Um function routine (reference),
Um push detector.

Etapas necessárias para que se finalize o compilador:
Destrua o catálogo de rotinas úteis.
Destrua o catálogo geral de rotinas.
Destrua o catálogo de variáveis hexadecimais.
Destrua o catálogo de variáveis globais.
Destrua o catálogo de tipos.
Destrua o imports.
Destrua as routines.
Destrua o literals.
Destrua o globals.
Destrua o types.
Destrua o source files.

O finalize tag é uma tag igual a 9.

Etapas necessárias para que se encontre um entry usando um string e alguns entries:
Esvazie o entry.
Percorra.
Obtenha a entry from o entries.
Se a entry for inexistente, cancele.
Se o nome desta entry for o string, cancele.
Repita.

Etapas necessárias para que se encontre um campo termo usando um phrase e um type e um nome:
Limpe o campo termo.
Encontre o campo termo usando o type e o nome.
Se o campo deste campo termo não for inexistente, cancele.
Se a phrase não estiver em branco, encontre uma routine usando "atribua" e a phrase e "'s " seguido de o nome e "para".
Se a routine não for inexistente, atribua a routine à function deste campo termo; exit.
Se o type for inexistente, cancele.
Encontre a routine usando "atribua" e o type e "'s " seguido de o nome e "para".
Se a routine não for inexistente, acione o push detector deste campo termo; atribua a routine ao function deste campo termo; exit.
\ code below for looking deep within endereço de memórias - a debatable feature
\ Se o target type deste type não for inexistente, encontre a routine usando "atribua" e o target type deste type e "'s " seguido de o nome e "para".
\ Se a routine não for inexistente, acione o dereference detector deste campo termo; atribua a routine à function deste campo termo; exit.

Etapas necessárias para que se encontre um campo termo usando um type e um nome:
Se o type for inexistente, cancele.
Encontre um campo usando o nome e os campos deste type.
Se o campo não for inexistente, atribua o campo ao campo deste campo termo; exit.
Se o target type deste type não for inexistente, encontre o campo usando o nome e os campos deste target type deste type.
Se o campo não for inexistente, acione o dereference detector deste campo termo; atribua o campo ao campo deste campo termo; exit.

Etapas necessárias para que se encontre um fragment usando um segundo fragment e uma tag:
Atribua o segundo fragment ao fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Atribua o next deste fragment ao fragment.
Repita.

Etapas necessárias para que se encontre um fragment usando um segundo fragment e uma tag (backwards):
Atribua o segundo fragment ao fragment.
Percorra.
Se o fragment for inexistente, cancele.
Se o tag deste fragment for o tag, cancele.
Atribua o previous deste fragment ao fragment.
Repita.

Etapas necessárias para que se encontre um import usando um string:
Esvazie o import.
Percorra.
Obtenha o import from o imports.
Se o import for inexistente, cancele.
Se o nome deste import for o string, cancele.
Repita.

Etapas necessárias para que se encontre um endereço completo e um número da linha usando um endereço de memória do pedaço :
Limpe o endereço completo.
Atribua 0 ao número da linha.
Encontre um source file usando o endereço de memória do pedaço .
Se o source file for inexistente, cancele.
Atribua o endereço completo deste source file ao endereço completo.
Encontre o número da linha usando o source file e o endereço de memória do pedaço .

Etapas necessárias para que se encontre uma routine usando um cabeçalho expandido e um monikette e um catálogo:
Se o monikette for inexistente, cancele.
Esvazie a routine.
Isole o cabeçalho expandido.
Atribua o type deste monikette ao type atual deste monikette.
Lance o subtexto atual deste monikette sobre o string deste monikette.
Percorra.
Posponha o monikette para o cabeçalho expandido (while bubbling).
Encontre um refer usando o cabeçalho expandido e o catálogo.
Se o refer não for inexistente, atribua o endereço de memória deste refer à routine.
Se o refer não for inexistente, encontre a routine usando o cabeçalho expandido e o next deste monikette e o catálogo.
Se a routine não for inexistente, pare.
Bubble o monikette.
Se o monikette estiver bubbled out, pare.
Atribua o original cabeçalho expandido ao cabeçalho expandido.
Repita.

Etapas necessárias para que se encontre uma routine usando alguns monikettes:
Esvazie a routine.
Encontre a routine usando um cabeçalho expandido e o first destes monikettes e o catálogo geral de rotinas.

Etapas necessárias para que se encontre uma routine usando um string e uma segunda string e um terceiro string e um quarto string:
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando a segunda string.
Adicione um terceiro monikette para os monikettes usando o terceiro string.
Adicione um quarto monikette para os monikettes usando o quarto string.
Encontre a routine usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type:
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando o type.
Encontre a routine usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e uma segunda string e uma segunda type:
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando a segunda type.
Encontre a routine usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e uma segunda string e um terceiro string:
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o terceiro string.
Encontre a routine usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre uma routine usando um string e um type e uma segunda string e um terceiro string e um quarto string e um quinto string:
Adicione um monikette para alguns monikettes usando o string.
Adicione uma segunda monikette para os monikettes usando o type.
Adicione um terceiro monikette para os monikettes usando a segunda string.
Adicione um quarto monikette para os monikettes usando o terceiro string.
Adicione um quinto monikette para os monikettes usando o quarto string.
Adicione um sexto monikette para os monikettes usando o quinto string.
Encontre a routine usando os monikettes.
Destrua os monikettes.

Etapas necessárias para que se encontre um número da linha usando um source file e um endereço de memória do pedaço :
Se o endereço de memória do pedaço for inexistente, atribua 0 ao número da linha; exit.
Lance um subtexto sobre o trecho deste source file.
Atribua 1 ao número da linha.
Percorra.
Se o subtexto estiver em branco, cancele.
Se o first deste subtexto for o endereço de memória do pedaço , cancele.
Se o target deste first deste subtexto for o return pedaço, adicione 1 para o número da linha.
Adicione 1 para o first deste subtexto.
Repita.

Etapas necessárias para que se encontre um source file usando um endereço de memória do pedaço :
Se o endereço de memória do pedaço for inexistente, esvazie o source file; exit.
Percorra.
Obtenha o source file from o source files.
Se o source file for inexistente, cancele.
Se o endereço de memória do pedaço for menor do que o first deste trecho deste source file, repita.
Se o endereço de memória do pedaço for maior do que o last deste trecho deste source file, repita.

Etapas necessárias para que se encontre um type e um nickname usando um nome:
Esvazie o type.
Limpe o nickname.
Encontre o type e o nickname usando o nome (forward).
Se o type não for inexistente, cancele.
Encontre o type e o nickname usando o nome (backward).
\Lance um subtexto sobre o nome.
\Percorra.
\Se o subtexto estiver em branco, cancele.
\Encontre o type usando o subtexto e o catálogo de tipos.
\Se o type não for inexistente, pare.
\Skip para o next palavra no subtexto.
\Repita.
\Atribua o first deste nome para first deste uma segunda subtexto. \ pode estar errado
\Atribua o first deste subtexto menos 2 ao last deste segunda subtexto.
\Se a segunda subtexto não estiver em branco, atribua a segunda subtexto ao nickname.
\Se a segunda subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre um type e um nickname usando um nome (backward):
Esvazie o type.
Limpe o nickname.
Lance um subtexto sobre o nome.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip para o previous palavra no subtexto.
Repita.
Atribua o last deste nome para o last desse segunda subtexto.
Atribua o last deste subtexto mais 2 ao first deste segunda subtexto.
Se a segunda subtexto não estiver em branco, atribua a segunda subtexto ao nickname.
Se a segunda subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre um type e um nickname usando um nome (forward):
\ original - no mude
Esvazie o type.
Limpe o nickname.
Lance um subtexto sobre o nome.
Percorra.
Se o subtexto estiver em branco, cancele.
Encontre o type usando o subtexto e o catálogo de tipos.
Se o type não for inexistente, pare.
Skip para o next palavra no subtexto.
Repita.
Atribua o first deste nome para o first desse segunda subtexto.
Atribua o first deste subtexto menos 2 ao last deste segunda subtexto.
Se a segunda subtexto não estiver em branco, atribua a segunda subtexto ao nickname.
Se a segunda subtexto estiver em branco, atribua o subtexto ao nickname.

Etapas necessárias para que se encontre uma variável usando um nome:
Se a rotina utilizada atualmente for inexistente, esvazie o variável; exit.
Encontre o variável usando o nome e os locals desta rotina utilizada atualmente.
Se o variável não for inexistente, cancele.
Encontre o variável usando o nome e os parâmetros desta rotina utilizada atualmente.
Se o variável não for inexistente, cancele.
Encontre o variável usando o nome e o catálogo de variáveis globais.
Se o variável não for inexistente, cancele.
Encontre o variável usando o nome e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se encontre uma variável usando um nome e algumas variáveis:
Esvazie o variável.
Percorra.
Obtenha o variável from o variáveis.
Se o variável for inexistente, cancele.
Se o nome desta variável for o nome, cancele.
Se o nickname desta variável for o nome, cancele.
Repita.


\Etapas necessárias para que se encontre uma variável usando um nome:
\Se a rotina utilizada atualmente for inexistente, esvazie o variável; exit.
\Encontre o variável usando o nome e os locals desta rotina utilizada atualmente.
\Se o variável não for inexistente, cancele.
\Encontre o variável usando o nome e os parâmetros desta rotina utilizada atualmente.
\Se o variável não for inexistente, cancele.
\Encontre o variável usando o nome e o catálogo de variáveis globais.
\Se o variável não for inexistente, cancele.
\ Encontre o variável usando o nome e o catálogo de variáveis hexadecimais.

\Etapas necessárias para que se encontre uma variável usando um nome e alguns variáveis:
\esvazie o variável.
\Percorra.
\Obtenha o variável from o variáveis.
\Se o variável for inexistente, cancele.
\Se o nome desta variável for o nome, cancele.
\Se o nickname desta variável for o nome, cancele.
\Repita.

An fragment é uma coisa com
Uma tag [break, call external, call indirect, call internal, dereference, end if, epilog, exit, finalize, increment, Intel, jump false, load address, load eax, loop, not, prolog, push address, push value, save eax, repeat, routine address],
Uma variável (reference) [call indirect, dereference, increment, load address, load eax, pop, push address, push value, routine address, save eax],
Uma segunda variável (reference) [load address],
Uma routine (reference) [call internal, routine address],
Uma entry (reference) [call external],
Um número [increment],
Um detector [load eax], \SAL
Um address,
Um texto hexadecimal called code.

Etapas necessárias para que se gere um nome usando um string:
Atribua o string ao nome.
Adicione 1 para o nome contagem deste compilador.
Converta o nome contagem deste compilador para uma segunda string.
Posponha a segunda string para o nome.

Etapas necessárias para que se obtenha um address usando uma routine:
Se o address desta routine não for 0, atribua o address desta routine ao address; exit.
Atribua -1 ao address desta routine.
Encontre uma segunda routine usando o employs cabeçalho expandido desta routine e o catálogo geral de rotinas.
Se a segunda routine for inexistente, apresente uma mensagem de erro contendo "Eu não consegui encontrar uma tarefa: " seguido de o employs cabeçalho expandido desta routine seguido de "' que você está tentando employ." e o local de aparição desta routine; exit.
Se o address desta segunda routine for -1, apresente a mensagem de erro contendo "Referência recursiva na cláusula employ." e o local de aparição desta routine; exit. \Bora traduzir
Obtenha o address usando a segunda routine.
Atribua o address ao address desta routine.

Etapas necessárias para que se obtenha uma contagem usando alguns imports (all entries mais markers):
Atribua 0 à contagem.
Percorra.
Obtenha um import from o imports.
Se o import for inexistente, cancele.
Adicione a contagem destas entries deste import para a contagem.
Adicione 1 para a contagem.
Repita.

Um global body é um subtexto.

O catálogo de variáveis globais é um catálogo.

An global é uma variável.

O globals são alguns globals.

O image base é um address igual a 4194304 [$00400000].

O import zona é um zona.

Um import header é um conjunto com
Um address called original first thunk, \ consulte https://www.linkedin.com/pulse/why-pe-need-original-first-thunkoft-milad-kahsari-alhadi/
\ https://stackoverflow.com/questions/42413937/why-pe-need-original-first-thunkoft#:~:text=The%20original%20first%20thunk%20is,%2C%20user32%20etc)%20are%20known.
\Thunks are the defnitive pieces of codes em an operating system that handle the transitions between 16 and 32-bit code.
\ Thus they ensure backward compatibility between the calls made by the application.
\ O OS is subjected com this facility for backward compatibility, so that the 16 bit applications can run smoothly em 32 bit environment.
\ O original first thunk is needed if the imports are bound but the imported .DLL does not match.
\ On a fresh unpatched version of Windows, all addresses of all functions em the base .DLLs (ntdll, kernel32, user32 etc) are known.
\Take shell32 for example, it links para kernel32!CreateProcess and the true address of CreateProcess can be stored directly em shell32.
\This is called import binding and lets the loader skip the step where it looks up all the addresses of the imported functions.
\This does not work if the imported .DLL has not been loaded at its preferred address nor if the .DLL has changed (security update etc).
\If this happens seguido de the loader has para look up the functions "the normal way" and the original first thunk array has para be used
\ because that is the only place where the RVAs of the function names are stored.
\ If import binding is not used seguido de the original first thunk array is optional and might not be present.
\ ASLR has probably made this optimization irrelevant.
Um número called timestamp, \ Set para zero until bound; seguido de this feld is set para the TimeDateStamp of the exporting FileHeader da DLL
Um address called forwarder chain, \ Forwarder Chain: O 32-bit catálogo of the frst forwarder em the list of imported functions
Um address called nome memory address, 
\It holds the RVA [Relative Virtual Address] of the dll para be loaded para memory. It is a dword value.
\It is comprised of : RVA = Image Base + Endian Order 
\Note: As we know OllyDbg gives the result em the Big Endian order where as the x86 architecture holds the address em the Little Endian order, 
\ so the address gets exchanged reversibly em the di tuples
Um address called first thunk memory address.
\ Once the API is linked and gets loaded para memory the frst thunk which is a RVA points para the Import Address Table [IAT]

An import é uma coisa com
Um nome address,
Um header address,
Um nome,
Um import header,
Some entries.

O imports são alguns imports.

O increment tag é uma tag igual a 10.

Etapas necessárias para que se catalogue um global:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o global for inexistente, cancele.
Se o nome deste global estiver no catálogo de variáveis globais, apresente uma mensagem de erro contendo "'" seguido de o nome deste global seguido de "' é uma variável global duplicada." e o local de aparição deste global; exit.
Catalogue o global usando o nome deste global e o catálogo de variáveis globais.

Etapas necessárias para que se catalogue um literal:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o literal for inexistente, cancele.
Se o nome deste literal estiver no catálogo de variáveis hexadecimais, apresente uma mensagem de erro contendo "Erro interno no nome do literal na função catálogo um literal" e o local de aparição deste literal; exit.
Catalogue o literal usando o nome deste literal e o catálogo de variáveis hexadecimais.

Etapas necessárias para que se catalogue um cabeçalho semi-expandido usando um catálogo (special):
Encontre um refer usando o cabeçalho semi-expandido e o catálogo.
Se o refer não for inexistente, cancele.
Catalogue o cabeçalho semi-expandido no catálogo.

Etapas necessárias para que se catalogue uma routine por utility use:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o detector de função desta routine estiver ativo, cancele.
Se o contagem destes parâmetros desta routine for 0, cancele.
Copy os monikettes desta routine para alguns monikettes.
Reduce os monikettes por utility use.
Converta os monikettes para um cabeçalho expandido.
Destrua os monikettes.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, cancele.
Encontre um refer usando o cabeçalho expandido e o catálogo de rotinas úteis.
Se o refer não for inexistente, atribua nil ao endereço de memória deste refer; exit.
Catalogue a routine usando o cabeçalho expandido e o catálogo de rotinas úteis.

Etapas necessárias para que se catalogue uma routine usando um cabeçalho expandido e um catálogo (special):
Encontre um refer usando o cabeçalho expandido e o catálogo.
Se o refer não for inexistente, atribua a routine ao endereço de memória deste refer; exit.
Catalogue a routine usando o cabeçalho expandido e o catálogo.

Etapas necessárias para que se catalogue uma routine usando alguns monikettes e um catálogo:
Se a routine for inexistente, cancele.
Limpe um cabeçalho semi-expandido.
Percorra.
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Posponha o monikette para o cabeçalho semi-expandido.
Se o monikette for o last destes monikettes, pare.
Catalogue o cabeçalho semi-expandido usando o catálogo (special).
Repita.
Catalogue a routine usando o cabeçalho semi-expandido como um cabeçalho expandido e o catálogo (special).

Etapas necessárias para que se catalogue alguns routines por utility use:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma routine from as routines.
Se a routine for inexistente, cancele.
Catalogue a routine por utility use.
Repita.

Etapas necessárias para que se catalogue um type:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Catalogue o type usando o nome deste type.

Etapas necessárias para que se catalogue um type usando um nome:
Se o type for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Encontre um existing type usando o nome e o catálogo de tipos.
Se o existing type for inexistente, catalogue o type usando o nome e o catálogo de tipos; exit.
Atribua o local de aparição deste type para um local de aparição.
Se o local de aparição for inexistente, atribua o local de aparição deste existing type ao local de aparição. \ point o erro para um type no source code, not um generated type
Apresente uma mensagem de erro contendo "Acho que já vi o tipo: " seguido de o nome seguido de "' em algum lugar antes; você deve ter duplicado ele." e o local de aparição.

O indexing utilities temporizador é um temporizador.

Etapas necessárias para que se initialize o compilador:

Etapas necessárias para que se initialize o compilador usando um endereço da pasta:
Atribua o endereço da pasta ao endereço da pasta deste compilador.
Atribua 0 ao nome contagem deste compilador.
Desative o detector de erros deste compilador.
Limpe a mensagem de erro deste compilador.
Limpe o endereço completo do arquivo de erro deste compilador.
Atribua 0 ao número da linha de erro deste compilador.
Esvazie a rotina utilizada atualmente.
Crie o catálogo de tipos com 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis globais com 13001 [buckets]. \ was 4027
Crie o catálogo de variáveis hexadecimais com 13001 [buckets]. \ was 4027
Crie o catálogo geral de rotinas com 13001 [buckets]. \ was 7919
Crie o catálogo de rotinas úteis com 13001 [buckets]. \ was 4027

Etapas necessárias para que se initialize um DOS header: \ vou alterar depois
Atribua 23117 [$5A4D] ao signature deste DOS header.
Atribua 64 [$0040] ao addressofrelocationtableinfile deste DOS header. \ O ?addressofrelocationtableinfile? is a pointer para the variável-length table of DLLs needed for this program.
Atribua 256 [$00000100] ao addressofpeheaderinfile deste DOS header. \O ?addressofpeheaderinfile? is a pointer para the ?PE Header?, a revised and extended version of the DOS Header introduced com advent of Windows. 
\O segunda 16 campos of the DOS Header are not used.

Etapas necessárias para que se initialize um PE header:
Initialize o PE header (standard header).
Initialize o PE header (optional header).
Initialize o PE header (version information).
Initialize o PE header (directories).
Initialize o PE header (import section).
Initialize o PE header (data section).
Initialize o PE header (code section).

Etapas necessárias para que se initialize um PE header (code section):
Copy pedaços from "code "'s first para o whereabouts deste nome desta code section deste PE header por 6.
Atribua o length desta code zona ao sizeinbytes desta code section deste PE header.
Atribua a base desta code zona ao addressinmemory desta code section deste PE header.
Atribua o length desta code zona ao sizeinfile desta code section deste PE header.
Atribua a base desta code zona ao addressinfile desta code section deste PE header.
Atribua -536870880 [$E0000020] para as characteristics desta code section deste PE header. \ executable, readable, writable, code object

Etapas necessárias para que se initialize um PE header (data section):
Copy pedaços from "data "'s first para o whereabouts deste nome desta data section deste PE header por 6.
Atribua o length desta zona de dados ao sizeinbytes desta data section deste PE header.
Atribua a base desta zona de dados ao addressinmemory desta data section deste PE header.
Atribua o length desta zona de dados ao sizeinfile desta data section deste PE header.
Atribua a base desta zona de dados ao addressinfile desta data section deste PE header.
Atribua -1073741760 [$C0000040] para as characteristics desta data section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (directories):
Atribua 16 [$00000010] ao numberofdirectories deste PE header.
Atribua a base desta import zona ao imagedirectoryentryimportaddress deste PE header.
Atribua o length desta import zona ao imagedirectoryentryimportsize deste PE header.

Etapas necessárias para que se initialize um PE header (import section):
Copy pedaços from "idata "'s first para o whereabouts deste nome desta idata section deste PE header por 6.
Atribua o length desta import zona ao sizeinbytes desta idata section deste PE header.
Atribua a base desta import zona ao addressinmemory desta idata section deste PE header.
Atribua o length desta import zona ao sizeinfile desta idata section deste PE header.
Atribua a base desta import zona ao addressinfile desta idata section deste PE header.
Atribua -1073741760 [$C0000040] para as characteristics desta idata section deste PE header. \ initialized, readable, writable

Etapas necessárias para que se initialize um PE header (optional header):
Atribua 267 [$010B] ao magicnumber deste PE header.
Atribua o length desta code zona ao sizeofcodeinfile deste PE header.
Atribua o length desta zona de dados ao sizeofinitializeddatainfile deste PE header.
Atribua 0 ao sizeofuninitializeddatainfile deste PE header.
Encontre uma routine usando "~initialize before run e run e finalize after run" e o catálogo geral de rotinas.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Erro interno: não achei a tarefa de inicialização"; exit.
Atribua o address desta routine menos o image base ao addressofentrypointinmemory deste PE header.
Atribua a base desta code zona ao addressofcodeinmemory deste PE header.
Atribua a base desta zona de dados ao addressofinitializeddatainmemory deste PE header.
Atribua o image base à imagebase deste PE header.
Atribua 4096 [$00001000] ao memoryalignment deste PE header.
Atribua 4096 [$00001000] ao filealignment deste PE header.
Atribua 0 ao reserved deste PE header.
Atribua o exe size deste compilador ao sizeofimageinmemory deste PE header.
Atribua 4096 [section base] ao sizeofallheadersinfile deste PE header.
Atribua 0 ao checksum deste PE header.
Atribua 0 para as dllcharacteristics deste PE header.
Atribua 1048576 [$00100000] ao maxstack deste PE header.
Atribua 16384 [$00004000] ao minstack deste PE header.
Atribua 1048576 [$00100000] ao maxheap deste PE header.
Atribua 16384 [$00004000] ao minheap deste PE header.
Atribua 0 ao loaderflags deste PE header.

Etapas necessárias para que se initialize um PE header (standard header):
Atribua 17744 [$00004550] ao signature deste PE header.
Atribua 332 [$014C] ao machinetype deste PE header.
Atribua 3 [$0003] ao numberofsections deste PE header.
Atribua 0 ao timestamp deste PE header.
Atribua 0 ao pointertosymboltable deste PE header.
Atribua 0 ao numberofsymbols deste PE header.
Atribua 224 [$00E0] ao sizeofoptionalheaderinbytes deste PE header.
Atribua 33166 [$818E] ao characteristics deste PE header.

Etapas necessárias para que se initialize um PE header (version information):
Atribua 0 ao majorlinkerversion deste PE header.
Atribua 0 ao minorlinkerversion deste PE header.
Atribua 4 [$0004] ao osmajorversion deste PE header.
Atribua 0 [$0000] ao osminorversion deste PE header.
Atribua 0 ao usermajorversion deste PE header.
Atribua 0 ao userminorversion deste PE header.
Atribua 4 [$0004] ao subsystemmajorversion deste PE header.
Atribua 0 [$0000] ao subsystemminorversion deste PE header.
Atribua 2 [$0002] ao subsystem deste PE header.

O Intel tag é uma tag igual a 11.

Um intermediate é um local.

O jump false tag é uma tag igual a 12.

Etapas necessárias para que se link:
Round up zona sizes.
Initialize um DOS header.
Initialize um PE header.
Fill o exe deste compilador com o null pedaço usando o exe size deste compilador.
Blurt o DOS header ao exe deste compilador.
Blurt o PE header ao exe deste compilador.
Blurt o imports ao exe deste compilador.
Blurt os globals ao exe deste compilador.
Blurt os literals ao exe deste compilador.
Blurt as routines ao exe deste compilador.

O linking temporizador é um temporizador.

Etapas necessárias para que se list:
Limpe o listagem deste compilador.
List a mensagem de erro deste compilador no listagem deste compilador.
List os types under "TYPES:" no listagem deste compilador.
List os globals under "GLOBALS:" no listagem deste compilador.
List os literals under "LITERALS:" no listagem deste compilador.
List as routines under "ROUTINES:" no listagem deste compilador.
List o catálogo de tipos under "TYPE INDEX:" no listagem deste compilador.
List o catálogo de variáveis globais under "GLOBAL INDEX:" no listagem deste compilador.
List o catálogo de variáveis hexadecimais under "LITERAL INDEX:" no listagem deste compilador.
List o catálogo geral de rotinas under "ROUTINE INDEX:" no listagem deste compilador.
List o catálogo de rotinas úteis under "catálogo de rotinas úteis:" no listagem deste compilador.
List o imports under "IMPORTS:" no listagem deste compilador.
List o source files under "SOURCE FILES:" no listagem deste compilador.
List os temporizadores under "TIMERS:" no listagem deste compilador.
Escreva o listagem deste compilador para o listagem endereço completo deste compilador.

Etapas necessárias para que se list um mensagem de erro em um trecho:
Se o mensagem de erro estiver em branco, cancele.
Posponha "COMPILE ABORTED - LISTING INCOMPLETE" para o trecho.
Advance o trecho (twice).
Posponha o mensagem de erro para o trecho.
Advance o trecho (twice).

Etapas necessárias para que se list um bucket em um trecho:
Se os refers deste bucket estiverem vazio, cancele.
Posponha "/bucket" para o trecho (with separator).
Advance o trecho.
List os refers deste bucket no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns entries em um trecho:
Obtenha um entry from as entries.
Se a entry for inexistente, cancele.
List a entry no trecho.
Repita.

Etapas necessárias para que se list um entry em um trecho:
Se a entry for inexistente, cancele.
Posponha "/entry" para o trecho (with separator).
Posponha o nome desta entry para o trecho (with separator).
Posponha o address desta entry para o trecho (as hex com separator).
Advance o trecho.

Etapas necessárias para que se list um fragment em um trecho:
Posponha "/fragment" para o trecho (with separator).
Posponha a tag deste fragment para o trecho (as um fragment tag string com separator).
Posponha a variável deste fragment para o trecho (with separator).
Posponha a segunda variável deste fragment para o trecho (with separator).
Posponha a routine deste fragment para o trecho (with separator).
Posponha a entry desta fragment para o trecho (with separator).
Posponha o número deste fragment para o trecho (as hex com separator).
Posponha o address deste fragment para o trecho (as hex com separator).
Converta o code deste fragment para um cifra hexadecimal.
Posponha o cifra hexadecimal para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns fragments em um trecho:
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
List o fragment no trecho.
Repita.

Etapas necessárias para que se list um import em um trecho:
Se o import for inexistente, cancele.
Posponha "/import" para o trecho (with separator).
Posponha o nome deste import para o trecho (with separator).
Advance o trecho.
List as entries deste import no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns imports em um trecho:
Obtenha um import from o imports.
Se o import for inexistente, cancele.
List o import no trecho.
Repita.

Etapas necessárias para que se list alguns imports under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o imports estiverem vazio, cancele.
List o imports no trecho.

Etapas necessárias para que se list um catálogo em um trecho:
Posponha "/" seguido de o used bucket contagem deste catálogo seguido de " buckets" para o trecho (with separator).
Posponha a contagem deste catálogo seguido de " refers" para o trecho (with separator).
Advance o trecho (twice).
Percorra.
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, cancele.
List o bucket no trecho.
Repita.

Etapas necessárias para que se list um catálogo under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o catálogo estiver vazio, cancele.
List o catálogo no trecho.

Etapas necessárias para que se list um refer em um trecho:
Se o refer for inexistente, cancele.
Posponha "/refer" para o trecho (with separator).
Posponha o string deste refer para o trecho.
Se o endereço de memória deste refer for inexistente, posponha "..." para o trecho.
Posponha "/" para o trecho.
Advance o trecho.

Etapas necessárias para que se list alguns refers em um trecho:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
List o refer no trecho.
Repita.

Etapas necessárias para que se list uma routine em um trecho:
Se a routine for inexistente, cancele.
Posponha "/routine" para o trecho (with separator).
Posponha o cabeçalho expandido desta routine para o trecho (with separator).
Posponha o compiled detector desta routine para o trecho (with separator).
Posponha o detector de compatibilidade desta routine para o trecho (with separator).
Posponha o detector de deliberação desta routine para o trecho (with separator).
Posponha o detector de função desta routine para o trecho (with separator).
Posponha o employs cabeçalho expandido desta routine para o trecho (with separator).
Posponha o parâmetro size desta routine para o trecho (with separator).
Posponha o local size desta routine para o trecho (with separator).
Posponha o address desta routine para o trecho (as hex com separator).
Advance o trecho.
List os parâmetros desta routine no trecho.
List os locals desta routine no trecho.
List os fragments desta routine no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns routines em um trecho:
Obtenha uma routine from as routines.
Se a routine for inexistente, cancele.
List a routine no trecho.
Repita.

Etapas necessárias para que se list alguns routines under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se as routines estiverem vazio, cancele.
List as routines no trecho.

Etapas necessárias para que se list um source file em um trecho:
Se o source file for inexistente, cancele.
Posponha "/source file" para o trecho (with separator).
Posponha o endereço completo deste source file para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns source files em um trecho:
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
List o source file no trecho.
Repita.

Etapas necessárias para que se list alguns source files under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o source files estiverem vazio, cancele.
List o source files no trecho.
Advance o trecho.

Etapas necessárias para que se list um temporizador usando um string em um trecho:
Posponha "/timer" para o trecho (with separator).
Posponha o string para o trecho (with separator).
Posponha o string deste temporizador para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list os temporizadores under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
List o temporizador de operacionalização usando "loading" no trecho.
List o temporizador de análise/verificação usando "scanning" no trecho.
List o resolving types temporizador usando "resolving types" no trecho.
List o resolving globals temporizador usando "resolving globals" no trecho.
List o temporizador de compilação de cabeçalhos de rotina usando "compiling routine headers" no trecho.
List o calculating temporizador usando "calculating" no trecho.
List o adding built-in memory routines temporizador usando "adding built-in memory routines" no trecho.
List o indexing utilities temporizador usando "indexing utilities" no trecho.
List o compiling routine bodies temporizador usando "compiling routine bodies" no trecho.
List o adding built-in startup routine temporizador usando "adding built-in startup routine" no trecho.
List o offsetting temporizador usando "offsetting" no trecho.
List o addressing temporizador usando "addressing" no trecho.
List o transmogrifying temporizador usando "transmogrifying" no trecho.
List o linking temporizador usando "linking" no trecho.
List o writing temporizador usando "writing" no trecho.
List o temporizador deste compilador usando "total" no trecho.
Advance o trecho.

Etapas necessárias para que se list um type em um trecho:
Se o type for inexistente, cancele.
Posponha "/type" para o trecho (with separator).
Posponha o nome deste type para o trecho (with separator).
Posponha o plural nome deste type para o trecho (with separator).
Posponha o length deste type para o trecho (as hex com separator).
Posponha o base nome deste type para o trecho (with separator).
Posponha o base type deste type para o trecho (with separator).
Posponha o target nome deste type para o trecho (with separator).
Posponha o target type deste type para o trecho (with separator).
Posponha a scale deste type para o trecho (with separator).
Advance o trecho.
List os campos deste type no trecho.
Advance o trecho.

Etapas necessárias para que se list alguns types em um trecho:
Obtenha um type from o types.
Se o type for inexistente, cancele.
List o type no trecho.
Repita.

Etapas necessárias para que se list alguns types under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se os types estiverem vazio, cancele.
List os types no trecho.

Etapas necessárias para que se list uma variável em um trecho:
Se o variável for inexistente, cancele.
Posponha "/variável" para o trecho (with separator).
Posponha o categoria desta variável para o trecho (with separator).
Posponha o compiled detector desta variável para o trecho (with separator).
Posponha o nome desta variável para o trecho (with separator).
Posponha o nickname desta variável para o trecho (with separator).
Posponha o type nome desta variável para o trecho (with separator).
Posponha o type desta variável para o trecho (with separator).
Posponha o address desta variável [or offset] para o trecho (as hex com separator).
Posponha o by-value detector desta variável para o trecho (with separator).
Posponha o contagem desta variável para o trecho (with separator).
Posponha o reference detector desta variável para o trecho (with separator).
Posponha o redefinition target nome desta variável para o trecho (with separator).
Posponha o literal desta variável para o trecho (with separator).
Converta o data desta variável para um cifra hexadecimal.
Posponha o cifra hexadecimal para o trecho (with separator).
Advance o trecho.

Etapas necessárias para que se list alguns variáveis em um trecho:
Obtenha uma variável from o variáveis.
Se o variável for inexistente, cancele.
List o variável no trecho.
Repita.

Etapas necessárias para que se list alguns variáveis under um string em um trecho:
Posponha o string para o trecho.
Advance o trecho (twice).
Se o variáveis estiverem vazio, cancele.
List o variáveis no trecho.
Advance o trecho.

O catálogo de variáveis hexadecimais é um catálogo.

An literal é uma variável.

O literals são alguns literals.

O load address tag é uma tag igual a 13.

O load eax tag é uma tag igual a 14.

An local é uma variável.

Um local de aparição é um endereço de memória do pedaço .

O loop tag é uma tag igual a 15.

Um cabeçalho expandido é um string. 
\ A cabeçalho expandido is the internal representation of a routine header com
\ ? no articles preceding parameter types,
\ ? parameter types in square brackets, and
\ ? expanded prepositions.
\ Each piece of a cabeçalho expandido is a monikette. For example:
\ Routine header: To add a number to a count:
\ Moniker: add [number] in/into/to [count]
\ Monikettes: (1) add (2) [number] (3) in/into/to (4) [count]
 \ We use this internal representation because it...
\ ? makes it easy reduce types (like [count] to [number]) when looking for an appropriate routine to call;
\ ? makes it easy to expand prepositions (like "to" para "in/into/to"); and
\ ? shows how the compiler interpreted various phrases in error messages.
Um monikette é uma coisa com
Um string,
Um type (reference),
Um variável (reference),
\ por bubbling
Um type atual (reference),
Um subtexto atual.

Um cabeçalho semi-expandido é um cabeçalho expandido.

Etapas necessárias para que se mova um percorredor (code rules - comment):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor não for o return pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - glom):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o percorredor estiver sobre any possessive, cancele.
Se o target deste first deste source deste percorredor for any glom pedaço, repita.

Etapas necessárias para que se mova um percorredor (code rules - mark):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - noise):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for noise, repita.

Etapas necessárias para que se mova um percorredor (code rules - possessive):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o source deste percorredor starts com "s", avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules - qualifier):
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, pare.
Se o target deste first deste source deste percorredor for o parênteses esquerdo, adicione 1 para uma contagem.
Se o target deste first deste source deste percorredor for o parênteses direito, subtraia 1 from a contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - remark):
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, pare.
Se o target deste first deste source deste percorredor for o colchete esquerdo, adicione 1 para uma contagem.
Se o target deste first deste source deste percorredor for o right-bracket pedaço, subtraia 1 from a contagem.
Avance o percorredor.
Se o contagem for 0, pare.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - string):
Avance o percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for o return pedaço, cancele.
Se o percorredor estiver sobre any nested double-quote, avance o percorredor; repita.
Se o target deste first deste source deste percorredor for as aspas duplas, avance o percorredor; exit.
Repita.

Etapas necessárias para que se mova um percorredor (code rules - symbol):
Avance o percorredor.

Etapas necessárias para que se mova um percorredor (code rules):
Position o token deste percorredor sobre o source deste percorredor.
Se o source deste percorredor estiver em branco, cancele.
Se o target deste first deste source deste percorredor for noise, mova o percorredor (code rules - noise); exit.
Se o target deste first deste source deste percorredor for a barra invertida, mova o percorredor (code rules - comment); exit.
Se o target deste first deste source deste percorredor for o colchete esquerdo, mova o percorredor (code rules - remark); exit.
Se o target deste first deste source deste percorredor for as aspas duplas, mova o percorredor (code rules - string); exit.
Se o target deste first deste source deste percorredor for o parênteses esquerdo, mova o percorredor (code rules - qualifier); exit.
Se o target deste first deste source deste percorredor for any mark, mova o percorredor (code rules - mark); exit.
Se o percorredor estiver sobre any possessive, mova o percorredor (code rules - possessive); exit.
Mova o percorredor (code rules - glom).

Etapas necessárias para que se mova um percorredor (usando diretrizes do compilador): \ talvez aqui conserte o subtraia
Se o detector de erros deste compilador estiver ativo, limpe o token deste percorredor; exit.
Mova o percorredor devolvendo um erro string (code rules).
Se o erro string não estiver em branco, apresente uma mensagem de erro contendo o erro string e o first deste token deste percorredor; exit.
\Se o token deste percorredor for "del", recue o percorredor; exit. \ Spanish contraction "del"; fudged para "de l", short por "de el"
\Se o token deste percorredor for "al", recue o percorredor; exit. \ Spanish contraction "al"; fudged para "a l", short por "a el"
Se o token deste percorredor estiver em branco, cancele.
Se o target deste first deste token deste percorredor for noise, repita.
Se o target deste first deste token deste percorredor for a barra invertida, repita.
Se o target deste first deste token deste percorredor for o colchete esquerdo, repita.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (code rules - validate qualifier):
Se o length deste token deste percorredor for menor do que 2, atribua "Qualificadores devem terminar com parêntese ')'." ao erro string; exit.
Se o target deste last deste token deste percorredor não for o parênteses direito, atribua "Qualificadores precisam terminar com um parêntese ')'." ao erro string; exit.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (code rules - validate remark):
Se o length deste token deste percorredor for menor do que 2, atribua "Observações devem terminar com um colchete ']'." ao erro string; exit.
Se o target deste last deste token deste percorredor não for o right-bracket pedaço, atribua "Observações precisam terminar com um colchete ']'." ao erro string; exit.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (code rules - validate string):
Se o length deste token deste percorredor for menor do que 2, atribua "Textos precisam terminar com aspas: ""." ao erro string; exit.
Se o target deste last deste token deste percorredor não for as aspas duplas, atribua "Textos devem terminar com aspas: ""." ao erro string; exit.

Etapas necessárias para que se mova um percorredor devolvendo um erro string (code rules):
Limpe o erro string.
Mova o percorredor (code rules).
Se o token deste percorredor estiver em branco, cancele.
Se o target deste first deste token deste percorredor for o colchete esquerdo, mova o percorredor devolvendo o erro string (code rules - validate remark); exit.
Se o target deste first deste token deste percorredor for as aspas duplas, mova o percorredor devolvendo o erro string (code rules - validate string); exit.
Se o target deste first deste token deste percorredor for o parênteses esquerdo, mova o percorredor devolvendo o erro string (code rules - validate qualifier); exit.

Um parte da cifra binária é um subtexto.

Um nickname é um nome.

O not tag é uma tag igual a 16.

Etapas necessárias para que se offset o locals em uma routine:
Se a routine for inexistente, cancele.
Se a compiled detector desta routine não estiver ativo, cancele.
Limpe o local size desta routine.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um local from os locals desta routine.
Se o local for inexistente, cancele.
Se o previous deste local não for inexistente, atribua o offset deste previous deste local ao offset deste local.
Atribua o length deste type deste local para um length.
Se a categoria deste local for "scratch", atribua a magnitude desse endereço de memória ao length.
Round o length up para o nearest multiple of 4.
Subtraia o length from o offset deste local.
Adicione o length para o local size desta routine.
Repita.

Etapas necessárias para que se offset os locals em alguns routines:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma routine from as routines.
Se a routine for inexistente, cancele.
Offset os locals na routine.
Repita.

Etapas necessárias para que se offset o parâmetros em uma routine:
Se a routine for inexistente, cancele.
Se a compiled detector desta routine não estiver ativo, cancele.
Limpe o parâmetro size desta routine.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um parâmetro from os parâmetros desta routine.
Se o parâmetro for inexistente, cancele.
Se o detector de compatibilidade desta routine estiver ativo, acione o by-value detector deste parâmetro.
Se o previous deste parâmetro for inexistente, atribua 8 ao offset deste parâmetro. \ skip o return address e saved ebp
Se o previous deste parâmetro não for inexistente, atribua o offset deste previous deste parâmetro mais 4 ao offset deste parâmetro. \ all parâmetros são 4 endereço de memória do pedaço s ou 4 pedaço values por callbacks
Adicione 4 para a parâmetro size desta routine.
Repita.

Etapas necessárias para que se offset o parâmetros em alguns routines:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma routine from as routines.
Se a routine for inexistente, cancele.
Offset o parâmetros na routine.
Repita.

O offsetting temporizador é um temporizador.

An parâmetro é uma variável.



Um PE header é um conjunto com
\ Portable Executable (PE) file format is a file format for executable / dll files introduced em Windows NT. It is based sobre COFF (Common Object File Format) specification.
\To remain compatible com previous versions of the MS-DOS and Windows, the PE file format retains the old MZ header from MS-DOS.
\O PE file format is organized as a linear stream of data. 
\It begins com an MS-DOS header, a real-mode program stub, and a PE file signature. 
\Immediately following is a PE file header and optional header. Beyond that, all the section headers appear, followed by all of the section bodies. 
\Closing out the file are a few segunda regions of miscellaneous information, including relocation information, symbol table information, line number information, and string table data. 
\ O MS-DOS header occupies the first 64 bytes of the PE file. A structure representing its content is described below:
Um número called signature,
Um wyrd called machinetype, \ O number that identifies the type of target machine. For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#machine-types
Um wyrd called numberofsections, \ O number of sections. This indicates the size of the section table, which immediately follows the headers.
Um número called timestamp, \ O low 32 bits of the number of seconds since 00:00 January 1, 1970 (a C run-time time_t value), which indicates when the file was created.
Um número called pointertosymboltable, \ O file offset of the COFF symbol table, or zero if no COFF symbol table is present. 
\This value should be zero for an image because COFF debugging information is deprecated.
Um número called numberofsymbols, \ O number of entries em the symbol table. 
\This data can be used para locate the string table, which immediately follows the symbol table. 
\This value should be zero for an image because COFF debugging information is deprecated.
Um wyrd called sizeofoptionalheaderinbytes, \ O size of the optional header, which is required for executable files but not for object files. 
\This value should be zero for an object file. For a description of the header format, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#optional-header-image-only
Um wyrd called characteristics, \ O flags that indicate the attributes of the file. For specific flag values, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#characteristics
\ optional header
Um wyrd called magicnumber, \ O optional header magic number determines whether an image is a PE32 or PE32+ executable.
\PE32+ images allow for a 64-bit address space while limiting the image size para 2 gigabytes. Other PE32+ modifications are addressed em their respective sections.
\ O unsigned integer that identifies the state of the image file. 
\O most common number is 0x10B, which identifies it as a normal executable file. 0x107 identifies it as a ROM image, and 0x20B identifies it as a PE32+ executable.
\ O first campo, e_magic, is the so-called magic number. 
\This campo is used para identify an MS-DOS-compatible file type. 
\All MS-DOS-compatible executable files set this value para 0x5A4D, which represents the ASCII characters MZ. 
\MS-DOS headers are sometimes referred para as MZ headers for this reason. 
\Many segundo campos are important para MS-DOS operating systems, but for Windows NT, there is really one more important campo em this structure. 
\O final campo, e_lfanew, is a 4-byte offset para the file where the PE file header is located. 
\It is necessary para use this offset para locate the PE header em the file. 
\For PE files em Windows NT, the PE file header occurs soon after the MS-DOS header com only the real-mode stub program between them.
Um pedaço called majorlinkerversion, \ Indicates version of the linker that linked this image.
Um pedaço called minorlinkerversion, \ Indicates version of the linker that linked this image.
Um número called sizeofcodeinfile, \ Size of executable code. O size of the code (text) section, or the sum of all code sections if there are multiple sections.
Um número called sizeofinitializeddatainfile, \ Size of initialized data. O size of the initialized data section, or the sum of all such sections if there are multiple data sections.
Um número called sizeofuninitializeddatainfile, \ Size of uninitialized data. O size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.
Um número called addressofentrypointinmemory, \ Of the standard campos, the AddressOfEntryPoint campo is the most interesting for the PE file format. 
\This campo indicates the location of the entry point for the application and, perhaps more importantly para system hackers, the location of the end of the Import Address Table (IAT). 
\O address of the entry point relative para the image base when the executable file is loaded para memory. 
\For program images, this is the starting address. For device drivers, this is the address of the initialization function. 
\Um entry point is optional for DLLs. When no entry point is present, this campo must be zero.
Um número called addressofcodeinmemory, \ O address that is relative para the image base of the beginning-of-code section when it is loaded para memory.
Um número called addressofinitializeddatainmemory, \ O address that is relative para the image base of the beginning-of-data section when it is loaded para memory.
Um número called imagebase, \ O preferred address of the first byte of image when loaded para memory; must be a multiple of 64 K. 
\O default for DLLs is 0x10000000. O default for Windows CE EXEs is 0x00010000. 
\O default for Windows NT, Windows 2000, Windows XP, Windows 95, Windows 98, and Windows Me is 0x00400000.
\Preferred base address em the address space of a process para map the executable image to. O linker defaults para 0x00400000, but you can override the default.
Um número called memoryalignment, \ O alignment (in bytes) of sections when they are loaded para memory. 
\It must be greater than or equal para FileAlignment. 
\O default is the page size for the architecture.
Um número called filealignment, \ O alignment factor (in bytes) that is used para align the raw data of sections em the image file. 
\O value should be a power of 2 between 512 and 64 K (65535) , inclusive. O default is 512. 
\If the SectionAlignment is less than the page size da architecture, seguido de FileAlignment must match SectionAlignment.
Um wyrd called osmajorversion, \ Indicates the major version of the Windows NT operating system.
Um wyrd called osminorversion, \ Indicates the minor version of the Windows NT operating system.
Um wyrd called usermajorversion, \ Used para indicate the major version number of the application.
Um wyrd called userminorversion, \ Used para indicate the minor version number of the application.
Um wyrd called subsystemmajorversion, \ Indicates the Windows NT Win32 subsystem major version number.
Um wyrd called subsystemminorversion, \ Indicates the Windows NT Win32 subsystem minor version number.
Um número called reserved, \ Reserved, must be zero. Unknown purpose, currently not used by the system and set para zero by the linker.
Um número called sizeofimageinmemory, \ O size (in bytes) of the image, including all headers, as the image is loaded em memory. It must be a multiple of SectionAlignment.
\ Indicates the amount of address space para reserve em the address space for the loaded executable image. 
\This number is influenced greatly by SectionAlignment. 
\For example, consider a system having a fixed page size of 4096 bytes. 
\If you have an executable com 11 sections, each less than 4096 bytes, aligned sobre a 65,536-byte boundary, the SizeOfImage campo would be set para 11 * 65,536 = 720,896 (176 pages). 
\O same file linked com 4096-byte alignment would result em 11 * 4096 = 45,056 (11 pages) for the SizeOfImage campo. 
\This is a simple example em which each section requires less than a page of memory. 
\In reality, the linker determines the exact SizeOfImage by figuring each section individually. 
\It first determines how many bytes the section requires, seguido de it rounds up para the nearest page boundary, and finally it rounds page count para the nearest SectionAlignment boundary. 
\O total is seguido de the sum of each individual requirement da section.
Um número called sizeofallheadersinfile, \ O combined size of an MS-DOS stub, PE header, and section headers rounded up para a multiple of FileAlignment.
\ This campo indicates how much space em the file is used for representing all the file headers, 
\ including the MS-DOS header, PE file header, PE optional header, and PE section headers. O section bodies begin at this location em the file.
Um número called checksum, \ O image file checksum. 
\ O algorithm for computing the checksum is incorporated para IMAGHELP.DLL. 
\ O following are checked for validation at load time: all drivers, any DLL loaded at boot time, and any DLL that is loaded à critical Windows process.
\ A checksum value is used para validate the executable file at load time. 
\ O value is set and verified by the linker. O algorithm used for creating these checksum values is proprietary information and will not be published.
Um wyrd called subsystem, \ Field used para identify the target subsystem for this executable (O subsystem that is required para run this image). 
\Each of the possible subsystem values are listed em the WINNT.H file immediately after the IMAGE_OPTIONAL_HEADER structure.
\For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#windows-subsystem
Um wyrd called dllcharacteristics, \ Flags used para indicate if a DLL image includes entry points for process and thread initialization and termination.
\ For more information, see https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#dll-characteristics
Um número called maxstack, \These campos control the amount of address space para reserve and commit for the stack and default heap. 
Um número called minstack, \Both the stack and heap have default values of 1 page committed and 16 pages reserved. 
Um número called maxheap, \These values are set com the linker switches -STACKSIZE: and -HEAPSIZE:. 
Um número called minheap, 
Um número called loaderflags, \ TReserved, must be zero. Tells the loader whether para break sobre load, debug sobre load, or the default, which is para let things run normally.
\ directories (16 address e size pairs)
Um número called numberofdirectories,
8 pedaços called directory0,
Um número called imagedirectoryentryimportaddress,
Um número called imagedirectoryentryimportsize,
112 pedaços called directories2-15,
Um PE section header called idata section,
Um PE section header called data section,
Um PE section header called code section. \ https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#section-flags

Um PE section header é um conjunto com
\ Section headers are located sequentially right after the optional header em the PE file format. Each section header is 40 bytes com no padding between them. 
\O PE file specification consists of the headers defined so far and a generic object called a section. 
\Sections contain the content of the file, including code, data, resources, and segunda executable information. 
\Each section has a header and a body (the raw data). Section headers are described below, but section bodies lack a rigid file structure. 
\They can be organized em almost any way a linker wishes para organize them, as long as the header is filled com enough information para be able para decipher the data.
8 pedaços called nome, \ Each section header has a nome campo up para eight characters long, for which the first character must be a period.
Um número called sizeinbytes,
Um número called addressinmemory,
Um número called sizeinfile,
Um número called addressinfile,
12 pedaços called reserved,
Um número called characteristics. \ Defines the section characteristics. These values are found both em WINNT.H and em the Portable Executable Format specification.
\Value	Definition
\0x00000020	Code section
\0x00000040	Initialized data section
\0x00000080	Uninitialized data section
\0x04000000	Section cannot be cached
\0x08000000	Section is not pageable
\0x10000000	Section is shared
\0x20000000	Executable section
\0x40000000	Readable section
\0x80000000	Writable section

Um phrase é um string.

\Etapas necessárias para que se determine se um string looks like English:
\Load o lexicon.
\Se o lexicon for inexistente, mostre erro "I can't find any lecksicon."; diga não.
\Se o string estiver em branco, diga não.
\Lance um subtexto sobre o string.
\Atribua o last deste subtexto ao first deste subtexto.
\Percorra.
\Se o first deste subtexto é o first deste string, pare.
\Se o target deste first deste subtexto for o caractere de espaço, adicione 1 para o first deste subtexto; break.
\Subtraia 1 from o first deste subtexto.
\Repita.
\Se o subtexto estiver no catálogo deste lexicon, diga sim.
\Diga não.

Etapas necessárias para que se pluralize um string (portuguese rules):
Lance um percorredor sobre o string.
Percorra.
Mova o percorredor (spell checking rules).
Se o token deste percorredor estiver em branco, pare.
Se um plural string não estiver em branco, posponha " " para o plural string.
Posponha o token deste percorredor para o plural string.
Se o token deste percorredor for "de", acione um detector; repita. \ aqui identifica um termo composto. Falta implementar.
Se o detector não estiver ativo, pluralize o plural string (portuguese rules - each palavra).
\ Se o detector estiver ativo, pluralize o plural string (substantivos compostos).
Repita.
Atribua o plural string ao string.

Etapas necessárias para que se pluralize um string (portuguese rules - each palavra):
\PAL
\# https://www.normaculta.com.br/singular-e-plural/
\# palavras que são exceções às regras
Se o string for "bit", atribua "bits" ao string; exit.
Se o string for "cidadão", posponha "s" para o string; exit.
Se o string for "irmão", posponha "s" para o string; exit.
Se o string for "cristão", posponha "s" para o string; exit.
Se o string for "refrão", posponha "s" para o string; exit.
Se o string for "pão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "capitão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "alemão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "charlatão", remove o last pedaço from o string; posponha "es" para o string; exit.
Se o string for "caráter", atribua "carateres" ao string; exit.
Se o string for "júnior", atribua "juniores" ao string; exit.
Se o string for "sênior", atribua "seniores" ao string; exit.
Se o string for "mão", atribua "mãos" ao string; exit.
Se o string for "são", atribua "sãos" ao string; exit.
\# advérbios principais
Se o string for "muito", cancele.
Se o string for "pouco", cancele.
Se o string for "mais", cancele.
Se o string for "menos", cancele.
Se o string for "bastante", cancele.
Se o string for "quase", cancele.
Se o string for "demais", cancele.
Se o string for "bem", cancele.
Se o string for "deveras", cancele.
Se o string for "mal", cancele.
Se o string for "melhor", cancele.
Se o string for "pior", cancele.
\# palavras terminadas com "ão"
Se o string termina com "ão", pluralize o string (portuguese rules - ending palavras com "ão"); exit.
\# palavras terminadas com "l"
Se o string termina com "l", pluralize o string (portuguese rules - ending palavras com "l"); exit.
\# palavra terminadas com "m"
Se o string termina com "m", remove o last pedaço from o string; posponha "ns" para o string; exit.
\# palavra terminadas com "n" (essa regra é preferível porque mantém o acento da palavra, se houver)
Se o string termina com "n", posponha "es" para o string; exit.
\# palavras terminadas com "r"
Se o string termina com "r", pluralize o string (portuguese rules - ending palavras com "r"); exit.
\# palavras terminadas com "s"
Se o string termina com "s", pluralize o string (portuguese rules - ending palavras com "s"); exit.
\# palavra terminadas com "x"
Se o string termina com "x", posponha "es" para o string; exit.
\# palavras terminadas com "z"
Se o string termina com "z", pluralize o string (portuguese rules - ending palavras com "z"); exit.
\# regra padrão
Posponha "s" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "ão"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "s" para o string; exit.
\# regra padrão
Remove os last dois pedaços from o string.
Posponha "ões" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "l"):
\# palavras terminadas com "al"
Se o string termina com "al", remove o last pedaço from o string; posponha "is" para o string; exit.
\# palavras terminadas com "el"
Se o string termina com "el", pluralize o string (portuguese rules - ending palavras com "el"); exit.
\# palavras terminadas com "il"
Se o string termina com "il", pluralize o string (portuguese rules - ending palavras com "il"); exit.
\# palavras terminadas com "ol"
Se o string termina com "ol", pluralize o string (portuguese rules - ending palavras com "ol"); exit.
\# palavras terminadas com "ul"
Se o string termina com "ul", remove o last pedaço from o string; posponha "is" para o string; exit.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "el"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" para o string; exit.
Remove os last dois pedaços from o string.
Posponha "éis" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "il"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove os last dois pedaços from o string; posponha "eis" para o string; exit.
Remove o last pedaço from o string.
Posponha "s" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "ol"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, remove o last pedaço from o string; posponha "is" para o string; exit.
Remove os last dois pedaços from o string.
Posponha "óis" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "r"):
\# hiatos acentuados
\Se o string termina com "aír", posponha "es" para o string; exit.
\Se o string termina com "aúr", posponha "es" para o string; exit.
\# palavras terminadas em "ár", "âr", "ér", "êr", "ír", "ór", "ôr", "úr"
\Se o string termina com "ár", remove os last dois pedaços from o string; posponha "ares" para o string; exit.
\Se o string termina com "âr", remove os last dois pedaços from o string; posponha "ares" para o string; exit.
\Se o string termina com "ér", remove os last dois pedaços from o string; posponha "eres" para o string; exit.
\Se o string termina com "êr", remove os last dois pedaços from o string; posponha "eres" para o string; exit.
\Se o string termina com "ír", remove os last dois pedaços from o string; posponha "ires" para o string; exit.
\Se o string termina com "ór", remove os last dois pedaços from o string; posponha "ores" para o string; exit.
\Se o string termina com "ôr", remove os last dois pedaços from o string; posponha "ores" para o string; exit.
\Se o string termina com "úr", remove os last dois pedaços from o string; posponha "ures" para o string; exit.
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" para o string; exit.
\# hiatos
Se o string termina com "air", remove os last dois pedaços from o string; posponha "íres" para o string; exit.
Se o string termina com "aur", remove os last dois pedaços from o string; posponha "úres" para o string; exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "s"):
\# proparoxítonas/paroxítonas terminadas com "as", "es", "os"
Se o string termina com "as", cancele.
Se o string termina com "es", cancele.
Se o string termina com "os", cancele.
\# hiatos acentuados
Se o string termina com "aís", posponha "es" para o string; exit.
Se o string termina com "aús", posponha "es" para o string; exit.
\# oxítonas terminadas com "ás", "âs", "és", "ês", "ís", "ós", "ôs", "ús"
Se o string termina com "ás", remove os last dois pedaços from o string; posponha "ases" para o string; exit.
Se o string termina com "âs", remove os last dois pedaços from o string; posponha "ases" para o string; exit.
Se o string termina com "és", remove os last dois pedaços from o string; posponha "eses" para o string; exit.
Se o string termina com "ês", remove os last dois pedaços from o string; posponha "eses" para o string; exit.
Se o string termina com "ís", remove os last dois pedaços from o string; posponha "ises" para o string; exit.
Se o string termina com "ós", remove os last dois pedaços from o string; posponha "oses" para o string; exit.
Se o string termina com "ôs", remove os last dois pedaços from o string; posponha "oses" para o string; exit.
Se o string termina com "ús", remove os last dois pedaços from o string; posponha "uses" para o string; exit.
\# palavras terminadas com "is", "us"
Se o string termina com "is", pluralize o string (portuguese rules - ending palavras com "is/us"); exit.
Se o string termina com "us", pluralize o string (portuguese rules - ending palavras com "is/us"); exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "is/us"):
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, cancele.
\# hiatos
Se o string termina com "ais", remove os last dois pedaços from o string; posponha "íses" para o string; exit.
Se o string termina com "aus", remove os last dois pedaços from o string; posponha "úses" para o string; exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (portuguese rules - ending palavras com "z"):
\# hiatos acentuados
Se o string termina com "aíz", posponha "es" para o string; exit.
Se o string termina com "aúz", posponha "es" para o string; exit.
\# palavras terminas em "áz", "âz", "éz", "êz", "íz", "óz", "ôz", "úz"
Se o string termina com "áz", remove os last dois pedaços from o string; posponha "azes" para o string; exit.
Se o string termina com "âz", remove os last dois pedaços from o string; posponha "azes" para o string; exit.
Se o string termina com "éz", remove os last dois pedaços from o string; posponha "ezes" para o string; exit.
Se o string termina com "êz", remove os last dois pedaços from o string; posponha "ezes" para o string; exit.
Se o string termina com "íz", remove os last dois pedaços from o string; posponha "izes" para o string; exit.
Se o string termina com "óz", remove os last dois pedaços from o string; posponha "ozes" para o string; exit.
Se o string termina com "ôz", remove os last dois pedaços from o string; posponha "ozes" para o string; exit.
Se o string termina com "úz", remove os last dois pedaços from o string; posponha "uzes" para o string; exit.
\# acentos em sílabas prévias
Lance um subtexto sobre o string.
Subtraia 2 from o last deste subtexto.
Se o subtexto has any stressed vowel, posponha "es" para o string; exit.
\# hiatos
Se o string termina com "aiz", remove os last dois pedaços from o string; posponha "ízes" para o string; exit.
Se o string termina com "auz", remove os last dois pedaços from o string; posponha "úzes" para o string; exit.
\# regra padrão
Posponha "es" para o string.

Etapas necessárias para que se pluralize um string (english rules); \ plural inglês
Etapas necessárias para que se pluralize um string:
Se o string for "centena", atribua "centenas" ao string; exit.
Se o string for "milhar", atribua "milhares" ao string; exit.
Se o string for "entrada", atribua "entradas" ao string; exit.
Se o string for "campo", atribua "campos" ao string; exit.
Se o string for "fragmento", atribua "fragmentos" ao string; exit.
Se o string for "parâmetro", atribua "parâmetros" ao string; exit.
Se o string for "fonte", atribua "fontes" ao string; exit.
Se o string for "forma", atribua "formas" ao string; exit.
Se o string for "contexto", atribua "contextos" ao string; exit.
Se o string for "evento", atribua "eventos" ao string; exit.
Se o string for "catálogo", atribua "catálogos" ao string; exit.
Se o string for "índice", atribua "índices" ao string; exit.
Se o string for "milhão", atribua "milhões" ao string; exit.
Se o string for "milissegundo", atribua "milissegundos" ao string; exit.
Se o string for "ponto", atribua "pontos" ao string; exit.
Se o string for "polígono", atribua "polígonos" ao string; exit.
Se o string for "objeto", atribua "objetos" ao string; exit.
Se o string for "grau", atribua "graus" ao string; exit.
Se o string for "preciso", atribua "precisos" ao string; exit.
Se o string for "linha", atribua "linhas" ao string; exit.
Se o string for "fileira", atribua "fileiras" ao string; exit.
Se o string for "conjunto", atribua "conjuntos" ao string; exit.
Se o string for "texto", atribua "textos" ao string; exit.
Se o string for "unidade", atribua "unidades" ao string; exit.
Se o string for "polegada", atribua "polegadas" ao string; exit.
Se o string for "endereço", atribua "endereços" ao string; exit.
Se o string for "comando", atribua "comandos" ao string; exit.
Se o string for "tipo", atribua "tipos" ao string; exit.
Se o string for "nome", atribua "nomes" ao string; exit.
Se o string for "extensão", atribua "extensões" ao string; exit.
Se o string for "rotina", atribua "rotinas" ao string; exit.
Se o string for "imagem", atribua "imagens" ao string; exit.
Se o string for "figura", atribua "figuras" ao string; exit.
Se o string for "variável", atribua "variáveis" ao string; exit.
Se o string for "cabeçalho", atribua "cabeçalhos" ao string; exit.
Se o string for "rotina", atribua "rotinas" ao string; exit.
Se o string for "tarefa", atribua "tarefas" ao string; exit.
Se o string for "procedimento", atribua "procedimentos" ao string; exit.
Se o string for "função", atribua "funções" ao string; exit.
Se o string for "redimensionador", atribua "redimensionadores" ao string; exit.
Se o string for "botão", atribua "botões" ao string; exit.
Se o string for "segmento", atribua "segmentos" ao string; exit.
Se o string for "segmento de cabeçalho", atribua "segmentos de cabeçalhos" ao string; exit.
\ nouns only
Se o string for "alumnus", atribua "alumni" ao string; exit.
Se o string for "auto", atribua "autos" ao string; exit.
Se o string for "botão", atribua "botões" ao string; exit.
Se o string for "cello", atribua "cellos" ao string; exit.
Se o string for "dwarf", atribua "dwarfs" ao string; exit.
Se o string for "foot", atribua "feet" ao string; exit.
Se o string for "forma", atribua "formas" ao string; exit.
Se o string for "genus", atribua "genera" ao string; exit.
Se o string for "goose", atribua "geese" ao string; exit.
Se o string for "hippo", atribua "hippos" ao string; exit.
Se o string for "louse", atribua "lice" ao string; exit.
Se o string for "memo", atribua "memos" ao string; exit.
Se o string for "mouse", atribua "mice" ao string; exit.
Se o string for "ox", atribua "oxen" ao string; exit.
Se o string for "phenomenon", atribua "phenomena" ao string; exit.
Se o string for "photo", atribua "photos" ao string; exit.
Se o string for "phylum", atribua "phyla" ao string; exit.
Se o string for "piano", atribua "pianos" ao string; exit.
Se o string for "pimento", atribua "pimentos" ao string; exit.
Se o string for "pro", atribua "pros" ao string; exit.
Se o string for "proof", atribua "proofs" ao string; exit.
Se o string for "radius", atribua "radii" ao string; exit.
Se o string for "rhinoceros", atribua "rhinoceri" ao string; exit.
Se o string for "roof", atribua "roofs" ao string; exit.
Se o string for "solo", atribua "solos" ao string; exit.
Se o string for "soprano", atribua "sopranos" ao string; exit.
Se o string for "staff", atribua "staffs" ao string; exit.
Se o string for "tooth", atribua "teeth" ao string; exit.
Se o string for "torus", atribua "tori" ao string; exit.
Se o string for "turf", atribua "turfs" ao string; exit.
Se o string for "virus", atribua "viruses" ao string; exit.
Se o string termina com "sh", posponha "es" para o string; exit.
Se o string termina com "ch", posponha "es" para o string; exit.
Se o string termina com "man", remove os last dois pedaços from o string; posponha "en" para o string; exit.
Se o string termina com "child", posponha "ren" para o string; exit.
Se o string termina com "ex", remove os last dois pedaços from o string; posponha "ices" para o string; exit. \ ou adicione ES
Se o string termina com "fe", remove os last dois pedaços from o string; posponha "ves" para o string; exit.
Se o string termina com "is", remove os last dois pedaços from o string; posponha "es" para o string; exit.
Se o string termina com "ix", remove os last dois pedaços from o string; posponha "ices" para o string; exit. \ ou adicione ES
Se o string termina com "ma", posponha "ta" para o string; exit. \ ou adicione S
Se o string termina com any consonant e "y", remove o last pedaço from o string; posponha "ies" para o string; exit.
Se o string termina com any vowel e "o", posponha "s" para o string; exit.
Se o string termina com any vowel e "y", posponha "s" para o string; exit.
Se o string termina com "f", remove o last pedaço from o string; posponha "ves" para o string; exit.
Se o string termina com "s", posponha "es" para o string; exit.
Se o string termina com "x", posponha "es" para o string; exit.
Se o string termina com "z", posponha "es" para o string; exit.
Posponha "s" para o string.

O prolog tag é uma tag igual a 17.

Um prototype string é um conjunto com um first endereço de memória do pedaço e um last endereço de memória do pedaço .

O push address tag é uma tag igual a 18.

O push value tag é uma tag igual a 19.

Etapas necessárias para que se atribua o endereço exe completo deste compilador para um endereço completo:
Extract um designador from o endereço da pasta deste compilador.
Remove any trailing barra invertida from o designador.
Atribua o endereço da pasta deste compilador seguido de o designador seguido de ".exe" ao endereço completo.

Etapas necessárias para que se atribua o exe size deste compilador para um size:
Atribua 4096 [section base] ao size.
Adicione o size desta import zona para o size.
Adicione o size desta zona de dados para o size.
Adicione o size desta code zona para o size.

Etapas necessárias para que se atribua o listagem endereço completo deste compilador para um endereço completo:
Extract um designador from o endereço da pasta deste compilador.
Remove any trailing barra invertida from o designador.
Atribua o endereço da pasta deste compilador seguido de o designador seguido de ".lst" ao endereço completo.

Etapas necessárias para que se atribua um termo para uma segunda termo:
Atribua a variável deste termo ao variável deste segunda termo.
Atribua a phrase deste termo ao phrase deste segunda termo.

Etapas necessárias para que se load um source file:
Se o source file for inexistente, cancele.
\Load o endereço completo deste source file ao trecho deste source file.
\Se o i/o erro não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " seguido de o endereço completo deste source file seguido de "."; exit.
Load o endereço completo deste source file para um string.
Se o i/o erro não estiver em branco, apresente uma mensagem de erro contendo "Não foi possível carregar o arquivo: " seguido de o endereço completo deste source file seguido de "."; exit.
Parse o string para o trecho deste source file (portuguese contractions e synonyms rules).

Etapas necessárias para que se load alguns source files:
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um item from o endereço da pasta deste compilador.
Se o item não for found, pare.
Se a categoria deste item não for "file", repita.
Se a extensão deste item não estiver em branco, repita.
Se o item looks reamish, repita.
Adicione um source file para o source files usando o endereço completo deste item.
Load o source file.
Repita.

O temporizador de operacionalização é um temporizador.

Etapas necessárias para que se parse um string para uma segunda string (portuguese contractions e synonyms rules):
Limpe a segunda string.
Limpe um terceiro string.
Lance um percorredor sobre o string.
Percorra.
Se o source deste percorredor estiver em branco, cancele.
Position o token deste percorredor sobre o source deste percorredor.
Mova o percorredor (code rules).
Se o target deste first deste token deste percorredor não for any glom pedaço, posponha o token deste percorredor para a segunda string; repita.
Posponha o token deste percorredor para a segunda string usando o terceiro string (portuguese contractions e synonyms rules).
Atribua o token deste percorredor ao terceiro string.
Repita.

Etapas necessárias para que se reduce alguns monikettes por utility use:
Obtenha um monikette from os monikettes.
Se o monikette for inexistente, cancele.
Se o type deste monikette for inexistente, repita.
Reduce o type deste monikette para um type por utility use.
Se o type não for inexistente, atribua o type ao type deste monikette.
Repita.

Etapas necessárias para que se reduce um type para uma segunda type por utility use:
Atribua o type ao segunda type.
Percorra.
Se a segunda type for inexistente, cancele.
Se o nome deste segunda type for "texto hexadecimal", cancele.
Se o nome deste segunda type for "string", cancele.
Se o nome deste segunda type for "número", cancele.
Se o nome deste segunda type for "endereço de memória", cancele.
Se o nome deste segunda type for "coisa", esvazie a segunda type; exit.
\PAL
\Se o nome deste segunda type for "elemento", esvazie a segunda type; exit.
Se o base type deste segunda type for a segunda type, esvazie a segunda type; exit.
Atribua o base type deste segunda type ao segunda type.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um bucket usando o catálogo de rotinas úteis.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Catalogue novamente o catálogo de rotinas úteis usando os refers deste bucket.
Repita.

Etapas necessárias para que se catalogue novamente o catálogo de rotinas úteis usando alguns refers:
Obtenha um refer from o refers.
Se o refer for inexistente, cancele.
Atribua o endereço de memória deste refer para uma routine.
Se a routine for inexistente, apresente uma mensagem de erro contendo "Erro interno na função: catálogo o utility routines usando alguns refers"; exit.
Copy os monikettes desta routine para alguns monikettes.
Reduce os monikettes por utility use.
Catalogue a routine usando os monikettes e o catálogo geral de rotinas.
Destrua os monikettes.
Repita.

Etapas necessárias para que se remove any negatives from alguns monikettes devolvendo um detector:
Desative o detector.
Swap os monikettes com alguns segunda monikettes.
Percorra.
Atribua o first destes segunda monikettes para um monikette.
Se o monikette for inexistente, cancele.
Remove o monikette from a segunda monikettes.
\PAL
Se o string deste monikette for "não", reverse o detector; destrua o monikette; repita.
Se o string deste monikette for "nada", reverse o detector; destrua o monikette; repita.
\CAL
Se o string deste monikette for "not", reverse o detector; destrua o monikette; repita.
Se o string deste monikette for "nada", reverse o detector; destrua o monikette; repita.
Posponha o monikette para os monikettes.
Se o string deste monikette for "can't", reverse o detector; atribua "can" ao string deste monikette; repita.
Se o string deste monikette for "cannot", reverse o detector; atribua "can" ao string deste monikette; repita.
Se o string deste monikette for "nothing", reverse o detector; atribua "something" ao string deste monikette; repita.
Se o string deste monikette for "won't", reverse o detector; atribua "will" ao string deste monikette; repita.
Se o string deste monikette termina com "n't", reverse o detector; remove trailing pedaços from o string deste monikette usando 3; repita.
Repita.

O repeat tag é uma tag igual a 21.

Etapas necessárias para que se resolva um campo:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o campo for inexistente, cancele.
Resolva o campo como uma variável.
Se o nickname deste campo não for any valid campo nome, limpe o nickname deste campo. \it
Se o nome deste campo não for any valid campo nome, apresente uma mensagem de erro contendo "'" seguido de o nome deste campo seguido de "' é um campo nome inválido." e o local de aparição deste campo; exit.

Etapas necessárias para que se resolva um global:
Se o global for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o global body deste global não estiver em branco, resolva o global (compile body).
Se o type nome deste global estiver em branco, apresente uma mensagem de erro contendo "Tipo inválido: " seguido de o nome deste global seguido de "' . O tipo da variável global está vazio." e o local de aparição deste global; exit.
Resolva o global como uma variável.

Etapas necessárias para que se resolva um global (compile body):
Se o global for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Lance um percorredor sobre o global body deste global.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any literal, apresente uma mensagem de erro contendo "Erro de tipo. O tipo: " seguido de o token deste percorredor seguido de "' deve ser do tipo literal." e o percorredor; exit.
Compile um literal usando o percorredor.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Acho que era bom colocar um ponto por aqui, né?" e o percorredor; exit.
Se o type nome deste global estiver em branco, atribua o nome deste type deste literal ao type nome deste global.
Atribua o literal ao literal deste global.
Catalogue o literal.

Etapas necessárias para que se resolva alguns globals:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um global from o globals.
Se o global for inexistente, cancele.
Resolva o global.
Repita.

Etapas necessárias para que se resolva um type (base type):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Encontre o base type deste type usando o base nome deste type e o catálogo de tipos.
Se o base type deste type for inexistente, apresente uma mensagem de erro contendo "Base type inválido:'" seguido de o base nome deste type seguido de "." e o local de aparição deste type; exit.
Ligue o cooking detector deste type.
Se o cooking detector deste base type deste type estiver ativo, apresente a mensagem de erro contendo "Definição recursiva com: " seguido de o base nome deste type seguido de "." e o local de aparição deste type; exit.
Resolva o base type deste type (base type).
Desative o cooking detector deste type.

Etapas necessárias para que se resolva um type (expand coisa): \ base type deste type não está resolved yet
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o base type deste type não for inexistente, cancele.
Se o nome deste type for "coisa", cancele.
\Se o nome deste type for "elemento", cancele.
Se o type não puder ser reduzido para "coisa" using o base nome, cancele.
Encontre um base type usando o base nome deste type e o catálogo de tipos.
\ adicione coisa conjunto - o número of secret campos é hard coded em two places: search por "du que 4" \ was 6
Atribua o nome deste type seguido de " conjunto" para um nome.
Atribua o nome deste type seguido de " conjuntos" para um plural nome.
Atribua o nome deste base type seguido de " conjunto" para um base nome.
Adicione um conjunto type para os types usando o nome e o plural nome e o base nome.
Adicione um campo para os campos deste conjunto type usando "next " seguido de o nome deste type e "next" e o nome deste type e o detector de ignição.
\PAL
Adicione um portuguese campo para os campos deste conjunto type usando "seguinte " seguido de o nome deste type e "seguinte" e o nome deste type e o detector de ignição.
Atribua "next " seguido de o nome deste type ao redefinition target nome deste portuguese campo.
\Adicione um portuguese reverse campo para os campos deste conjunto type usando o nome deste type seguido de " seguinte" e "seguinte" e o nome deste type e o detector de ignição.
\Atribua "next " seguido de o nome deste type ao redefinition target nome deste portuguese reverse campo.
Adicione uma segundo campo para os campos deste conjunto type usando "previous " seguido de o nome deste type e "previous" e o nome deste type e o detector de ignição.
\Adicione uma segunda portuguese campo para os campos deste conjunto type usando "anterior " seguido de o nome deste type e "anterior" e o nome deste type e o detector de ignição.
\Atribua "previous " seguido de o nome deste type ao redefinition target nome deste segunda portuguese campo.
Adicione uma segunda portuguese reverse campo para os campos deste conjunto type usando o nome deste type seguido de " anterior" e "anterior" e o nome deste type e o detector de ignição.
Atribua "previous " seguido de o nome deste type ao redefinition target nome deste segunda portuguese reverse campo.
Se os campos deste type não estiverem vazio, posponha os campos deste type para os campos deste conjunto type.
Catalogue o conjunto type.
\ fix up original type para look like um endereço de memória
Atribua o nome deste conjunto type ao target nome deste type.
\ adicione chain type
Adicione um chain type para os types usando o plural nome deste type e "" e o plural nome deste base type.
Adicione um terceiro campo para os campos deste chain type usando "first " seguido de o nome deste type e "first" e o nome deste type e o detector de ignição.
Adicione um terceiro portuguese campo para os campos deste chain type usando "primeiro " seguido de o nome deste type e "primeiro" e o nome deste type e o detector de ignição.
Atribua "first " seguido de o nome deste type ao redefinition target nome deste terceiro portuguese campo.
Adicione um terceiro feminine portuguese campo para os campos deste chain type usando "primeira " seguido de o nome deste type e "primeira" e o nome deste type e o detector de ignição.
Atribua "first " seguido de o nome deste type ao redefinition target nome deste terceiro feminine portuguese campo.
Adicione um quarto campo para os campos deste chain type usando "last " seguido de o nome deste type e "last" e o nome deste type e o detector de ignição.
Adicione um quarto portuguese campo para os campos deste chain type usando "último " seguido de o nome deste type e "último" e o nome deste type e o detector de ignição.
Atribua "last " seguido de o nome deste type ao redefinition target nome deste quarto portuguese campo.
Adicione um quarto portuguese feminine campo para os campos deste chain type usando "última " seguido de o nome deste type e "última" e o nome deste type e o detector de ignição.
Atribua "last " seguido de o nome deste type ao redefinition target nome deste quarto portuguese feminine campo.
Catalogue o chain type.

Etapas necessárias para que se resolva um type (registro de plurais):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o plural nome deste type estiver em branco, cancele.
Se o type puder ser reduzido para "coisa" using o base nome, cancele.
Catalogue o type usando o plural nome deste type.

Etapas necessárias para que se resolva um type (optional info - endereço de memória):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o target type deste type não for inexistente, cancele.
Se o target nome deste type estiver em branco, atribua o target type deste base type deste type ao target type deste type; exit.
Encontre o target type deste type usando o target nome deste type e o catálogo de tipos.
Se o target type deste type for inexistente, apresente uma mensagem de erro contendo "Não sei bem pra que coisa você está pointing at." e o local de aparição deste type; exit.

Etapas necessárias para que se resolva um type (optional info - conjunto):
Se o detector de erros deste compilador estiver ativado, cancele.
Se os campos deste type estiverem vazio, copy os campos deste base type deste type a os campos deste type; exit.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um campo from os campos deste type (backwards).
Se o campo for inexistente, pare.
Se o campo estiver duplicada em os campos deste type, apresente uma mensagem de erro contendo "O campo: " seguido de o nome deste campo seguido de "' está definido mais de uma vez." e o local de aparição deste campo; exit.
Resolva o campo.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o cooking detector deste type deste campo estiver ativo, apresente a mensagem de erro contendo "Recursive definition no: " seguido de o nome deste type deste campo seguido de "." e o local de aparição deste campo; exit.
Resolva o type deste campo (optional info). \ de novo
Se o reference detector deste campo não estiver ativo, repita.
Se o type deste campo não puder ser reduzido para "endereço de memória", apresente a mensagem de erro contendo "Não entendi o parâmetro '(reference)' nesse campo: " seguido de o nome deste campo seguido de "'..." e o local de aparição deste campo; exit.
Repita.
Eliminate duplicate nicknames from os campos deste type.
Se o type não puder ser reduzido para "coisa conjunto", cancele.
Se a contagem destes campos deste type for maior do que 4, cancele. \ already copied? was 2 por next e prev, now 6 para included Spanish redefiniions
Copy os campos deste base type deste type a os campos deste type (data campos only).

Etapas necessárias para que se resolva um type (optional info - scale):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua o base type deste type para um base type.
Se a scale deste type for 0, atribua o scale deste base type deste type ao scale deste type; exit.
Se a scale deste base type for 0, cancele.
Multiplique o scale deste type pela scale deste base type.
Atribua o base type deste base type ao base type deste type.

Etapas necessárias para que se resolva um type (optional info):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o type for inexistente, cancele.
Se o optional info resolved detector deste type estiver ativo, cancele.
Se o base type deste type for o type, cancele. \ por built em types
Check por invalid optional info sobre o type.
Ligue o cooking detector deste type.
Resolva o base type deste type (optional info).
Se o type puder ser reduzido para "endereço de memória", resolva o type (optional info - endereço de memória).
Se o type puder ser reduzido para "conjunto", resolva o type (optional info - conjunto). \ mudar aqui
Se o type puder ser reduzido para "número", resolva o type (optional info - scale).
Desative o cooking detector deste type.
Ligue o optional info resolved detector deste type.

Etapas necessárias para que se resolva alguns types (base types):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (base type).
Repita.

Etapas necessárias para que se resolva alguns types (expand coisas):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (expand coisa).
Repita.

Etapas necessárias para que se resolva alguns types (registro de plurais):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (registro de plurais).
Repita.

Etapas necessárias para que se resolva alguns types (optional info):
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um type from o types.
Se o type for inexistente, cancele.
Resolva o type (optional info).
Repita.

Etapas necessárias para que se resolva uma variável:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o variável for inexistente, cancele.
Se a type desta variável não for inexistente, cancele.
Se o type nome desta variável não estiver em branco, resolva o variável (explicit type nome); exit.
Encontre o type desta variável e o nickname desta variável usando o nome desta variável.
Se o type desta variável não for inexistente, atribua o nome deste type desta variável ao type nome desta variável; exit.
Apresente uma mensagem de erro contendo "Não achei o tipo da variável: " seguido de o nome desta variável seguido de "." e o local de aparição desta variável.

Etapas necessárias para que se resolva uma variável (explicit type nome):
Encontre o type desta variável usando o type nome desta variável e o catálogo de tipos.
Se o type desta variável for inexistente, apresente uma mensagem de erro contendo "Não achei o nome do tipo da variável: " seguido de o type nome desta variável seguido de "." e o local de aparição desta variável; exit.

O resolving globals temporizador é um temporizador.

O resolving types temporizador é um temporizador.

Etapas necessárias para que se round up zona sizes:
Atribua o length desta import zona ao size desta import zona.
Round o size desta import zona up para o nearest multiple of 4096.
Atribua o length desta zona de dados ao size desta zona de dados.
Round o size desta zona de dados up para o nearest multiple of 4096.
Atribua o length desta code zona ao size desta code zona.
Round o size desta code zona up para o nearest multiple of 4096.

O routine address tag é uma tag igual a 22.

An instruções é um subtexto.

Um routine header é um subtexto.

O catálogo geral de rotinas é um catálogo.

Um routine é uma coisa com
Um local de aparição (reference),
Um detector de compatibilidade,
Um detector de deliberação,
Um detector de função,
Um compiled detector,
Um nickname catálogo,
Um cabeçalho expandido, alguns monikettes, alguns parâmetros, um parâmetro size,
Um employs cabeçalho expandido,
Some locals, um local size,
Um routine header, um header string,
Um instruções, um body string,
Some fragments,
Um address.

Um routine reference é alguns monikettes.

O routines são algumas routines.

O save eax tag é uma tag igual a 20.

Etapas necessárias para que se examine any optional info por um type usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor for "to", examine any optional info pelo type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for "para", examine any optional info pelo type usando o percorredor (endereço de memória); exit.
Se o token deste percorredor for any com, examine any optional info pelo type usando o percorredor (conjunto); exit.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (endereço de memória):
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo indefinido, apresente uma mensagem de erro contendo "A palavra 'to' precisa de um artigo indefinido depois dela, não de um: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o target nome deste type usando o percorredor.

Etapas necessárias para que se examine any optional info por um type usando um percorredor (conjunto):
Mova o percorredor (usando diretrizes do compilador).
Examine o campos deste type usando o percorredor.

Etapas necessárias para que se examine any pauses usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any pause, cancele.
Mova o percorredor (usando diretrizes do compilador).
Repita.

Etapas necessárias para que se examine um campo usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Examine o campo usando o percorredor (type part).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor for any called, examine o campo usando o percorredor (called part); repita.
Se o token deste percorredor for "at", examine o campo usando o percorredor (redefine part); repita.
Se o token deste percorredor for "em", examine o campo usando o percorredor (redefine part); repita.
Se o token deste percorredor for "redefinindo", examine o campo usando o percorredor (redefine part); repita.
Se o token deste percorredor for any reference, examine o campo usando o percorredor (reference part); repita.

Etapas necessárias para que se examine um campo usando um percorredor (called part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o type nome deste campo estiver em branco, atribua o nome deste campo ao type nome deste campo. \ pedaço array type nome already filled in
Examine o nome deste campo usando o percorredor.

Etapas necessárias para que se examine um campo usando um percorredor (redefine part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo definido, apresente uma mensagem de erro contendo "Eu estava esperando o artigo 'the', mas o que encontrei foi: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o redefinition target nome deste campo usando o percorredor.

Etapas necessárias para que se examine um campo usando um percorredor (reference part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Ligue o reference detector deste campo.

Etapas necessárias para que se examine um campo usando um percorredor (type part - pedaço array):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o token deste percorredor para um ratio.
Reduce o ratio.
Se o denominador desta ratio não for 1, apresente uma mensagem de erro contendo "Você precisa especificar um número completo de pedaços para um pedaço array" e o percorredor; exit.
Atribua o numerador desta ratio à contagem deste campo.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for "pedaço" ou "pedaços", apresente a mensagem de erro contendo "Você precisa usar a palavra 'pedaços' depois de um counted campo designador." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Atribua "pedaço" ao type nome deste campo.

Etapas necessárias para que se examine um campo usando um percorredor (type part - normal):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor não for any artigo indefinido, apresente uma mensagem de erro contendo "Falta por um artigo idefinido aqui, mas você colocou isso: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
\Se o token deste percorredor for "another", atribua "segunda" ao nome deste campo.
\PAL
Se o token deste percorredor for "outra", atribua "outra" ao nome deste campo.
Se o token deste percorredor for "outro", atribua "outro" ao nome deste campo.
Se o token deste percorredor for "segundo", atribua "segundo" ao nome deste campo.
Se o token deste percorredor for "segunda", atribua "segunda" ao nome deste campo.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Extend o nome deste campo com o nome.

Etapas necessárias para que se examine um campo usando um percorredor (type part):
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor for any numeric literal, examine o campo usando o percorredor (type part - pedaço array); exit.
Examine o campo usando o percorredor (type part - normal).

Etapas necessárias para que se examine alguns campos usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione um campo para o campos usando "campo" e o first deste token deste percorredor.
Examine o campo usando o percorredor.
Se o token deste percorredor não for any pause, cancele.
Examine any pauses usando o percorredor.
Repita.

Etapas necessárias para que se examine um global body usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Atribua o first deste token deste percorredor ao first deste global body.
Atribua -1 ao last deste global body.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Atribua o last deste token deste percorredor ao last deste global body.
Mova o percorredor (usando diretrizes do compilador).
Repita.

Etapas necessárias para que se examine um global usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione o global para os globals usando "global" e o first deste token deste percorredor.
Mova o percorredor (usando diretrizes do compilador).
Examine o nome deste global usando o percorredor.
Se o token deste percorredor for any has, examine o global usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, apresente uma mensagem de erro contendo "Eu preciso de um 'is' ou de um 'are' mas só pude achar o termo: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo indefinido, examine o global usando o percorredor (literal termo); exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o type nome deste global usando o percorredor.
Se o token deste percorredor for o start of any optional info, examine o global usando o percorredor (optional info); exit.
Se o token deste percorredor for any operador de atribuição, examine o global usando o percorredor (data part); exit.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Toda definição precisa terminar com um ponto. Inclusive essa." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (data part):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any to, apresente uma mensagem de erro contendo "Depois da palavra 'equal' você precisa por um palavra 'to'. Você colocou;: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o global body deste global usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Falta terminar um frase com um ponto." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (has ou have):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Atribua "~inline " seguido de o nome deste global seguido de " type" para um nome.
Atribua o nome seguido de "s" para um plural nome.
Adicione um type para os types usando o nome e o plural nome e "conjunto" e o local de aparição deste global. \mudar aqui
Catalogue o type.
Atribua o nome deste type ao type nome deste global.
Examine os campos deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (literal termo):
Se o detector de erros deste compilador estiver ativado, cancele.
Examine o global body deste global usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Aprenda a escrever corretamente. Cadê o ponto final?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um global usando um percorredor (optional info):
Se o detector de erros deste compilador estiver ativado, cancele.
Atribua "~inline " seguido de o nome deste global seguido de " type" para um nome.
Atribua o nome seguido de "s" para um plural nome.
Adicione um type para os types usando o nome e o plural nome e o type nome deste global e o local de aparição deste global.
Catalogue o type.
Atribua o nome deste type ao type nome deste global.
Examine any optional info pelo type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Tá na hora de aprender a escrever direito. Cadê o ponto?." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o global.

Etapas necessárias para que se examine um nome usando um percorredor:
Limpe o nome.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre any nome starter, extend o nome com o token deste percorredor; mova o percorredor (usando diretrizes do compilador).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o percorredor estiver sobre any nome ender, pare.
Extend o nome com o token deste percorredor.
Mova o percorredor (usando diretrizes do compilador).
Repita.
Se o nome estiver em branco, apresente uma mensagem de erro contendo "Acho que faltou colocar um nome por aqui. Você escreveu: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.

Etapas necessárias para que se examine uma instruções usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any definition, cancele.
Atribua o first deste token deste percorredor ao first destas instruções.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Atribua o last deste token deste percorredor ao last destas instruções.
Se o token deste percorredor for o sinal de dois pontos, apresente uma mensagem de erro contendo "Acho que faltou um ponto lá em cima. É melhor você ir lá dar uma olhada." e o percorredor; exit.
Se o token deste percorredor não for o ponto final, mova o percorredor (usando diretrizes do compilador); repita.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for o start of any definition, cancele.
Repita.

Etapas necessárias para que se examine uma routine usando um percorredor:
\ Define o cabeçalho de rotina.
Se o detector de erros deste compilador estiver ativado, cancele.
Adicione a routine para as routines usando o first deste token deste percorredor.
Se o token deste percorredor for "Etapas", mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for "Passos", mova o percorredor (usando diretrizes do compilador). \ Pula a palavra  "Passos" ou "Etapas" e obtém o next token
Se o token deste percorredor for "necessários", mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for "necessárias", mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for "para", apresente uma mensagem de erro contendo "Você precisa escrever 'para' antes de: " seguido de o token deste percorredor seguido de "' nesse tipo de rotina." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador). \ skip o "para" e obtenha o next token
Se o token deste percorredor for "que", mova o percorredor (usando diretrizes do compilador).
\Se o token deste percorredor não for "que", apresente uma mensagem de erro contendo "Você precisa colocar um 'que' antes da palavra: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
\Mova o percorredor (usando diretrizes do compilador). \ skip o "que" e obtenha o next token
Se o token deste percorredor for "se", mova o percorredor (usando diretrizes do compilador).
\Se o token deste percorredor não for "se", apresente uma mensagem de erro contendo "Você precisa colocar um 'se' antes da palavra: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
\Mova o percorredor (usando diretrizes do compilador). \ skip o "se" e obtenha o next token
Examine a routine header desta routine usando o percorredor.
Se o token deste percorredor for o ponto&vírgula, examine a routine usando o percorredor (sobrecarga de métodos); exit. \ *** usado para nomes alternativos de rotinas
Se o token deste percorredor não for o sinal de dois pontos, apresente a mensagem de erro contendo "O nome dessa função está escrito errado.." e o local de aparição desta routine; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine as instruções desta routine usando o percorredor.

Etapas necessárias para que se examine uma routine usando um percorredor (sobrecarga de métodos):
\ *** para nomes alternativos de rotinas
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for o start of any routine, apresente uma mensagem de erro contendo "Esse ponto e vírgula tá no lugar errado." e o original percorredor; exit.
Atribua o first deste token deste original percorredor ao first destas instruções desta routine.
Atribua o last deste token deste original percorredor ao last destas instruções desta routine.
Mova o original percorredor (usando diretrizes do compilador).

Etapas necessárias para que se examine uma routine header usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Atribua o first deste token deste percorredor ao first deste routine header.
Atribua -1 ao last deste routine header.
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o ponto&vírgula, cancele. \ *** alternate palavraings
Se o token deste percorredor for o sinal de dois pontos, cancele.
Se o token deste percorredor for o ponto final, cancele.
Atribua o last deste token deste percorredor ao last deste routine header.
Mova o percorredor (usando diretrizes do compilador).
Repita.

Etapas necessárias para que se examine um source file:
Se o source file for inexistente, cancele.
Se o detector de erros deste compilador estiver ativado, cancele.
Lance um percorredor sobre o trecho deste source file.
Mova o percorredor (usando diretrizes do compilador).
Percorra.
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor estiver em branco, cancele.
Se o token deste percorredor for o start of any type, examine um type usando o percorredor; repita.
Se o token deste percorredor for o start of any global, examine um global usando o percorredor; repita.
Se o token deste percorredor for o start of any routine, examine uma routine usando o percorredor; repita.
Apresente uma mensagem de erro contendo "Faltou definir melhor o que é o: " seguido de o token deste percorredor seguido de "." e o percorredor.
Repita.

Etapas necessárias para que se examine alguns source files:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um source file from o source files.
Se o source file for inexistente, cancele.
Examine o source file.
Repita.

Etapas necessárias para que se examine um type usando um percorredor:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o token deste percorredor for any artigo indefinido português, acione um portuguese detector.
Se o token deste percorredor for any artigo indefinido inglês, acione um english detector.
Adicione o type para os types usando o first deste token deste percorredor.
Mova o percorredor (usando diretrizes do compilador).
Examine o nome deste type usando o percorredor.
Atribua o nome deste type ao plural nome deste type.
Se o portuguese detector estiver ativo, pluralize o plural nome deste type (portuguese rules).
Se o english detector estiver ativo, pluralize o plural nome deste type (english rules).
Se o english detector não estiver ativo, pluralize o plural nome deste type (portuguese rules).
Se o token deste percorredor for any has, examine o type usando o percorredor (has ou have); exit.
Se o token deste percorredor não for any is, apresente uma mensagem de erro contendo "Eu esperava um 'is' ou um 'are', mas só achei um " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
\Pluralize o plural nome deste type.
\Se o token deste percorredor for "has" ou "have", examine o type usando o percorredor (has ou have); exit.
\Se o token deste percorredor não for "is" ou "are", apresente uma mensagem de erro contendo "I was expecting um 'is' ou 'are', but I found: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.

Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor for any numeric literal, examine o type usando o percorredor (unit of measure); exit.
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Faltou um artigo indefinido, lembra?: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o base nome deste type usando o percorredor.
Examine any optional info pelo type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Você precisa usar um ponto para definir um tipo, lembra? Você usou: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (has ou have):
Se o detector de erros deste compilador estiver ativado, cancele.
Mova o percorredor (usando diretrizes do compilador).
Atribua "conjunto" ao base nome deste type. \\mudar aqui
Examine o campos deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente uma mensagem de erro contendo "Ao invés de usar o ponto para definir tipo, você usou: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o type.

Etapas necessárias para que se examine um type usando um percorredor (unit of measure):
Se o detector de erros deste compilador estiver ativado, cancele.
Converta o token deste percorredor para o scale deste type.
Se o scale deste type for 0, apresente uma mensagem de erro contendo "Zero é um tipo de escala inválido." e o local de aparição deste type; exit.
Mova o percorredor (usando diretrizes do compilador).
Examine o base nome deste type usando o percorredor.
Se o token deste percorredor não for o ponto final, apresente a mensagem de erro contendo "Os tipos precisam terminar com um ponto, não com: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Mova o percorredor (usando diretrizes do compilador).
Catalogue o type.

O temporizador de análise/verificação é um temporizador.

Um scratch é um local.

Etapas necessárias para que se scrub um catálogo:
Obtenha um bucket usando o catálogo.
Se o bucket for inexistente, cancele.
Se os refers deste bucket estiverem vazio, repita.
Scrub os refers deste bucket.
Repita.

Etapas necessárias para que se scrub alguns refers:
Swap o refers com alguns segunda refers.
Percorra.
Atribua o first destes segunda refers para um refer.
Se o refer for inexistente, cancele.
Remove o refer from a segunda refers.
Se o endereço de memória deste refer for inexistente, destrua o refer; repita.
Posponha o refer para os refers.
Repita.

Etapas necessárias para que se ative o compiled detector em uma variável;
Etapas necessárias para que se ligue o compiled detector em uma variável:
Se o variável for inexistente, cancele.
Se o compiled detector desta variável [já] estiver ativo, cancele.
Ligue o compiled detector desta variável.
Se a categoria desta variável não for "global", cancele.
Se o literal desta variável for inexistente, cancele.
Encontre uma routine usando "atribua" e o type deste literal desta variável e "para" e o type desta variável.
Se a routine for inexistente, encontre a routine usando "converta" e o type deste literal desta variável e "para" e o type desta variável; acione um detector.
Se a routine for inexistente, apresente uma mensagem de erro contendo "O tipo dessa variável global e desse literal não são compatíveis." e o local de aparição desta variável; exit.
Compile o body of a routine.
Se o detector estiver ativo, atribua "converta o " seguido de o nome deste literal desta variável seguido de " para o " seguido de o nome desta variável seguido de ". " ao initializer string desta variável.
Se o detector não estiver ativo, atribua "atribua o " seguido de o nome deste literal desta variável seguido de " para o " seguido de o nome desta variável seguido de ". " ao initializer string desta variável. \ Era " ao ". NÃO PODIA MUDAR O " ao " não sei o porquê

Etapas necessárias para que se skip para o next palavra em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste first deste subtexto for noise, pare.
Adicione 1 para o first deste subtexto.
Repita.
Skip any leading noise no subtexto.

Etapas necessárias para que se skip para o previous palavra em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto for noise, pare.
Subtraia 1 from o last deste subtexto.
Repita.
Skip any trailing noise no subtexto.

An source file é uma coisa com um endereço completo e um trecho.

O source files são alguns source files.

Um tag é um número.

Um termo é um conjunto com uma variável e um phrase.

Etapas necessárias para que se transmogrify um fragment:
Se o detector de erros deste compilador estiver ativado, cancele.
Se o fragment for inexistente, cancele.
Se a tag deste fragment for o push address tag, transmogrify o fragment (push address); exit.
Se a tag deste fragment for o call internal tag, transmogrify o fragment (call internal); exit.
Se a tag deste fragment for o load address tag, transmogrify o fragment (load address); exit.
Se a tag deste fragment for o increment tag, transmogrify o fragment (increment); exit.
Se a tag deste fragment for o dereference tag, transmogrify o fragment (dereference); exit.
Se a tag deste fragment for o jump false tag, transmogrify o fragment (jump false); exit.
Se a tag deste fragment for o not tag, transmogrify o fragment (not); exit.
Se a tag deste fragment for o exit tag, transmogrify o fragment (exit); exit.
Se a tag deste fragment for o repeat tag, transmogrify o fragment (repeat); exit.
Se a tag deste fragment for o break tag, transmogrify o fragment (break); exit.
Se a tag deste fragment for o prolog tag, transmogrify o fragment (prolog); exit.
Se a tag deste fragment for o epilog tag, transmogrify o fragment (epilog); exit.
Se a tag deste fragment for o push value tag, transmogrify o fragment (push value); exit.
Se a tag deste fragment for o call external tag, transmogrify o fragment (call external); exit.
Se a tag deste fragment for o load eax tag, transmogrify o fragment (load eax); exit.
Se a tag deste fragment for o save eax tag, transmogrify o fragment (save eax); exit.
Se a tag deste fragment for o call indirect tag, transmogrify o fragment (call indirect); exit.
Se a tag deste fragment for a routine address tag, transmogrify o fragment (routine address); exit.

Etapas necessárias para que se transmogrify um fragment (break):
Atribua o repeat tag para uma tag.
Encontre um segundo fragment usando o fragment e o tag.
Se o segundo fragment for inexistente, atribua o finalize tag ao tag. \ por break sem um loop ou after um loop
Encontre um terceiro fragment usando o last deste fragments desta rotina utilizada atualmente e o tag (backwards).
Se o terceiro fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (break)"; exit.
Se o next deste terceiro fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (break)"; exit.
Attach $E9 e o address deste next deste terceiro fragment para o fragment. \ JMP o address da destination

Etapas necessárias para que se transmogrify um fragment (call external):
Attach $FF15 e o address desta entry deste fragment para o code deste fragment. \ call [o address desta entry deste fragment ]

Etapas necessárias para que se transmogrify um fragment (call indirect):
Attach address loading code para o code deste fragment usando o variável deste fragment. \ coloca address para edx
Attach $FF12 para o code deste fragment. \ call [edx]

Etapas necessárias para que se transmogrify um fragment (call internal):
Obtenha um address usando o routine deste fragment.
Attach $E8 e o address para o fragment. \ call o address da routine do fragment 

Etapas necessárias para que se transmogrify um fragment (dereference):
Attach $8B95 e o offset desta variável deste fragment para o code deste fragment. \ mov edx,[ebp+ o offset desta variável deste fragment]
Attach $8B12 para o code deste fragment. \ mov edx,[edx]
Attach $8995 e o offset desta variável deste fragment para o code deste fragment. \ mov [ebp+ o offset desta variável deste fragment]

Etapas necessárias para que se transmogrify um fragment (epilog):
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, attach $5F5E5B para o code deste fragment. \ pop edi, esi, ebx
Attach $8BE5 para o code deste fragment. \ mov esp,ebp
Attach $5D para o code deste fragment. \ pop ebp
Attach $C2 e o parâmetro size desta rotina utilizada atualmente para o code deste fragment. \ ret o parâmetro size da rotina utilizada atualmente

Etapas necessárias para que se transmogrify um fragment (exit):
Encontre um segundo fragment usando o fragment e o finalize tag.
Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (exit)"; exit.
Attach $E9 e o address deste segundo fragment para o fragment. \ jmp o address da destination

Etapas necessárias para que se transmogrify um fragment (increment):
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (increment)"; exit.
Se a categoria desta variável deste fragment não for "scratch", apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (increment)"; exit.
Attach $8185 e o offset desta variável deste fragment e o número deste fragment para o code deste fragment. \ add [ebp+ o offset desta variável deste fragment], o número deste fragment

Etapas necessárias para que se transmogrify um fragment (jump false):
Encontre um segundo fragment usando o fragment e o end if tag.
Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (jump false)"; exit.
Attach $83F800 para o code deste fragment. \ cmp eax,0
Attach $0F84 e o address deste segundo fragment para o fragment. \ je o address da destination

Etapas necessárias para que se transmogrify um fragment (load address):
Attach address loading code para o code deste fragment usando a variável deste fragment. \ atribua address para edx
Attach $8995 e o offset desta segunda variável deste fragment para o code deste fragment. \ mov [ebp+ o offset desta variável deste fragment],edx

\Etapas necessárias para que se transmogrify um fragment (load eax):
\Attach address loading code para o code deste fragment usando a variável deste fragment. \ atribua address para edx
\Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variável deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 para o code deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (load eax):
Attach $B8 e o detector deste fragment para o code deste fragment. \ mov eax,detector
\Attach address loading code para o code deste fragment usando a variável do fragment. \ atribua address para edx
\Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro - transmogrify um fragment (load eax)"; exit.
\Se o type desta variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Internal erro 2 - transmogrify um fragment (load eax)"; exit.
\Se o length deste type desta variável deste fragment não for 4, apresente uma mensagem de erro contendo "Internal erro 3 - transmogrify um fragment (load eax)"; exit.
\Attach $8B02 para o code deste fragment. \ mov eax,[edx]

Etapas necessárias para que se transmogrify um fragment (not):
Attach $83F001 para o code deste fragment. \ xor eax,1

Etapas necessárias para que se transmogrify um fragment (prolog):
Attach $55 para o code deste fragment. \ push ebp
Attach $8BEC para o code deste fragment. \ mov ebp,esp
Atribua o local size desta rotina utilizada atualmente dividido por 4 para um número.
Se o número não for 0, attach $B9 e o número e $6A004975FB para o code deste fragment. \ mov ecx,number; loop: push 0; dec ecx; jnz loop
Se o detector de compatibilidade desta rotina utilizada atualmente estiver ativo, attach $535657 para o code deste fragment. \ push ebx, esi, edi

Etapas necessárias para que se transmogrify um fragment (push address):
Attach address loading code para o code deste fragment usando a variável deste fragment. \ atribua address para edx
Attach $52 para o code deste fragment. \ push edx

Etapas necessárias para que se transmogrify um fragment (push value):
Attach address loading code para o code deste fragment usando a variável deste fragment. \ atribua address para edx
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (push value)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (push value)"; exit.
Atribua o length deste type desta variável deste fragment para um length.
Se o length for 4, attach $FF32 para o code deste fragment; exit. \ push [edx]
Se o length for 2, attach $66FF32 para o code deste fragment; exit. \ push palavra ptr [edx]
Se o length for 1, attach $0FB61252 para o code deste fragment; exit. \ movzxb edx,[edx]; push edx
Apresente a mensagem de erro contendo "Erro interno 3 - transmogrify um fragment (push value)".

Etapas necessárias para que se transmogrify um fragment (repeat):
Encontre um segundo fragment usando o fragment e o loop tag (backwards).
Se o segundo fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (repeat)"; exit.
Attach $E9 e o address deste segundo fragment para o fragment. \ jmp o address da destination 

Etapas necessárias para que se transmogrify um fragment (routine address):
Attach address loading code para o code deste fragment usando a variável deste fragment. \ atribua address para edx
Se a routine deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (routine address)"; exit.
Obtenha um address usando a routine deste fragment.
Attach $C702 e o address para o code deste fragment. \ mov [edx],the address

Etapas necessárias para que se transmogrify um fragment (save eax):
Attach address loading code para o code deste fragment usando a variável deste fragment. \ atribua address para edx
Se a variável deste fragment for inexistente, apresente uma mensagem de erro contendo "Erro interno - transmogrify um fragment (save eax)"; exit.
Se o type desta variável deste fragment for inexistente, apresente a mensagem de erro contendo "Erro interno 2 - transmogrify um fragment (save eax)"; exit.
Atribua o length deste type desta variável deste fragment para um length.
Se o length for 4, attach $8902 para o code deste fragment; exit. \ mov [edx],eax
Se o length for 2, attach $668902 para o code deste fragment; exit. \ mov [edx],ax
Se o length for 1, attach $8802 para o code deste fragment; exit. \ mov [edx],al
Apresente a mensagem de erro contendo "Erro interno 3 - transmogrify um fragment (save eax)".

Etapas necessárias para que se transmogrify alguns fragments:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha um fragment from o fragments.
Se o fragment for inexistente, cancele.
Transmogrify o fragment.
Repita.

Etapas necessárias para que se transmogrify uma routine:
Se o detector de erros deste compilador estiver ativado, cancele.
Se a routine for inexistente, cancele.
Se o employs cabeçalho expandido desta routine não estiver em branco, cancele.
Se o compiled detector desta routine não estiver ativo, cancele.
Atribua a routine à rotina utilizada atualmente.
Transmogrify os fragments desta routine.

Etapas necessárias para que se transmogrify alguns routines:
Se o detector de erros deste compilador estiver ativado, cancele.
Obtenha uma routine from as routines.
Se a routine for inexistente, pare.
Transmogrify a routine.
Repita.

O transmogrifying temporizador é um temporizador.

O catálogo de tipos é um catálogo.

Um type é uma coisa com
Um local de aparição (reference),
Um nome, um plural nome,
Um cabeçalho semi-expandido,
Um length,
Um base nome, um base type (reference),
Um target nome, um target type (reference) [endereço de memórias only],
Um scale ratio,
Some campos [records only],
Um cooking detector,
Um optional info resolved detector.

Um type nome é um nome.

O types são alguns types.

O catálogo de rotinas úteis é um catálogo.

Um variável é uma coisa com
Um local de aparição (reference),
Um categoria [literal, global, local, parâmetro, scratch],
Um compiled detector,
Um nome, um nickname, um type nome,
Um type (reference), \ actual type sobre literal, global, local; dereferenced type sobre parâmetros e scratches
Um address [globals e literals only] ou 
Um offset at o address [locals, parâmetros, e campos only],
Um contagem [campos only],
Um reference detector [campos only],
Um redefinition target nome [campos only],
Um by-value detector [parâmetros only],
Um global body [globals only],
Um initializer string [globals only],
Um literal (reference) [globals only - constant com which to initalize the global],
Um texto hexadecimal called data [literals only].

O writing temporizador é um temporizador.

Etapas necessárias para que se skip any trailing noise em um subtexto:
Se o subtexto estiver em branco, cancele.
Se o target deste last deste subtexto não for noise, cancele.
Subtraia 1 from o last deste subtexto.
Repita.

\ dahn - reverse functions
\ para put o xxx uv a/the yyy para zzz
\ internally we turn this para "to put a/the yyy's xxx para zzz"
Etapas necessárias para que se compile o header of uma routine usando um percorredor (função do possessivo reverso):
Se o detector de erros deste compilador estiver ativado, cancele.
Ligue o detector de função desta routine.
Adicione um monikette para os monikettes desta routine usando "atribua".
Mova o percorredor (usando diretrizes do compilador). \ skip "atribua" ou "poner"
Mova o percorredor (usando diretrizes do compilador). \ skip "the" ou Portuguese artigo definido
Examine um nome usando o percorredor. \ campo nome
Mova o percorredor (usando diretrizes do compilador). \ skip "uv" ou "de"
Se o token deste percorredor for any artigo indefinido, acione um detector.
Se o detector estiver ativo, compile os monikettes desta routine e o parâmetros desta routine usando o percorredor (artigo indefinido).
Se o detector não estiver ativo, compile os monikettes desta routine e o parâmetros desta routine usando o percorredor (artigo definido).
Adicione uma segunda monikette para os monikettes desta routine usando "'s " seguido de o nome.
Se o token deste percorredor não for any reverse-possessive function into, apresente uma mensagem de erro contendo "Esperava a palavra 'em', mas encontrei: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Adicione um terceiro monikette para os monikettes desta routine usando "para".
Converta os monikettes desta routine para um cabeçalho expandido.
Se o cabeçalho expandido estiver no catálogo geral de rotinas, apresente a mensagem de erro contendo "Já sei como: " seguido de o cabeçalho expandido seguido de "." e o local de aparição desta routine; exit.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo indefinido, apresente a mensagem de erro contendo "Esperava um artigo indefinido, mas encontrei: " seguido de o token deste percorredor seguido de "." e o percorredor; exit.
Compile os monikettes desta routine e o parâmetros desta routine usando o percorredor (artigo indefinido).
Se o token deste percorredor não estiver em branco, apresente a mensagem de erro contendo "Existem outras coisas no final desta função." e o percorredor; exit.
Converta os monikettes desta routine para o cabeçalho expandido desta routine.
Catalogue a routine usando os monikettes desta routine e o catálogo geral de rotinas. \ por employs

\ dahn - reverse functions
\ para atribua o xxx uv a/the yyy para zzz
Etapas necessárias para que se determine se um percorredor é o start of any reverse-possessive function:
Se o detector de erros deste compilador estiver ativo, diga não.
Se o token deste percorredor não for any atribua, diga não.
Isole o percorredor.
Mova o percorredor (usando diretrizes do compilador).
Se o token deste percorredor não for any artigo definido, diga não.
Mova o percorredor (usando diretrizes do compilador).
Examine um nome usando o percorredor.
Se o percorredor não for sobre any reverse-possessive, diga não.
Diga sim.
\finalmente